# 开机流程、模块管理与 Loader

系统开机其实是一项非常复杂的程序，因为核心需要检测硬件并加载适当的驱动程序后，接下来必须要调用程序来准备好系统运行的环境，让使用者能够顺利的操作整部主机系统。

如果能够理解开机原理，当系统出现问题时，就能很快速的修复系统，而且还能顺利的配置多重操作系统的多重引导问题，为了多重引导的问题，那么就需要学习 grub2 这个 Linux 下优秀的开机管理程序（boot loader）

在系统运行期间，也需要学会管理核心模块

::: tip
本章没有接触过的东西较多，笔者基本上全程都很难理解在讲什么，只好大部分都直接抄下来的。只有小部分能跟着练习，因此感觉看看就好
:::

## Linux 的开机流程分析

为什么要了解开机流程？下面又几个常见的场景：

- 如果想多重引导，怎么安全系统？
- 如果你的 root 密码忘记了，如何救援？
- 如果你的默认登录模式为图形界面，如果在开机时直接指定进入纯文本模式？
- 如果因为 `/etc/fstab` 设置错误，导致无法顺利挂载根目录，如何修复 `/etc/fstab` 文件？

笔者当时其实就因为 fstab 文件配置错误，导致开机进入不了系统的问题，当时通过第 3 章中的知识点，还好救援回来了。可见是真的很重要

## 开机流程一览

开机管理程序（Boot Loader），由于各大 Linux distribution 的主流为 grub2，下面就以它为主讲解

简单来说，系统开机的经过可以总结如下的流程：

1. 加载 BISO 的硬件信息与进行自我测试，并根据设置获得第一个可开机的设备

2. 读取并执行第一个开机设备内 MBR 的 boot Loader（grub2、spfdisk 等程序）

3. 根据 boot loader 的设置加载 Kernel，Kernel 会开始检测硬件与加载驱动程序

4. 在硬件驱动成功后，Kernel 会调用 systemd 程序，并以 default.target 的流程开机：

   - systemd 执行 sysinit.target 初始系统以及 bashic.target 准备操作系统

   - systemd 启动 multi-user.target 下的本机与服务器服务

   - systemd 执行 multi-user.target 下的`/etc/rc.d/rc.local` 文件
   - systemd 执行 multi-user.target 下的 `getty.target` 及登录服务
   - systemd 执行 graphical 需要的服务

大概流程如上，会发现 systemd 程序占比非常重，下面来谈谈各个程序的主要内容是什么

## BIOS、boot loader 与 kernel 载入

在第 2 章中简单的讲解过开机流程与 MBR 的功能，以及大容量磁盘需要使用 GPT 分区格式等。这里只把后续会用到的部分专有名词综合解释：

- BIOS：无论传统 BIOS 还是 UEFI BIOS 统称 BIOS
- MBR：分区表有传统 MBR 和新式 GPT，GPT 也保留一块兼容 MBR 的区块，因此后续的说明在安装 boot loader 的部分，都简称 MBR，总之， MBR 就代表该磁盘最前面可安装 boot loader 的哪个区块

### BIOS 开机自我测试与 MBR/GPT

BIOS：在第 0 章的计算机概论中谈过，在个人计算机架构下，要启动整部系统，需要让系统去加载 BIOS （Basic Output System），并通过 BIOS 程序与加载 CMOS 的信息，获取 CMOS 内的设置取得主机的各项硬件配置，例如 CPU 与接口设备的沟通频率、开机设备的搜索顺序、硬盘的大小、系统时间、各周边总线是否启动 Plug and Play （PnP 即插即用设备）等信息

开机自我测试：BIOS 取得上述信息后，会进行开机自我测试（Power-on Self Test，简称 POST）。然后执行硬件检测初始化，并设置 PnP 装置，之后再定义出可开机的设备顺序，接下来会开始进行开机设备的数据读取

MBR：系统软件大多放置在硬盘中，所以 BIOS 会指定开机的设备让我们可以读取磁盘中的操作系统核心文件，但是由于不同的操作系统的文件系统格式不同，因此需要一个开机管理程序来处理核心文件加载 （load）的问题，因此整个 **开机管理程序被称为 Boot Loader **，Boot Loader 程序安装在开机设备的第一个扇区（sector）内，整个扇区也称为 **MBR（Master Boot Record）** 主要启动记录区

每个操作系统的 loader 都可能不同，BIOS 通过硬件的 INT 13 中断功能来读取 MBR 的，也就是说，只要 BIOS 能够检测到你的硬盘（不论该磁盘是 SATA 还是 SAS 接口），它就有办法通过 INT 13 这个信道来读取该磁盘的第一个扇区内的 MBR 软件

注意：如果系统中有两块硬盘，那么查找的是第一启动设备中的 MBR

### Boot Loader 功能

Loader 最主要的功能是认识操作系统的文件格式并根据加载核心到主存储器去执行。由于不同操作系统的文件格式不一致，因此每种操作系统都有自己的 boot loader。

那么多重操作系统：就是在不一部追上安装多中不同的操作系统

1. 必须要使用自己的 loader 才能够加载属于自己的操作系统核心
2. 但是系统的 MBR 只有一个，那么怎么能让同一台主机上安装 windows 与 Linux 呢？

这个问题在第 7 章的磁盘文件系统中有介绍到过。每个文件系统（filesystem 或 partition）都会保留一块启动扇区（boot sector）提供操作系统安装 boot loader，通常操作系统默认会安装一份 loader 到它根目录所在的文件系统的 boot sector 上。

如果在一台主机上安装 Windows 与 Linux 后，boot sector、boot loader 与 MBR 的相关系如下图所示

![image-20200323222234528](http://p6ui.toweydoc.tech:20080/images/stydocs/image-20200323222234528.png)

如上图所示，每个操作系统默认会安装一套 boot loader 到他自己的文件系统中（左下角的蓝色区域）：

- Linux 系统：安装时，你可以选择 boot loader 安装到 MBR 上，也可以选择不安装。如果选择安装到 MBR 的话，理论上你再 MBR 与 boot sector 都会有一份 boot loader 程序。
- Windows：安装时，它默认主动的将 MBR  与 boot sector 都装上一份 boot loader

所以会发现安装多重操作系统时，你的 MBR 常常会被不同的操作系统的 boot loader 所覆盖。

那么怎么解决多重操作系统的问题呢？在第 2 章中提到过，boot loader 的功能

- 提供选单：用户可以选择不同的开机项目，这也是多重引导的重要功能
- 载入核心文件：直接执行可开机的程序区段来开始操作系统
- 转交其他 loader：将开机管理功能转交给其他 loader 负责

由于具有选单功能，可以选择不同的核心来开机。由于具有控制权限转交功能，因此可以加载其他 boot sector 内的 loader。但是 Windows 的 loader 预设不具有控制转交的功能，因此你不能使用 Windows 的 loader 来加载 Linux 的 loader。这也是为什么会强调 **先装 windows，再装 Linux** 的缘故。

上述三个功能图下图所示：

![image-20200323223119255](http://p6ui.toweydoc.tech:20080/images/stydocs/image-20200323223119255.png)

上图，MBR 使用 Linux 的 grub2 开机管理程序，并且设置了 3 个选单：

- 选单 1：MBR（grub2） -> kernel file -> booting
- 选单 2：MBR（grub2） -> boot sector（Windows loader） -> Windows kernel -> booting
- 选单 3：MBR（grub2） -> boot sector（grub2）-> kernel file -> booting

### 加载核心检查硬件与 initramfs 功能

通过 boot loader 的管理而开始读取核心文件后，加下来，Linux 会将核心解压到主存储器中，并利用核心的功能，开始测试与驱动各个周边设备，包括存储设备、CPU、网卡、声卡等。

**此时 Linux 核心会以自己的功能重新检查一次硬件，而不一定会使用 BIOS 检测到的硬件信息，也就是说，核心此时才开始接管 BIOS 后的工作 **。一般来说，核心文件会放到 `/boot` 中，并取名为 `/boot/vmlinuz`

```bash
[root@study ~]# ls --format=single-column -F /boot
config-3.10.0-1062.el7.x86_64																# 此版本核心被编译时选择的功能与模块配置文件
efi/																												# 书上没有这个
grub/																												# 旧版 grub1，不用管
grub2/																											# 开机管理程序 grub2 的目录
initramfs-0-rescue-f228ab37c368416c84c6b27971ba45a9.img			# 虚拟文件系统，用来救援的
initramfs-3.10.0-1062.el7.x86_64.img												# 正常开机会用到的虚拟文件系统
initramfs-3.10.0-1062.el7.x86_64kdump.img										# 核心出问题时会用到的虚拟文件系统；笔者这里没有看到这个文件
System.map-3.10.0-1062.el7.x86_64														# 核心功能放到内存地址的对应表
symvers-3.10.0-1062.el7.x86_64.gz														# 书上没有这个
vmlinuz-0-rescue-f228ab37c368416c84c6b27971ba45a9*					# 救援用的核心文件
vmlinuz-3.10.0-1062.el7.x86_64*															# 核心文件，最重要的
testing.img																									# 书上没有这个
```

上面可知道 CentOS 7.x 的 Linux 核心为 3.10.0-1062.el7.x86_64 版本。为了硬件开发商与其他核心功能开发者的便利，因此 Linux 核心是可以通过动态加载核心模块的（可想象成驱动程序），这些核心模块放在 `/lib/modules/` 目录内。

**由于模块放置到磁盘根目录内（记得 /lib  不可以与 /  分别放在不同的 partition）！，因此在开机的过程中核心必须要挂载根目录，这样才能读取核心模块提供价值驱动程序的功能**。而且为了担心影响到磁盘内的文件系统，因此开机过程中根目录是只读方式来挂载的

一般来说，非必要的功能且可以编译成模块的核心功能，目前的 Linux distribution 都会将它编译成模块。因此 USB、SATA、SCSI 等磁盘设备的驱动程序通常都是以模块的方式存在的。

考虑一种情况：你的 Linux 是安装在 SATA 磁盘上面的，可以通过 BIOS 的 INT 13 获取 boot loader 与 kernel 文件来开机，然后 kernel 会开始接管系统并且检查硬件及长沙挂载根目录来获取额外的驱动程序

问题是：**核心根本不认识 SATA 磁盘**，所以需要加载 SATA 磁盘的驱动程序，否则根本无法挂载根目录。但是 SATA 的驱动程序在 `/lib/modules` 内，你根本无法挂载根目录，就没法读取到 SATA 的驱动程序。

在这种情况下，LInux 是无法顺利开机的，但是可以使用虚拟文件系统来处理这个问题

**虚拟文件系统（Initial RAM Disk 或 Initial RAM Filesystem）** 一般使用 `/boot/initrd` 或 `/boot/initramfs`，该文件特点是，它也可以通过 boot loader 来加载到内存中，然后该文件会被解压缩并且在内存中 **仿真成一个根目录**，且此仿真在内存中的文件系统能够提供一个可执行的程序，通过该程序来 **加载开机过程中所最需要的核心模块**，等载入完成后，会帮助核心重新调用 systemd 来开始后续的正常开机流程

BIOS 与 boot loader 、核心加载流程示意图如下：

![image-20200323225642529](http://p6ui.toweydoc.tech:20080/images/stydocs/image-20200323225642529.png)

如图所示：boot loader 可以加载 kernel 与 initramfs，在内存中让 initramfs 解压缩成为根目录，kernel 借此加载适当的驱动程序，最终释放虚拟文件系统，并挂载实际的根目录文件系统，就可以开始后续的正常开机流程了

下面来了解下 CentOS 7.x 的 initramfs 文件内容

```bash
# 1. 直接看 initramfs 里的内容有哪些
[root@study ~]# lsinitrd /boot/initramfs-3.10.0-1062.el7.x86_64.img 
Image: /boot/initramfs-3.10.0-1062.el7.x86_64.img: 31M
========================================================================
这一部分数据笔者并没有看到有
Early CPIO image
kernel  kernel/x86
========================================================================

========================================================================
Version: dracut-033-564.el7

Arguments: -f

# 开始一堆模块的加载行为
dracut modules:
bash
nss-softokn
...
========================================================================
drwxr-xr-x  12 root     root            0 Oct  4 18:31 .
crw-r--r--   1 root     root       5,   1 Oct  4 18:31 dev/console
crw-r--r--   1 root     root       1,  11 Oct  4 18:31 dev/kmsg
crw-r--r--   1 root     root       1,   3 Oct  4 18:31 dev/null
lrwxrwxrwx   1 root     root            7 Oct  4 18:31 bin -> usr/bin
...
-rwxr-xr-x   1 root     root      1624552 Oct  4 18:31 usr/lib/systemd/systemd
...
-rw-r--r--   1 root     root         1377 Sep  7  2017 usr/share/terminfo/v/vt220
drwxr-xr-x   2 root     root            0 Oct  4 18:31 var
lrwxrwxrwx   1 root     root           11 Oct  4 18:31 var/lock -> ../run/lock
lrwxrwxrwx   1 root     root            6 Oct  4 18:31 var/run -> ../run
========================================================================
# 最后则会列出这个 initramfs 里所有的文件，也就是说，该文件大概存储两部分内容
# 1. 最前面核心文件 # 笔者这个里面没有这些数据
# 2. 被核心取用的全部附加的文件数据
```

下面解压下该 img 的文件，来看看里面的文件内容

提示：笔者机器上与书上一部分对不上，所以暂时不确定是否能正常解压

```bash
[root@study ~]# mkdir /tmp/initramfs
[root@study ~]# cd /tmp/initramfs
[root@study initramfs]# ll /boot/
total 135200
...
-rw-------. 1 root root 31799826 Oct  4 18:32 initramfs-3.10.0-1062.el7.x86_64.img
...
# 1. 跳过部分文件，这一步不跳过可以省略，直接复制原来的文件就可以
# 我这里没有跳过文件，可以看到 31799826 和上面的文件大小是一样的
# 书上是在下面的指令后面写了 skip 1; 跳过了一个 11264 的块，但是作者怎么知道这个大小是他需要跳过的文件大小呢？
[root@study initramfs]# dd if=/boot/initramfs-3.10.0-1062.el7.x86_64.img of=initramfs.gz bs=11264       
2823+1 records in
2823+1 records out
31799826 bytes (32 MB) copied, 0.0366742 s, 867 MB/s
[root@study initramfs]# ll initramfs.gz; file initramfs.gz 
-rw-r--r--. 1 root root 31799826 Mar 24 21:54 initramfs.gz
initramfs.gz: gzip compressed data, from Unix, last modified: Fri Oct  4 18:31:46 2019, max compression
# dd 语法还可以直接写一个压缩文件？还有这种神奇的用法？
# 上面和下面都用到了 file，因此笔者猜想，上面使用 dd 纯粹是为了跳过某些文件罢了
# 实际上 img 是一个 gizp 的压缩文件，可以从下面的结果看出来
[root@study initramfs]# file /boot/initramfs-3.10.0-1062.el7.x86_64.img 
/boot/initramfs-3.10.0-1062.el7.x86_64.img: gzip compressed data, from Unix, last modified: Fri Oct  4 18:31:46 2019, max compression
# 的确显示是 gzip 文件

# 2. 从文件来看，是一个 gz 文件，解压该压缩文件，查看文件内容
[root@study initramfs]# gzip -d initramfs.gz 
[root@study initramfs]# file initramfs 
initramfs: ASCII cpio archive (SVR4 with no CRC)

# 3. 解压之后，又产生了一个 cpio 的文件
# 使用 cpio 来解压，并且不要绝对路径是最保险的
[root@study initramfs]# cpio -i -H newc --no-absolute-filenames < initramfs 
128695 blocks
[root@study initramfs]# ll
total 64356
lrwxrwxrwx.  1 root root        7 Mar 24 22:05 bin -> usr/bin
drwxr-xr-x.  2 root root       45 Mar 24 22:05 dev
drwxr-xr-x. 12 root root     4096 Mar 24 22:05 etc
lrwxrwxrwx.  1 root root       23 Mar 24 22:05 init -> usr/lib/systemd/systemd
-rw-r--r--.  1 root root 65891840 Mar 24 21:54 initramfs
lrwxrwxrwx.  1 root root        7 Mar 24 22:05 lib -> usr/lib
lrwxrwxrwx.  1 root root        9 Mar 24 22:05 lib64 -> usr/lib64
drwxr-xr-x.  2 root root        6 Mar 24 22:05 proc
drwxr-xr-x.  2 root root        6 Mar 24 22:05 root
drwxr-xr-x.  2 root root        6 Mar 24 22:05 run
lrwxrwxrwx.  1 root root        8 Mar 24 22:05 sbin -> usr/sbin
-rwxr-xr-x.  1 root root     3117 Mar 24 22:05 shutdown
drwxr-xr-x.  2 root root        6 Mar 24 22:05 sys
drwxr-xr-x.  2 root root        6 Mar 24 22:05 sysroot
drwxr-xr-x.  2 root root        6 Mar 24 22:05 tmp
drwxr-xr-x.  7 root root       66 Mar 24 22:05 usr
drwxr-xr-x.  2 root root       29 Mar 24 22:05 var
# 可以看到上面几乎就像是一个小型的文件系统根目录，这样就能让 kernel 去挂载了

# 4. 再来看下，小型文件系统中，systemd 是使用哪一个 target 来执行开机呢？
[root@study initramfs]# ll usr/lib/systemd/system/default.target 
lrwxrwxrwx. 1 root root 13 Mar 24 22:05 usr/lib/systemd/system/default.target -> initrd.target

# 5. 最终，看看系统内默认的 initrd.target 相依的所有服务数据
[root@study initramfs]# systemctl list-dependencies initrd.target 
initrd.target
* |-dracut-cmdline.service
....
* |-basic.target
* | |-microcode.service
* | |-rhel-dmesg.service
* | |-selinux-policy-migrate-local-changes@targeted.service
* | |-paths.target
* | |-slices.target
* | | |--.slice
* | | `-system.slice
* | |-sockets.target
* | | |-avahi-daemon.socket
...
* | |-sysinit.target
* | | |-dev-hugepages.mount
...
* | | |-local-fs.target
* | | | |--.mount
* | | | |-boot.mount
* | | | |-home.mount
* | | | |-rhel-readonly.service
* | | | `-systemd-remount-fs.service
...
* | | `-swap.target
* | |   `-dev-mapper-centos\x2dswap.swap
* | `-timers.target
* |   |-systemd-tmpfiles-clean.timer
* |   `-unbound-anchor.timer
* |-initrd-fs.target
* `-initrd-root-fs.target

# 通过 systemd 的方式，一个一个的将所有的检查与服务价值系统中
```

通过上面解开 initramfs 的结果，其实它就是一个小型的根目录，而且也是通过 systemd 来进行管理，同时观察 default.target 的链接到了 initrd.target ，就是通过它来开机，而 initrd.target 也是需要读入一堆如 basic.target、sysinit.target 等硬件检测、核心功能启用的流程，然后让系统顺利运行。最终又卸载了 initramfs 的小型文件系统，实际挂载系统的根目录

同时可以看到 initramfs 里面很精简，仅是带入开机过程中会用到的核心模块。在 initramfs 里去找 modules 关键词，就可以发现主要的核心模块大概就是 SCSI、virtio、RAID 等与磁盘相关性较高的模块。现在由于大部分磁盘都使用 SATA ，并没有 IDE 的格式，没有 initramfs 的话，你的 Linux 几乎就不能顺利开机了，除非将 STAT 的模块直接编译到核心中去

在核心加载完成后，主机就开始正确运行了，接下来就要开始执行系统的第一个程序 systemd

## 第一个程序 systemd 及使用 defaul.target 进入开机程序分析

在核心加载完成、进行完硬件检测与驱动程序加载后，此时你的主机硬件已经准备就绪了（ready），此时核心会调用第一个程序 systemd。

systemd 最主要的功能就是准备软件执行的环境，包括系统的主机名、网络设置、语系处理、文件系统格式及其他服务的启动等。而所有的动作都活通过 systemd 的默认启动服务集合，也就是 `/etc/ststend/system/default.target` 来规划。

#### 常见的操作环境 target 与兼容于 runlevel 的等级

可以作为预设的操作环境（default.target）的主要项目有：multi-user.target 以及 graphical.target 这两个。还包括一些比较特殊的操作环境，包括在第 17 章中的 rescue.target、emergency.target.target、shutdown.target 等，还有本章讲到的 initramfs 中的 initrd.target 

以前 systemV 使用的是一个称为 runlevel（执行等级）的概念来启动系统的，systemd 为了兼容于旧的 systemd 操作行为，下列方式可以找到与之对应的关系

```bash
[root@study initramfs]# ll -d /usr/lib/systemd/system/runlevel*.target | cut -c 28-
Oct  4 18:22 /usr/lib/systemd/system/runlevel0.target -> poweroff.target
Oct  4 18:22 /usr/lib/systemd/system/runlevel1.target -> rescue.target
Oct  4 18:22 /usr/lib/systemd/system/runlevel2.target -> multi-user.target
Oct  4 18:22 /usr/lib/systemd/system/runlevel3.target -> multi-user.target
Oct  4 18:22 /usr/lib/systemd/system/runlevel4.target -> multi-user.target
Oct  4 18:22 /usr/lib/systemd/system/runlevel5.target -> graphical.target
Oct  4 18:22 /usr/lib/systemd/system/runlevel6.target -> reboot.target

```

### systemd 的处理流程

当我们取得了 `/etc/systemd/system/default.target` 这个默认的操作界面设置后，操作系统会链接到 `/usr/lib.systemd/system/` 目录下取得 multi-usr.target 或 graphical.target 中的一个，假设使用的是 graphical.target ，接下来，systemd 会找以下两个地方的配置

- `/etc/systemd/system/graphical.target.wants/`：使用者设置加载的 unit
- `/usr/lib/systemd/system/graphical.target.wants/`：系统默认加载的 unit

然后再由`/usr/lib/systemd/system/graphical.target` 配置文件内容发现如下资料

```bash
[root@study initramfs]# cat /usr/lib/systemd/system/graphical.target 
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Graphical Interface
Documentation=man:systemd.special(7)
Requires=multi-user.target				# 需要先运行该环境在运行自己
Wants=display-manager.service			# 运行完自己之后，还需要运行该服务
Conflicts=rescue.service rescue.target
After=multi-user.target rescue.service rescue.target display-manager.service
AllowIsolate=yes

```

那么通过同样的方式，找到 multi-user.target

```bash
[root@study initramfs]# cat /usr/lib/systemd/system/multi-user.target
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Multi-User System
Documentation=man:systemd.special(7)
Requires=basic.target				# 必须要先启动该环境
Conflicts=rescue.service rescue.target
After=basic.target rescue.service rescue.target
AllowIsolate=yes

# 看看系统默认要加载的 unit 有哪些
[root@study initramfs]# ls /usr/lib/systemd/system/multi-user.target.wants/
dbus.service  plymouth-quit-wait.service  systemd-ask-password-wall.path  systemd-update-utmp-runlevel.service
getty.target  plymouth-quit.service       systemd-logind.service          systemd-user-sessions.service

# 使用者自定义要加载的 unit 有哪些
[root@study initramfs]# ls /etc/systemd/system/multi-user.target.wants/    
ModemManager.service    avahi-daemon.service                   ksmtuned.service        rngd.service
NetworkManager.service  crond.service                          libstoragemgmt.service  rpcbind.service
abrt-ccpp.service       cups.path                              libvirtd.service        rsyslog.service
abrt-oops.service       cups.service                           mcelog.service          smartd.service
abrt-vmcore.service     firewalld.service                      mdmonitor.service       sshd.service
abrt-xorg.service       initial-setup-reconfiguration.service  nfs-client.target       sysstat.service
abrtd.service           irqbalance.service                     postfix.service         tuned.service
atd.service             kdump.service                          remote-fs.target        vdo.service
auditd.service          ksm.service                            rhel-configure.service  vmtoolsd.service

```

笔者在这里已经懵逼了，有点难了

通过以上分析知道：multi-user.target 要在 basic.target 运行完毕后才能够加载上述的许多 unit。然后再去 bashic.target 中找数据等，最终这些数据可以通过 `systemctl list-dependencies graphical.target` 指令列出来所有相关性的服务

这个就是 sytemd 调用所需要的服务流程

简约分析下 `systemctl list-dependencies graphical.target` 所输出的相依属性服务，基本上 CentOS 7.x 的 systemd 开机流程大约是这样：

1. `local-fs.target + swap.target`：主要在挂载本机 `/etc/fstab` 里所规范的文件系统与相关的内存交换空间
2. sysinit.target：主要在检测硬件、加载所需要的核心模块等
3. bashic.target：加载主要的外围用硬件驱动程序与防火墙相关服务
4. multi-user.target：下面的其他一般系统或网络服务的加载
5. 图形界面相关服务，如 gdm.service 等其他服务的加载

除了第一步是通过 `/etc/fastab` 来进行挂载的行为之外，其他的 target 做了什么呢？下面来简单说说

## systemd 执行 sysinit.target 初始化系统、bashic.target 准备系统

如果使用 `systemctl list-dependencies sysinit.target` 会看到很多相依的服务，想要知道这些服务是干什么的，需要一个一个区看脚本设置内容，基本上，可以将这些服务归类为几个大项：

- 特殊文件系统装置的挂载：包括 `dev-hugepages.mount dev-mqueue.mount` 等挂载服务，主要在挂载与巨量内存分页与消息队列的功能。挂载成功后，会在 `/dev` 下建立  `/dev/hugepages` 、`/dev.mqueue` 等目录
- 特殊文件系统的启用：包括磁盘阵列、网络驱动器（iscsi）、LVM 文件系、文件系统对照服务（multipath），等，也会在这里被检测到
- 开机过程的信息传递与动画执行：使用 plymouthd 服务搭配 plymouth 指令来传递动画与信息
- 日志文件的使用：systemd-journald 服务的启用
- 加载额外额核心模块：通过 `/etc/modules-load.d/*.conf` 文件的设置，让核心额外加载管理员所需要的核心模块
- 加载额外的核心参数设置：包括 `/etc/sysctl.conf` 以及 `/etc/sysctl.d/*.conf` 内部设置
- 启动系统的随机数生成器：随机数生成器可以帮助系统进行一些密码加密的功能
- 设置终端机（console）字形
- 启动动态设备管理器：udevd，用在动态对应实际设备存取与装置文件名对应的一个服务，相当重要

无论使用哪种操作环境来使用系统，该 sysinit.target 几乎都是必要的工作，从上面看，基本的核心功能、文件系统、文件系统设备的驱动等，都在此刻处理完成的

之后就是 basic.target 项目。该阶段主要启动的服务大概有：

- 加载 alsa 音效驱动程序
- 加载 firewalld 防火墙：CentOS 7.x 使用 firewalld 代替 iptables 的防火墙设置，不过底层还是私用的 iptables 架构
- 加载 CPU 的微指令功能
- 启动与设置 SELinux 的安全本文：如果 disable 的状态改成 enable，也是在该阶段处理
- 将目前的开机过程所产生的开机信息写到 `/var/log/dmesg` 中
- 由 `/etc/sysconfig/modules/*.modules` 以及 `/etc/rc.modules` 加载管理员指定的模块
- 加载 systemd 支持的 timer 功能

该阶段之后，系统已经开源顺利的运行，就差一堆需要的登录服务、网络服务、本机认证服务等 service 类别，下个阶段就进入到服务启动的阶段了

## systemd 启动 multi-user.target 下的服务

这些服务的启动大多是挂载 multi-user.target 操作环境下，可以到 `/etc/systemd/system/multi-user.target.wants/` 中看看默认要启动的服务。

一般来说服务的启动脚本设置都是放在如下的目录内：

- `/usr/lib/systemd/system`：系统默认的服务启动脚本设置
- `/etc/systemd/system`：管理员自己开发与设置的脚本设置

而用户针对主机的本地服务于服务器网络服务的各项 unit 若要 enable ，将他 放到 `/etc/systemd/system/multi-user.target.wants/` 目录下做个链接，就可以在开机的时候去启用它。

```bash
# 将 vsftpd.service 先 disable 再 enable 看看输出的信息
[root@study ~]# systemctl disable vsftpd.service
rm '/etc/systemd/system/multi-user.target.wants/vsftpd.service'
[root@study ~]# systemctl enable vsftpd.service
ln -s '/usr/lib/systemd/system/vsftpd.service' '/etc/systemd/system/multi-user.target.wants/vsftpd.service'
```

### 相容 systemV 的 rc-local.service

过去，要让系统开机后执行某些程序，可以将指令或脚本的绝对路径写入到 `/etc/rc.d/rc.local` 文件中

systemd 环境下，写一个 systemd 的启动脚本配置文件到 `/etc/systemd/system` 下，然后使用 systemctl enable 的方式来启动它

rc-local.service 服务就兼容了老的方式。该服务不需要启动，它会判断 `/etc/rc.d/rc.local` 是否具有可执行的权限来判断要不要启动这个服务。可以如下检查

```bash
# 1. 查看 rc.local 的权限，再检查 multi-user.target 有没有该服务
[root@study ~]# ll /etc/rc.d/rc.local 
-rw-r--r--. 1 root root 473 Aug  8  2019 /etc/rc.d/rc.local

[root@study ~]# systemctl status rc-local.service 
* rc-local.service - /etc/rc.d/rc.local Compatibility
   Loaded: loaded (/usr/lib/systemd/system/rc-local.service; static; vendor preset: disabled)
   Active: inactive (dead)

[root@study ~]# systemctl list-dependencies multi-user.target | grep rc-local

# 可以看到，有这个服务，但是 rc.local 没有可执行权限，因此该服务不会被执行

# 2. 加入可执行后，再看下 rc-local 是否可被启用 
[root@study ~]# chmod a+x /etc/rc.d/rc.local ;  ll /etc/rc.d/rc.local 
-rwxr-xr-x. 1 root root 473 Aug  8  2019 /etc/rc.d/rc.local
[root@study ~]# systemctl list-dependencies multi-user.target | grep rc-local
* |-rc-local.service

# 可以看到，该服务确实被记录到启动的环境下了
```

### 提供 tty 界面与登录的服务

在 multi-user.target 下有个 getty.target 的操作界面项目。能不能提供适当的登录服务也是该 target 下的内容，包括 systemd-logind.service、systemd-usr-sessions.service 等服务

这里可能会出现一个现象，在启动系统时，看到屏幕出现 tty1 可以登录，但是当输入正确的用户名和密码却无法登录，等待十几秒才可以，这是因为以上服务同时启动的，所以有可能 tty 先启动好，logind 还未启动好造成的

## systemd 启动 graphical.target 下的服务

如果 default.target 是 multi-user.target 的话，这个步骤就不会执行。

systemd 开始加载用户管理服务于图形界面管理员（window display manager，DM），启动图形界面让用户可以以图形界面登录系统，可以查看有哪些服务

```bash
[root@study ~]# systemctl list-dependencies graphical.target 
graphical.target
* |-accounts-daemon.service
* |-gdm.service
* |-initial-setup-reconfiguration.service
* |-network.service
* |-rtkit-daemon.service
* |-systemd-readahead-collect.service
* |-systemd-readahead-replay.service
* |-systemd-update-utmp-runlevel.service
* |-udisks2.service
* `-multi-user.target
*   |-abrt-ccpp.service
....
```

也有很多服务，其中 gdm.service 去查看他的内容，会发现执行的是 `/usr/sbin/gdm` 这个是让用户可以利用图形界面登录最重要的服务，未来再来详细讲解 gdm

## 开机过程会用到的主要配置文件

systemd 有自己的配置文件处理方式，不过为了兼容 systemV，还有部分服务脚本设置会读取 `/etc/sysconfig/` 下的环境配置文件。下面来看看几个比较重要的配置文件

### 关于模块 `/etc/modprobe.d/*.conf 与 /etc/modules-load.d/*.conf`

在 sysinit.target 系统初始化中谈到加载用户自定义模块的地方，有两个地方可以处理模块加载的问题：

-  `/etc/modules-load.d/*.conf`：单纯要核心加载模块的位置
- `/etc/modprobe.d/*.conf`：可以加上模块参数的位置

Systemd 基本上帮我们开机会用到的驱动程序全部加载了，一般不需要更改这部分，如果有特殊需求要处理的话，就需要再这里进行了。

举例：在第 17 章中谈到 vsftpd 服务，端口号粳稻到 555 上去了，我们可能需要修改防火墙设置，其中一个针对 FTP 很重要的防火墙模块为 nf_conntrack_ftp ，因此，可以将这个模块写入到系统开机流程中。例如

```bash
[root@study ~]# vim /etc/modules-load.d/mrcode.conf
nf_conntrack_ftp

```

一个模块（驱动程序）写一行，上述的模块基本上是针对默认 FTP 端口的，即 21 ，如果需要调整到port 555 ，需要额外带参数，模块外加参数的设置方式需要写到另外一个地方

```bash
[root@study ~]# vim /etc/modprobe.d/mrcode.conf
options nf_conntrack_ftp ports=555
[root@study ~]# lsmod | grep nf_conntrack_ftp
# 因为还没有加载该模块，所以没有任何信息

# 重启模块服务后，就发现被加载了
[root@study ~]# systemctl restart systemd-modules-load.service  
[root@study ~]# lsmod | grep nf_conntrack_ftp
nf_conntrack_ftp       18478  0 
nf_conntrack          139224  8 nf_nat,nf_nat_ipv4,nf_nat_ipv6,xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_ftp,nf_conntrack_ipv4,nf_conntrack_ipv6

```

通过如上方式，可以在开机时将你需要的驱动程序或则是调整这些模块的外加参数

###`/etc/sysconfig/*`

下面讲解几个比较常见且重要的环境配置文件

- authconfig

  主要规范使用者的身份认证机制，包括是否使用本机的 `/etc/passwd`、`/etc/shadow` 等，以及 `/etc/shadow` 密码记录使用何种加密算法，还有是否使用外部密码服务器提供的账户验证（NIS、LDAP）等。系统默认使用 SHA512 加密算法，并且不使用外部的身份验证机制；

  另外不建议手动修改该文件，应该使用 `authconfig-tui` 来修改

- cpupower

  如果有启动 cpupower.service 服务时，就会读取该文件。主要是 Linux 核心如何操作 CPU 的原则。一般来说，启动 cpupower.service 后，系统会让 CPU 以最大效能的方式来运行，否则预设就是用多少算多少的模式来处理

- firewalld、iptables-config、ebtables-config

  与防火墙服务的启动外带参数有关

- network-scripts

	至于 network-scripts 文件，则主要用来设置网卡

  
## 核心与核心模块

整个开机流程讲完，在整个开机过程中，是否能够成功的驱动我们主机的硬件设备，是核心的工作，而核心一般都是压缩文件，因此需要先解压后才能加载主存储器中

目前的核心都是具有可读取模块化驱动程序的功能，即模块化（modules），该模块可能由硬件开发厂商提供，也有可能核心本来就支持，较新的硬件，通常都需要硬件开发商提供驱动程序的模块

核心与核心模块位置：

- 核心：`/boot/vmlinuz` 或 `/boot/vminuz-version`
- 核心解压缩需 RAM disk：`/boot/initramfs(/boot/initramfs-version)`
- 核心模块：`/lib/modules/version/kernel` 或 `/lib/modules/$(uname-r)`/kernel
- 核心原始码：`/usr/src/linux` 或 `/usr/src/kernels/` (默认不安装，安装才会有)

如果该核心被顺利加载到系统中了，那么就会有如下信息记录下来

- 核心版本：`/proc/version`
- 系统核心功能：`/proc/sys/kernel`

问题来了：如果有个新的硬件，我的操作系统不支持怎么办？

- 重新编译核心，并加入最新的硬件驱动程序原始码
- 将该硬件的驱动程序编译成为模块，在开机时加载该模块

关于怎么编译可以参考后续的第 21 章。

## 核心模块与相依性

基本上核心模块在 `/lib/modules/$(uname -r)/kernel` 中，主要分成几个目录

```bash
arch：与硬件平台有关项目，例如 CPU 的等级等
crypto：核心所支持的加密技术，例如 md5 或则是 des 等
drivers：一些硬件的驱动程序，例如显卡、网卡、PCI 相关硬件
fs：核心所支持的 filesystems，例如 vfat、reiserfs、nfs 等
lib：一些函数库
net：与网络有关的各项协议数据，还有防火墙模块（net、ipv4、netfilter） 等
sound：与音效有关
```

有一个文件记录了核心支持的模块的各项相依性：`/lib/modules/$(uname -r)/modules.dep`, 可以使用 depmod 指令来管理

```bash
depmod [-Ane]

选项与参数：
	-A：不加任何参数时，depmod 会主动分析目前核心的模块，并且重新写入该文件中。若加入 -A 参数时，则会去搜索比 modules.dep 内还要新的模块，如果找到新模块，才会更新
	-n：不写入 modules.dep ,而是将结果输出到屏幕上
	-e：显示出目前已加载的不可执行的模块名称
```

```bash
# 范例：若我做好一个网卡驱动程序，文件名为 a.ko  ，如何更新核心想依性？
cp a.ko /lib/modules/$(uname -r)/kernel/drivers/net
depmod
```

核心模块扩展名一定是 `.ko` 结尾，当使用 depmod 后，该程序会在 ` /lib/modules/$(uname -r)/kernel/` 目录内，根据相关目录的定义将全部的模块拿来分析，最终才会将分析的结果写入 modules.dep 文件中

该文件很重要，会影响到本章后续会介绍的 modprobe 指令的应用

## 核心模块的观察

可以通过  lsmod 知道目前核心加载了多少模块

```bash
[root@study ~]# lsmod 
# 模块名									大小		模块是否被其他模块所使用
Module                  Size  Used by
xt_CHECKSUM            12549  1 
ipt_MASQUERADE         12678  3 
nf_nat_masquerade_ipv4    13430  1 ipt_MASQUERADE
tun                    32026  1 
bridge                151336  0 
stp                    12976  1 bridge
llc                    14552  2 stp,bridge
...
drm										 311588 4 qx1,ttm,drm_kms_helper

```

模块是有相依性的，比如上面 nf_nat_masquerade_ipv4 先加载，ipt_MASQUERADE 模块才能够进一步加载到系统中，这两者是有相依性的

想要了解某个块，可以使用 modinfo

```bash
modinfo [-adln] [module_name|filename]
选项与参数：
	-a：仅列出作者名称
	-d：仅列出该 modules 的说明（description）
	-l：仅列出授权 license
	-n：仅列出该模块的详细路径
```

```bash
# 范例：列出 drm 模块的相关信息
[root@study ~]# modinfo drm
# 该模块的来源
filename:       /lib/modules/3.10.0-1062.el7.x86_64/kernel/drivers/gpu/drm/drm.ko.xz
license:        GPL and additional rights
# 该模块的简介
description:    DRM shared core routines
author:         Gareth Hughes, Leif Delgass, José Fonseca, Jon Smirl
license:        GPL and additional rights
description:    DRM bridge infrastructure
author:         Ajay Kumar <ajaykumar.rs@samsung.com>
retpoline:      Y
rhelversion:    7.7
srcversion:     0B7C5A6948CEE2DF7C405B0
depends:        drm_panel_orientation_quirks
...
sig_hashalgo:   sha256
parm:           edid_firmware:Do not probe monitor, use specified EDID blob from built-in data or /lib/firmware instead.  (string)
parm:           vblankoffdelay:Delay until vblank irq auto-disable [msecs] (0: never disable, <0: disable immediately) (int)
parm:           timestamp_precision_usec:Max. error on timestamps [usecs] (int)
parm:           edid_fixup:Minimum number of valid EDID header bytes (0-8, default 6) (int)
parm:           debug:Enable debug output, where each bit enables a debug category.

```

该指令处理可以查询在核心内的模块，还可以检查某个模块文件。

## 核心模块的加载与移除

如想手动加载模块？有很多方法，这里推荐最简单的方式，就是使用 modprobe 指令来加载模块，因为它会主动搜索 modules.dep 的内容，先克服了模块的相依性后，才决定需要加载的模块有哪些

而 insmod 则完全由使用者加载一个完整文件名的模块，并不会主动分析模块的相依性

```bash
insmod [/full/path/module_name] [parameters]
```

```bash
# 范例 1：尝试载入 cifs.ko 文件系统模块
[root@study ~]# insmod /lib/modules/$(uname -r)/kernel/fs/fat/fat.ko.xz
[root@study ~]# lsmod | grep fat
fat                    65950  0 

```

like就被加载了，但是需要完整的路径

```bash
rmmod [-fw] module_name

-f：强制移除该模块，无论是否正在使用
```

```bash
# 范例 1：将刚刚加载的模块移除
[root@study ~]# rmmod fat
[root@study ~]# lsmod | grep fat
# 就被移除掉了

# 范例 2：加载 vfat 这个文件系统模块
[root@study ~]# insmod /lib/modules/$(uname -r)/kernel/fs/fat/vfat.ko.xz
insmod: ERROR: could not insert module /lib/modules/3.10.0-1062.el7.x86_64/kernel/fs/fat/vfat.ko.xz: Unknown symbol in module
# 无法加载
```

上面就由于有模块相依性，无法直接被加载，就可以使用 modprobe 来处理

```bash
modprobe [-cfr] module_name

选项与参数：
	-c：列出目前系统所有的模块（更详细的代号对应表）
	-f：强制加载该模块
	-r：类似 rmmod
```

```bash
# 范例 1： 加载 vfat 模块
[root@study ~]# modprobe vfat
[root@study ~]# lsmod | grep vfat
vfat                   17461  0 
fat                    65950  1 vfat

# 可以看到，自己就帮我们解决了模块的相依性问题，而且只需要知道模块名
```

## 核心模块的额外参数设置：`/etc/modprobe.d/*.conf`

如果有某些特殊的需求导致你必须要让核心模块加上某些参数时，这个时候可以回到上一章的最后一小节 **开机过程会用到的主要配置文件** 中去了解，重点就是要自己建议 `.conf` 的文件，通过 options 来带入核心模块参数

## Boot Loader：Grub2

前面知识点来看，boot loader 是载入核心的重要工具，来讲下 Linux 中最流行的 grub2 这个 boot loader

## boot loader 的两个 stage

曾经讲到，在 BIOS 读完信息后，接下来会到第一个开机设备的 MBR 去读取 boot loader 。该 boot loader 可以具有选单功能、字节加载核心文件以及控制权移交功能等，系统必须要有 loader 才能够加载该操作系统的核心。

但是 MBR 是整个硬盘的第一个 sector 内的一个区块，整个大小才 446 bytes 。即使 GPT 也没有很大的扇区来存储 loader 数据，那么功能强悍的 loader 是怎么放进去的？

为了解决这个问题，Linux 将 boot loader 的程序代码执行与设置值加载分成两个阶段（stage）执行

- Stage 1：执行 boot loader 主程序

  第一阶段执行 boot loader 的主程序，该主程序必须被安装在开机区，即 MBR 或则是 boot sector，但是因为 MBR 是在太小了，所以通常仅安装 boot loader 的最小主程序，并没有安装 loader 的相关配置文件

- Stage 2：主程序加载配置文件

  第二阶段通过 boot loader 加载所有配置文件与相关的环境参数文件，包括文件系统定义与主要配置文件 grub.cfg，一般来说，配置文件都在 /boot 下

与 grub2 相关的都放在 `/boot/grub2`

```bash
[root@study ~]# ls -l /boot/grub2
total 32
-rw-r--r--. 1 root root   84 Oct  4 18:31 device.map			# grub2 的设备对于文件
drwxr-xr-x. 2 root root   25 Oct  4 18:31 fonts						# 开机过程中的画面会使用到的字体数据
-rw-r--r--. 1 root root 4309 Oct  4 18:32 grub.cfg				# grub2 的主配置文件，非常重要
-rw-r--r--. 1 root root 1024 Oct  4 18:32 grubenv					# 一些环境区块的符号
drwxr-xr-x. 2 root root 8192 Oct  4 18:31 i386-pc					# 针对一般 x86 PC 所需要的 grub2 的相关模块
drwxr-xr-x. 2 root root 4096 Oct  4 18:31 locale					# 语系相关数据


[root@study ~]# ls -l /boot/grub2/i386-pc/
acpi.mod				# 电源管理有关的模块
ata.mod					# 磁盘有关的模块
chain.mod·			# 进行 loader 控制全移交的相关模块
command.lst 		# 一些指令相关性的列表
efiemu32.o			# 与 uefi BIOS 先关的模块
efiemu64.o
efiemu.mod
ext2.mod				# EXT w文件系统家族相关模块
fat.mod					# FAT 文件系统模块
gcry_sha256.mod	# 常见的加密模块
iso9660.mod			# 光盘文件系统模块
lvm.mod 				# LVM 文件系统模块
mdraid09.mod		# 软件磁盘阵列模块
minix.mod				# MINIX 相关文件系统模块
msdospart.mod		# 一般 MBR 分区表
part_gpt.mod    # GPT 分区表
part_msdos.mod	# MBR 分区表
scsi.mod				# SCSI 相关模块
usb_keyboard.mod	# usb 模相关模块
usb.mod
vga.mod					# VGA 显卡相关模块
xfs.mod					# XFS 文件系统模块
。。。。 等等很多模块


```

`/boot/grub2` 目录下最重要的是 grub2.cfg 配置文件，以及各种文件系统的定义。所以 loader 读取了这种文件系统定义数据后，就能够认识文件系统并读取在该文件系统内的核心文件了

从上面的文件来看， grub2 认识的文件系统与磁盘分区格式真的非常多，正因为如此，grub2 才会取代 Lio/grub 这个老婆的 boot loader

## grub2 的配置文件 `/boot/grub2/grub.cfg` 初探

Grub2 的有点挺多，包括：

- 认识与支持较多的文件系统，并且可以使用 grub2 的主程序直接在文件系统中搜索核心文件

- 开机时，可以自行编辑与修改改机设置项目，类似 bash 的指令模式

- 可以动态搜索配置文件，而不需要再修改配置文件后重新安装 grub2。

  即修改完配置文件后，下次开机就生效了

上面三个优点，也是 Stage 1、Stage 2 分别安装在 MBR（主程序）与文件系统中（配置文件与定义文件）的原因

### 磁盘与分区槽在 grub2 中的代号

安装在 MBR 的 grub2 的主程序，中重要任务之一是从磁盘中加载核心文件，让核心能顺利驱动整个系统的硬件

grub2 对硬盘的代号设置与传统的 LInux 磁盘代号完全不同，如下所示

```bash
(hd0,1)				# 一般的默认语法，由 grub2 自动判断分区格式
(hd0,msdos1)	# 此磁盘的分区为传统的 MBR 模式
(hd0,gpt1)		# 此磁盘的分区为 GPT 模式
```

从上面看，与 `/dev/sda1` 不相关，只要注意下面几个知识点：

- 硬盘代号以小括号 `()` 包起来
- 硬盘以 hd 表示，后面会接一组数字
- 以搜索顺序作为硬盘的编号（这个很重要）
- 第一个搜索到的硬盘为 0，一次类推
- 每块磁盘的第一个 partition 代号为 1，依序类推

如行 `(hd0,1)` 表示第一块硬盘，第一个分区槽；始终记得，硬盘号最小为 0，分区槽最小为 1

所以整个硬盘代号为：

| 硬盘搜索顺序   | grub2 的代号                       |
| -------------- | ---------------------------------- |
| 第一块磁盘 MBR | (hd0)、(hd0,msdos1)(hd0,msdos2)... |
| 第二块 GPT     | (hd1)、(hd1,gpt1)...               |
| 第三块         | (hd2)、(hd2,1)...                  |

例题：你的系统有一块 SATA 硬盘，请说明该硬盘的第一个逻辑分区槽在 Linux 与 grub2 中的文件名与代号

答：STAT 磁盘，使用逻辑分区槽，因此是 `/dev/sda5` （1-4 保留给 primary 与 extended 使用）。在 grub2 中则是，由于只有一块磁盘，那么 `(hd0,msdos5)`，简易写法 `(hd0,5)`

### `/boot/grub2/grub.cfg` 配置文件（重点了解，不要随意修改）！

```bash
[root@study ~]# vim /boot/grub2/grub.cfg 
# 开始是 00_header 这个脚本执行的结果展示，主要与基础设置与关机有关
### BEGIN /etc/grub.d/00_header ###
set pager=1

if [ -s $prefix/grubenv ]; then
  load_env
fi
...
if [ x$feature_timeout_style = xy ] ; then
  set timeout_style=menu
  set timeout=5			# 菜单显示时间
# Fallback normal timeout code in case the timeout_style feature is
# unavailable.
else
  set timeout=5
fi
### END /etc/grub.d/00_header ###
...

# 开始执行 10_linux ，主要针对实际的 Linux 核心文件的开机环境
# menuentry：表示选单内容，这里有两个，也就是说开机的时候，出现两个选单
### BEGIN /etc/grub.d/10_linux ###
menuentry 'CentOS Linux (3.10.0-1062.el7.x86_64) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-3.10.0-1062.el7.x86_64-advanced-7b220a88-4e13-4869-9aa9-87031303f3e1' {
        load_video
        set gfxpayload=keep
        insmod gzio
        insmod part_gpt
        insmod xfs
        set root='hd0,gpt2'		
        if [ x$feature_platform_search_hint = xy ]; then
          search --no-floppy --fs-uuid --set=root --hint-bios=hd1,gpt2 --hint-efi=hd1,gpt2 --hint-baremetal=ahci1,gpt2 --hint='hd0,gpt2'  13d0663f-4cbd-412d-aa9f-975eb18da590
        else
          search --no-floppy --fs-uuid --set=root 13d0663f-4cbd-412d-aa9f-975eb18da590
        fi
        linux16 /vmlinuz-3.10.0-1062.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet LANG=zh_CN.UTF-8
        initrd16 /initramfs-3.10.0-1062.el7.x86_64.img
}
menuentry 'CentOS Linux (0-rescue-f228ab37c368416c84c6b27971ba45a9) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-0-rescue-f228ab37c368416c84c6b27971ba45a9-advanced-7b220a88-4e13-4869-9aa9-87031303f3e1' {
        load_video
        insmod gzio
        insmod part_gpt
        insmod xfs
        set root='hd0,gpt2'
        if [ x$feature_platform_search_hint = xy ]; then
          search --no-floppy --fs-uuid --set=root --hint-bios=hd1,gpt2 --hint-efi=hd1,gpt2 --hint-baremetal=ahci1,gpt2 --hint='hd0,gpt2'  13d0663f-4cbd-412d-aa9f-975eb18da590
        else
          search --no-floppy --fs-uuid --set=root 13d0663f-4cbd-412d-aa9f-975eb18da590
        fi
        linux16 /vmlinuz-0-rescue-f228ab37c368416c84c6b27971ba45a9 root=/dev/mapper/centos-root ro crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet
        initrd16 /initramfs-0-rescue-f228ab37c368416c84c6b27971ba45a9.img
}

### END /etc/grub.d/10_linux ###

### BEGIN /etc/grub.d/20_linux_xen ###
### END /etc/grub.d/20_linux_xen ###

### BEGIN /etc/grub.d/20_ppc_terminfo ###
### END /etc/grub.d/20_ppc_terminfo ###

### BEGIN /etc/grub.d/30_os-prober ###
### END /etc/grub.d/30_os-prober ###

### BEGIN /etc/grub.d/40_custom ###

```

基本上，grub2 不希望你自己修改 grub.cfg 这个配置文件，取代他们的是修改几个特定的配置文件，由  grub2-mkconfig 指令来产生新的 grub.cfg 文件，这里需要了解下 grub2.cfg 的大致内容

- ` set root='hd0,gpt2'`

  root  指定 grub2 的配置文件所在的设备。测试机来说，当初安装的时候分区出 `/` 与 `/boot` 两个设备，而 grub2 是在 `/boot/grup2` 位置，该位置的磁盘文件名为 `/dev/sda2` 因此就是 `(hd0,2)`，又因为是 gpt 分区，所以是 `(hd0,gpt2)`

- `linux16 /vmlinuz-3.10.0-1062.el7.x86_64 root=/dev/mapper/centos-root `

  Linux 核心文件以及核心执行时下达的参数。我们的核心文件应该是 `/boot/vmlinuz-xx`，这里怎么会在根目录呢？这与上面的 root 有关：

  - 如果没有 /boot 分区，仅有 / 分区：所以文件名是：

    `/boot/vmlinuz-xxx  ---> (/)/boot/vmlinuz-xxx --> (hd0,msdos1)/boot/vmlinuz-xx`

  - 如果 /boot 是独立分区，则·

    `/boot/vmlinuz-xxx --> (/boot)/boot/vmlinuz-xx --> (hd0,msdos1)/vmlinuz-xxx`

  因此 linux16 后面接的文件名与上面的 root 搭配在一起，才是完整的绝对路径，至于文件名后面的 root=/dev/xx，中的 root 指 linux 文件系统中根目录是在哪个涉笔上的意思

- `initrd16/initramfs-3.10..`

  就是 initramfs 所在的文件名，与 linux16 哪个 vmlinuz-xxx 相同，也需要搭配 root，才是正确的位置

## grub2 的配置文件维护 `/etc/default/grub 与 /etc/grub.d`

### `/etc/default/grub` 主要配置文件

```bash
[root@study ~]# cat /etc/default/grub 
GRUB_TIMEOUT=5								# 指定预设倒数读秒数，也就是只给出 n 秒让你操作
GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"
GRUB_DEFAULT=saved						# 指定默认由哪一个选单来开机
GRUB_DISABLE_SUBMENU=true			# 是否隐藏次选单，通常是隐藏起来的
GRUB_TERMINAL_OUTPUT="console"	# 数据输出的终端机格式，默认是通过文字终端机
# 在 menuentry 括号内的 linux16 项目后续的核心参数
GRUB_CMDLINE_LINUX="crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet"
GRUB_DISABLE_RECOVERY="true"		# 取消救援选单的制作

```

下面讲解几个重要的设置（详情通过 info grub 6.1 章节阅读）

- 倒数时间参数：GRUB_TIMEOUT

  不想等待操作则输入 0，如果一定要求手动选择，则输入 -1，输入大于 0 秒的数值，则表示等待操作时间

- 是否隐藏选单：GRUB_TIMEOUT_STYLE

  可设置的值有：

  - menu：显示选单（默认）
  - countdown：不显示选单，但是还显示读秒
  - hidden ：不显示选单，且不显示读秒

  等

- 信息输出终端机模式：GRUB_TERMINAL_OUTPUT

  ​	输出的画面应该使用哪一个终端机来显示

  - console
  - serial
  - gfxterm
  - vag_text

  等

- 默认开机选单：GRUB_DEFAULT

  默认使用哪一个选单（menuentry）来作为开机项目。能使用的设置值为

  - saved
  - 数值
  - title
  - ID

  等，假设你有三个 menuentry

  ```bash
  menuentry  '1st linux system' --id 1lst-linux-system {...}
  menuentry  '2nd linux system' --id 2nd-linux-system {...}
  menuentry  '3rd linux system' --id 3rd-linux-system {...}
  
  几个常见的设置如下含义：
  # 表示使用第 2 个 menuentry 开机，数值编号以 0 开始
  GRUB_DEFAULT=1
  
  # 表示使用第 3 个
  GRUB_DEFAULT=3rd linux system
  
  # 表示使用 grub2-set-default 来设置哪一个 menuentry。通常预设为 0
  GRUB_DEFAULT=saved
  ```

- 核心的外加参数功能：GRUB_CMDLINE_LINUX

  可以在核心启动时加入额外的参数，在这里加入。比如，除了预设的核心参数外，还需要让你的磁盘读写机制为 deadline 时，可以这样处理

  ```bash
  GRUB_CMDLINE_LINUX="... crashkernel=atuo rhgb quiet elevator=deadline"
  ```



这个主要环节配置文件配置完成后，必须使用 grub2-mkconfig 来重建 grub.cfg 才可以。因为主配置文件是 grub.cfg，我们是通过许多脚本来协助完成 grub.cfg 的自动建立。另外，额外自己设置的项目，写入 `/etc/default/grub` 文件内

下面进行联系

问题：达成以下要求

1. 开机选单等待 40 秒
2. 预设使用第一个选单开机
3. 选单请显示出来，不要隐藏
4. 核心外带参数 `elevator=deadline` 

直接编辑主要环节配置文件后，再以 grub2-mkconfg 来重建 grub.cfg

```bash
# 1. 编辑主要环节配置文件
[root@study ~]# cat /etc/default/grub 
GRUB_TIMEOUT=40
GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"
GRUB_DEFAULT=0
GRUB_DISABLE_SUBMENU=true
GRUB_TERMINAL_STYLE=menu
GRUB_TERMINAL_OUTPUT="console"
GRUB_CMDLINE_LINUX="crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet elevator=deadline"
GRUB_DISABLE_RECOVERY="true"


# 2. 重建 grub.cfg
[root@study default]# grub2-mkconfig -o /boot/grub2/grub.cfg
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-3.10.0-1062.el7.x86_64
Found initrd image: /boot/initramfs-3.10.0-1062.el7.x86_64.img
Found linux image: /boot/vmlinuz-0-rescue-f228ab37c368416c84c6b27971ba45a9
Found initrd image: /boot/initramfs-0-rescue-f228ab37c368416c84c6b27971ba45a9.img
done


# 3. 检查是否生效
[root@study default]# grep timeout /boot/grub2/grub.cfg 
if [ x$feature_timeout_style = xy ] ; then
  set timeout_style=menu
  set timeout=40

# from /etc/grub.d and settings from /etc/default/grub
   set default="${next_entry}"
   set default="0"
   
[root@study default]# grep linux16 /boot/grub2/grub.cfg 
        linux16 /vmlinuz-3.10.0-1062.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet elevator=deadline 
        linux16 /vmlinuz-0-rescue-f228ab37c368416c84c6b27971ba45a9 root=/dev/mapper/centos-root ro crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet elevator=deadline 
```

通过以上测试，可以知道给我们一个配置文件，然后通过指令去刷新主配置文件，这能降低我们手动操作主配置文件的难度

### 选单建立的脚本 `/etc/grub.d/*`

执行 `grub2-mkconfig -o /boot/grub2/grub.cfg` 后，显示信息去抓取了 linux 核心等信息，这是因为 grub2-mkconfig 去分析 `/etc/grub.d/*` 中的文件，然后执行该文件来建立 grub.cfg 文件。该目录下一般或存储以下文件

- `00_header:`

  主要在建立初始的显示项目，包括需要加载的模块分析、屏幕终端机的格式、倒数描述、选单是否需要隐藏等，大部分在 `/etc/default/grub` 里所设置的变量，大概都会在该脚本中被利用来写入 grub.cfg 中

- `10_linux`

  根据分析 `/boot` 下的文件，尝试找到正确的 Linux 核心与读取该核心需要的文件系统模块与参数等信息，都在该脚本运行后找到并设置到 grub.cfg 中。

  因为该脚本会将所有在 `/boot` 下的每一个核心文件都对应到一个选单上，因此核心文件数量越多，你的开机选单项目就越多

  如果不需要旧的核心出现在选单上，可以通过移除旧核心来处理

- `30_os-prober`

  默认会到系统上找其他的 partition 里面可能含有的操作系统，然后将该操作系统做成选单来处理。

  如果不想要让其他操作系统被检测到并制作开机选单，可以在 `/etc/default/grub` 中加上 `GRUB_DISABLE_OS_PROBER=true` 来取消该文件的运行

- `40_custom`

  如果还有其他自定义加上的选单项目，或则其他需求，可以在这里进行补充

  

一般来说，我们会修改 40_custom 文件。现在我们知道 menuentry 是一个选单，它的功能有如下：

- 直接指定核心开机

  基本上如果是 Linux 的核心要直接被用来开机，直接通过 grub2-mkconfg 去抓取 `10_linux` 脚本来制作即可，但是如果你有额外比较特别的参数需要进行，可以这样做

  1. 先到 grub.cfg 取得你要制作的核心选单项目，让后将它复制到 40_custom 中
  2. 再到 40_custom 中根据你的需求修改即可

  问题：如果你想要使用第一个原有的 menuentry 取出来后，增加一个选单，该选单可以强制 systemd 使用 graphical.target 来启动 linux 系统，让选单一定可以使用图形界面而不用理会 default.target 的连结。如何做？

  ```bash
  在核心外带参数中，有个选项 systemd.unit=???，可以做到。因此先到 grub.cfg 中，复制一个 menuentry
  [root@study default]# vim /etc/grub.d/40_custom
  #在这里修改我们的选单名称
  menuentry 'My graphical CentOS' --class centos --class gnu-linux --class gnu --class os --unrestricted --id 'mygraphical' {   # 这里再设置一个 --id
          load_video
          set gfxpayload=keep
          insmod gzio
          insmod part_gpt
          insmod xfs
          set root='hd0,gpt2'
          if [ x$feature_platform_search_hint = xy ]; then
            search --no-floppy --fs-uuid --set=root --hint-bios=hd0,gpt2 --hint-efi=hd0,gpt2 --hint-baremetal=ahci0,gpt2  13d0663f-4cbd-412d-aa9f-975eb18da590
          else
            search --no-floppy --fs-uuid --set=root 13d0663f-4cbd-412d-aa9f-975eb18da590
          fi
          linux16 /vmlinuz-3.10.0-1062.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet elevator=deadline systemd.unit=graphical.target  # 这里再增加 systemd.unit=graphical.target 配置
          initrd16 /initramfs-3.10.0-1062.el7.x86_64.img
  }
  
  # 然后重建下
  [root@study default]# grep linux16 /boot/grub2/grub.cfg 
  # 下次重新开机的时候就会出现该选单给你选择了
  ```

  ### 通过 chainloader 的方式移交 loader 控制权

  chain loader ：开机管理程序的连结，仅是在将控制权交给下一个 boot loader。所以 grub2 并不需要认识与找出 kernel 的文件，只是将 boot 的控制权交给下一个 boot sector 或 MBR 内的 boot loader 而已，所以通常它也不需要去检查下一个 boot loader 的文件系统

  一般来说，chain loader 的设置值要两个就够了：

  1. 预计要前往的 boot sector 所在的分区槽代号
  2. 设置 chainloader 在那个分区槽的 boot sector （第一个扇区）上

  假设 windows 分区槽在 `/dev/sda1` ,但是我只有一块硬盘，那么要 grub 将控制权交给 windows loader 需要这样做

  ```bash
  menuentry "Windows" {
  	insmod chain		# 加载 chainloader 的模块
  	insmod ntfs			# 建议加入 windows 所在的文件系统模块较好
  	set root=(hd0,1)	# 是在哪一个分区槽？
  	chainloader +1 		# 去 boot sector 将 loader 软件读取出来的意思
  }
  # 通过以上配置，就可以让 grub2 叫出控制权了
  ```

  问题：假设你的测试系统上使用 MBR 分区槽，并且出现如下数据

  ```bash
  [root@study ~]# fdisk -l /dev/sda 
  Device Boot         Start           End    	Blocks  		Id    System
  /dev/sda1 					   2048         6143     44444			83		Linux
  /dev/sda2 *					   6144      2103295     999999			7		  HPFS/NTFS/exFAT
  /dev/sda3 					2103296     65026047     222222			84		Linux
  
  # 其中 /dev/sda2 是 windows 7 操作系统，现在需要增加两个开机选项
  # 1. 获取 windows7 的开机选单
  # 2. 回到 MBR 的预设环境
  
  
  win7 在 /dev/sda2，因此是 hd0,msdos2，而 MBR 则是 hd0 即可，因此设置如下
  
  vim /etc/grub.d/40_custom
  menuentry 'Go to Windows 7' --id 'win7'  {
  	insmod chain		
  	insmod ntfs			
  	set root=(hd0,2)	
  	chainloader +1 		
  }
  
  menuentry 'go to MBR' --id 'mbr' {
  	insmod chain			
  	set root=(hd0)
  	chainloader +1
  }
  
  # 如果每次都想要 windows 变成默认的开机选项，
  # 那么在 /etc/default/grub 中设置 GRUB_DEFAULT=win7
  # 再使用 grub2-mkconfig 即可，通过 --id 来处理，不需要去计算  menuentry 的顺序
  ```

## initramfs 的重要性与监理新 initramfs 文件

  在前面提到过 initramfs，它的目的是在于提供开机过程中所需要的最重要核心模块，让系统开机过程可以顺利完成。

  一般来说，需要 initramfs 的时刻有：

  - 根目录所在磁盘为 STAT、USB 或 SCSI 等连接接口
  - 根目录所在文件系统为 LVM、RAID 等特殊格式
  - 根目录所在文件系统为非传统 LInux 认识的文件系统时
  - 其他必须要在核心加载时提供的模块

  一般来说，各 distribution 提供的核心都会附上 initramfs 文件，但是如果你有特殊需要想重新制作 initramfs 文件的话，可以使用 `dracut\mkinitrd ` 来处理

  在 CentOS 7 下应该使用 dracut，这里也主要介绍它

  ```bash
  dracut [-fv] [--add-drivers 列表] initramfs 文件名 核心版本
  
  选项与参数：
  
  	-f：强迫编译出 initramfs，如果 initramfs 文件已经存在，则覆盖旧文件
  	-v：显示 dracut 的运行过程
  	--add-drivers 列表：在原本的默认核心模块中，增加某些你想要的模块，模块维护核心所在目录 `/lib/modules/$(uname -r)/kernel/*`
  	initramfs 文件名：你需要的文件名，开头最好以 initramfs，后面接版本与功能
  	核心版本：默认是目前运行中的核心版本，也可以手动输入其他不同版本
  	
  	dracut 还有很多功能。例如下面的几个参数：
  	--modules：将 dracut 所提供的开机锁需模块（核心模块）加载，可用模块在 /usr/lib/dracut/modules.d/ 目录
  	--gzip|--bzip2|--xz：尝试使用哪一种压缩方式来进行 initramfs 压缩，默认使用 gzip
  	--filesystem：加入某些额外的文件系支持 
  	
  # 范例 1：以 dracut 的默认功能建立一个 initramfs 虚拟盘文件
  [root@study ~]# dracut -v initramfs-test.img $(uname -r)
  Executing: /sbin/dracut -v initramfs-test.img 3.10.0-1062.el7.x86_64
  dracut module 'busybox' will not be installed, because command 'busybox' could not be found!
  ...
  dracut module 'cifs' will not be installed, because command 'mount.cifs' could not be found!
  *** Including module: bash ***
  *** Including module: nss-softokn ***
  *** Including module: i18n ***
  *** Including module: network ***
  *** Including module: ifcfg ***
  *** Including module: drm ***
  *** Including module: plymouth ***
  *** Including module: dm ***
  Skipping udev rule: 64-device-mapper.rules
  ....
  
  # 范例 2：额外加入 e100e 网卡驱动与 ext4/nfs 文件系统在新的 initramfs 内
  [root@study ~]# dracut -v --add-drivers "e10001" --filesystems "ext4 nfs" initramfs-new.img $(uname -r)
  [root@study ~]# lsinitrd initramfs-new.img | grep -E '(e1000|ext4|nfs)'
  Arguments: -v --add-drivers 'e10001' --filesystems 'ext4 nfs'
  nfs
  -rw-r--r--   1 root     root           15 Mar 29 21:52 etc/modprobe.d/nfs.conf
  ...
  
  ```

  建立完成之后，同时核心也处理完成后，就可以使用 grub2 来建立选单了。下面继续

## 测试与安装 grub2

如果你的 Linux 主机本来就使用 grub2 作为 loader 的话，就不需要重新安装了，如果并非使用 grub2，那么需要安装

首先：必须使用 grub-install 将一些必要的文件复制到 /boot/grub2 中，应该这样做

```bash
grub2-install [-boot-directory=DIR] INSTALL_DEVIVCE

--boot-directory=DIR：DIR 是实际的目录，使用 grub2-install 默认会将 grub2 所有的文件都复制到 `/boot/grub2/*` ，如果想复制到其他目录与设备，需要使用该参数
INSTALL_DEVIVCE：安装设置代号
```

```bash
# 范例 1： 将 grub2 安装在目录系统的 MBR 下，我的系统为 /dev/sda
[root@study ~]# grub2-install /dev/sda
# 如果原来就是 grub2，所以可能不会有什么特别的信息
# 但是去查看相关文件更新日期会发现被更新过了，因为是重装
# 但是我们并没有配置文件，需要自己创建
```

基本上，grub2-install 大概仅安装 grub2 主程序与相关软件到 `/boot/grub2` 目录，如果后面的设备是整个系统 (/dev/sda、/dev/vds ...)，那 loader 的程序才会写入到 MBR 中去。

如果 XFS 文件系统的 /dev/sda2 设备（个别 partition），那么 grub2-install 就会告诉你，该文件系统并不支持 grub2 的安装。

下面强迫写入试试

```bash
# 尝试看看你的系统中是否有 xfs 文件系统，且为传统的 parition 类型
[root@study ~]# df -T | grep -i xfs
/dev/mapper/centos-root xfs       10475520 5475932   4999588  53% /
/dev/sda2               xfs        1038336  184348    853988  18% /boot
/dev/mapper/centos-home xfs        5232640  949064   4283576  19% /home
# 笔者这里没有其他的分区。直接把书上的分区列出来
/dev/vda4							  xfs        5232640  949064   4283576  19% /srv/myproject

# 那么下面使用 /dev/vda4 来安装
[root@study ~]# grub2-install /dev/vda4
grub2-install: error: hostdisk/dev/vda appears to con...... (--skip-fs-probe ....)
# 报错了，恐怕不支持你的 boot sector ，这应该是误判，使用强制安装

[root@study ~]# grub2-install --skip-fs-probe /dev/vda4
Installing for i386-pc platform.
grub2-install:warning: FIle system 'xfs' doesn‘t support embedding
....
grub2-install:error: will not proceed with blocklists

# 还是失败，因为还是担心 xfs 被搞死，使用如下参数再测一次
[root@study ~]# grub2-install --force --recheck --skip-fs-probe /dev/vda4
Installing for i386-pc platform.
grub2-install:warning: FIle system 'xfs' doesn‘t support embedding
....
Installation finished.NO error reporled
# 安装好了，只出现了警告信息，但是错误没有了
```

上面这样将 grub2 的主程序安装到 /dev/vda4 以及重新安装到 MBR 里面去了。

思考下：grub2 主程序会找 grub.cfg 文件，大多是在 /boot/grub2/grub.cfg 里。那么我们的 MBR 与 /dev/vda4 都是到 /boot/grub2/grub.cfg 去抓设置吗？如果是多重操作系统怎么办？

```bash
# 问：假设你的测试系统上使用 MBR 分区槽，并且出现如下数据
[root@study ~]# fdisk -l /dev/sda 
Device Boot         Start           End    	Blocks  		Id    System
/dev/sda1 					   2048         6143     44444			83		Linux
/dev/sda2 *					   6144      2103295     999999			7		  HPFS/NTFS/exFAT
/dev/sda3 					2103296     65026047     222222			84		Linux

sda1 与 sda3 是两个 CentOS 7 系统。
sda2 是一个 windows7 系统
安装流程是 sda1、sda2、sda3 ，因此安装好而且重启后，系统其实是默认进入 sda3 这个 CentOS 7 系统的。此时 MBR 会去读取的配置文件在 (/dev/sda3)/boot/grub2/grub.cfg

因为 sda1 应该是用来管理开机选单的，而 sda2 以及 sda3 在规划中就是用来让学生操作的，因此默认情况下  sda1 内的 CentOS 系统应该只会在开机的使用用到，或则是出问题时才会用到。
而 sd2 与 sd3 则可能因为学生无用，因此未来可能会升级或删除或重装等，
那如何让系统永远都是使用 /dev/sda1 开机？

答：因为 MBR 的 boot loader 应该去 (/dev/sda1)/boot/grub2/grub.cfg 读取相关设置才是正常的，所以可以使用集中基本的方式来处理：

1. 因为 CentOS 7 会主动找其他操作系统，因此可以在 sda3 的开机选单中找到 sda1 的开机选项，使用该选项进入系统，就可以进入 sda1 了
2. 假设没能抓到 sda1，那可以在 sda3 下使用 chroot 来进入 sda1
3、 使用救援光盘去抓到正确的 sda1.然后去的 sda1 的系统

等进入到系统之后，修改 /etc/default/grub 以及 /etc/grub.d/40_custom 后，使用 grub2-mkconfig -o / boot/grb2/grub.cfg. 然后重新  grub2-install/dev/sda 就能够让你的 MBR 去获取 /dev/sda1 内的配置文件了
```

```bash
# 问：前面的练习，测试机目前为 40 秒倒数，且有一个强制进入图形界面 My graphical CentOS 7 的选单
# 现在需要多加两个选单，一个是回到 MBR 的 chainloader 
# 一个使用 sda4 的 chainloadder 该如何处理？

vim /etc/grub.d/40_custom
vim /etc/grub.d/40_custom
menuentry 'Goto MBR'{
	insmod chain		
	insmod part_gpt			
	set root=(hd0)	
	chainloader +1 		
}

menuentry 'Goto /dev/sda4'{
	insmod chain			
	insmod part_gpt			
	set root=(hd0.gpt4)
	chainloader +1
}

grub2-mkconfig -o /boot/grub2/grub.cfg
```

最后总结：

1. 如何是从其他 boot loader 转成 grub2 时，需要先使用 grub2-install 安装 grub2 配置文件

   如果安装到 partition 时，可能需要加上额外的许多参数才能够顺利安装

2. 开始编辑 `/etc/default/grub 以及 /etc/grub.d/*` 重要的配置文件

3. 使用 `grub2-mkconfig -o /boot/grub2/grub.cfg` 来建立开机的配置文件

## 开机前的额外功能修改

前面部分由于没有额外的分区，没有跟着做，导致这里无法显示没有做的那一部分选单，该章节直接使用书上的截图

![image-20200331214428334](http://p6ui.toweydoc.tech:20080/images/stydocs/image-20200331214428334.png)

上面的 ‘e’ ，表示按 e 键可以进入编辑模式，直接对该选项进行编辑

![image-20200331214650243](http://p6ui.toweydoc.tech:20080/images/stydocs/image-20200331214650243.png)

上面就是我们在 grub.cfg 里的配置的内容，这里可以直接修改。下半部分则是一些说明，可以使用 ctrl + x 重启，ctrl + c 或 esc 可返回上个画面

问题：在线编辑，让系统进入救援模式 （rescue），而不像要进入系统后使用 systemctl rescue 时，怎么做？

答：可使用在线编辑模式，找到下图的 linux16 的项，然后添加服务参数

![image-20200331215159375](http://p6ui.toweydoc.tech:20080/images/stydocs/image-20200331215159375.png)

修改之后，再重启就可以直接进入救援模式了

![image-20200331215301052](http://p6ui.toweydoc.tech:20080/images/stydocs/image-20200331215301052.png)

进入 runlevel 需要输入密码？后续会讲解如何处理（不输入密码）

## 关于开机画面与终端机画面的图形显示方式

如果想用开机画面使用图形显示方式，如使用中文来显示开机画面。我们预设的 locale 的语系是 `zh_CN.UTF-8`，所以理论上会显示中文才对，可以修改 grub.cfg 来达成

```bash
[root@study ~]# vim /etc/default/grub
.....
GRUB_TERMINAL=gfxterm					# 设置主要的终端机显示为图形界面
GRUB_GFXMODE=1024x768x24			# 图形界面的 x、y、彩度信息
GRUB_GFPAYLOAD_LINUX=keep			# 保留图形界面，不要使用 text

# 重新建立配置文件
[root@study ~]# grub2-mkconfig -o /boot/grub2/grub.cfg 
```

重启时，就能看到如下的画面了

![image-20200331220333935](http://p6ui.toweydoc.tech:20080/images/stydocs/image-20200331220333935.png)

后面这个开机选单中的中文是修改 menuentry 出来的，不是自动出来的哈

## 为个别选单加上密码

前面在讲解可以在开机时进入 grub2 的指令画面进入修改选单参数等，如果是在公共教室情况下，想要加密某个选单还是有必要的

grub2 的控制有：

1. grub2 的选单指令列修改

2. 进入选择的选单开机流程

要使用密码的话，就涉及到 grub2 的账户机制了

### grub2 的账户、密码与选单设置

在 grub2 的选单管理中，针对两种身份进行密码设置：

- superusers：

  设置系统管理员与相关参数还有密码等，使用这个密码的用户，将可再 grub2 内具有所有修改的权限。但一旦设置了这个参数，则所有的指令修改将会受到限制

- users

  设置一般账户的相关参数与密码，可以设置多个账户，使用该密码的用户可以选择要进入某些选单项目。不过，选单项目也需要搭配相对应的账户才可以

  一般来说，使用这种密码的账户并不能修改选单的内容，仅能选择进入选单去开机

下面的例子，不能用在测试机上面，笔者也直接抄下来了

假设系统有三个操作系统，分别安装在 `(hd0,1)、(hd0,2)、(hd0,3)`

- `(hd0,1)`：所有人都可以进入
- `(hd0,2)`：只有系统管理员可进入的系统
- `(hd0,3)`：另一个一般用户与管理员可以进入的系统

系统管理员账户密码设置为 `mrcode/123456`，一般账户为 `mrcode2/456789`

如上的需求，没有用到 Linux 的 linux16 与 initrd16 的项目，只需要 chainloader 的项目，因此，整个 grub.cfg 类似如下内容

```bash
# 1. 先设置好管理员与一般账户的名称与密码
set superusers='mrcode'		# 管理员账户名
password mrcode 123456		# 设置账户名和密码
password mrcode2 456789		# 一般账户名密码

menuentry "大家都可以选择开机" --unrestricted{
	set root(hd0,1)
	chainloader +1
}

menuentry "只有管理员的密码才有办法使用" --users ""{
	set root(hd0,1)
	chainloader +1
}

# 可以看到这里使用 --users 声明了 mrcode2 账户
menuentry "只有管理员与  mrcode2 才可以使用" --users mrcode2 {
	set root(hd0,3)
	chainloader +1
}
```

如上所示：使用 superusers 声明管理员账户，使用 password 来设置账户密码，密码有以下两种

- password_pbkdf2 账户 「使用 grub2-mkpasswd-pbkdf2 所产生的密码」
- password 账号「 没有加密的明文密码」

上面的内容不要手动去修改 grub.cfg 文件，而是放到相关环境配置文件下，下面开始讲解

### grub2 密码设置的文件位置与加密密码

前几小节讲到主要的环境设置在 `/etc/grub.d/*` 里面有一个 `00_header` 文件，但是不建议修改它，所以可以自己建立一个 `01_user` 的文件，要注意是两个数字开头的前缀才可以，表示优先级被读取的顺序

```bash
# 1. 先获取两个账户的加密密码
[root@study ~]# grub2-mkpasswd-pbkdf2 
Enter password: 
Reenter password: 
PBKDF2 hash of your password is grub.pbkdf2.sha512.10000.DB145873C4E3C7ACD4A549416F8F15751EBC79D6C91F78356239AB277D0A0D89790F7CF98EA8C435ACD51C019D36AF945FCE41228AD8B0C43055ADCE4A61D7E4.37ABF2CA07512796ED302DF38C9C0CC7E407B16E5B656E49770F89E65CC590EC2F30E9160237FEE6F520D1EBACA97A7160D576B33F58AFEFE50857A849DFA8E6
# 这个加密密码可真长

# 2. 将密码与账户写入到 01_users 文件内
[root@study ~]# vim /etc/grub.d/01_users
cat << eof
set superusers='mrcode'		
password_pbkdf2 mrcode grub.pbkdf2.sha512.10000.DB145873C4E3C7ACD4A5...
password_pbkdf2 mrcode2 grub.pbkdf2.sha512.10000.DB145873C4E3C7ACD4A5x...		
eof

# 特别注意，因为 /etc/grub.d/ 下的文件应该是执行文件
# 所以不能直接写账户密码，而是通过 cat 或 echo 等指令方式将密码数据显示出来

# 3. 因为是执行文件，给执行权限
[root@study ~]# chmod a+x  /etc/grub.d/01_users
```

### 为个别的选单设置账户密码的使用模式

回写之前的设置，目前测试机器的 Linux 系统选单应该有 5 个：

- 来自 `/etc/grub.d/10_linux`  文件主动检测到的两个 menuentry
- 来自 `/etc/grub.d/40_custom` 文件我们自己主动设置的三个 menuentry

由于上述在 `/etc/grub.d/01_users` 设置了管理员，那么只有知道管理员密码的情况下，才可以修改每个选单内的参数等信息了

设置 10_linux 制作出来的 menuentry 的选单，正常开机，所以不要使用密码，设置如下

```bash
[root@study ~]# vim /etc/grub.d/10_linux 
CLASS="--class gnu-linux --class gnu --class os --unrestricted"
# 上述配置是该文件默认就有的配置
# --unrestricted 不受限制，如果要受限制可将 --unrestricted 修改为 --users "账户名称"
# 默认选单的我们建议不修改
```

现在假设需要在 `40_custom` 里，添加一个可以进入救援模式 rescue 的环境，并且放到最后一个选单中，同时只有知道 mrcode2 的密码才可以使用，应该这样做

```bash
[root@study ~]# vim /etc/grub.d/40_custom
....
menuentry 'Rescue CentOS7,with Linux 3.xx' --users mrcode2 {
        load_video
        set gfxpayload=keep
        insmod gzio
        insmod part_gpt
        insmod xfs
        set root='hd0,gpt2'
        if [ x$feature_platform_search_hint = xy ]; then
          search --no-floppy --fs-uuid --set=root --hint-bios=hd0,gpt2 --hint-efi=hd0,gpt2 --hint-baremetal=ahci0,gpt2  13d0663f-4cbd-412d-aa9f-975eb18da590
        else
          search --no-floppy --fs-uuid --set=root 13d0663f-4cbd-412d-aa9f-975eb18da590
        fi
        linux16 /vmlinuz-3.10.0-1062.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet elevator=deadline systemd.unit=rescue.target  # 这里配置救援环境
        initrd16 /initramfs-3.10.0-1062.el7.x86_64.img
}

[root@study ~]# grub2-mkconfig -o /boot/grub2/grub.cfg
```

上面由于太多笔者没有跟着敲，导致这里设置开机选单也有不生效，感觉这一章是全军覆没了

### 设置fallback模式

GRUB支持一种备用机制，如果默认的启动项失败，它可以引导一个或多个其他项。如果需要的话，您可以指定多个备用项。

假设您有三个系统，A'、B'和C'。A'是您默认希望引导的系统。B'是一个备份系统，应该可以安全引导。C'是另一个备份系统，在`B'无法正常引导时使用。

那么您可能希望GRUB引导A'、B'和`C'中可引导的第一个系统。可以按以下方式编写配置文件：

```
     default saved        # This is important!!!
     timeout 10
     fallback 1 2         # This is important!!!
     
     title A
     root (hd0,0)
     kernel /kernel
     savedefault fallback # This is important!!!
     
     title B
     root (hd1,0)
     kernel /kernel
     savedefault fallback # This is important!!!
     
     title C
     root (hd2,0)
     kernel /kernel
     savedefault
```

请注意，配置文件中使用了default saved',fallback 1 2'和`savedefault fallback'。在这个配置中，GRUB默认引导一个已保存的项，并将一个备用项保存为下一个引导项。

当GRUB尝试引导A'时，GRUB将1'保存为下一个引导项，因为fallback命令指定1'是第一个备用项。而1'对应的是B'，所以GRUB将在下一次引导时尝试引导B'。

同样地，当GRUB尝试引导B'时，GRUB将2'保存为下一个引导项，因为fallback指定2'作为下一个备用项。这确保在引导B'后，GRUB将引导`C'。

值得注意的是，无论是在GRUB本身引导项失败还是在A'或B'启动您的系统失败时，GRUB都会使用备用项。因此，这个解决方案确保即使GRUB找不到您的内核或内核发生崩溃，您的系统也能够启动。

然而，当A'正确启动或您修复A'后，您需要运行grub-set-default，因为GRUB始终将下一个引导项设置为备用项。您可以在启动脚本（如rc.local）中运行这个命令来将`A'设置为默认引导项：

```
     # grub-set-default 0
```

这里的0'是系统A'的引导项号码。

如果您想查看当前的默认引导项，可以查看文件/boot/grub/default（或某些系统中的/grub/default）。由于该文件是纯文本文件，您可以直接使用cat命令查看。但强烈建议不要直接修改该文件，因为如果您以意外的方式更改该文件，GRUB可能无法保存默认引导项在该文件中。因此，当您需要更改默认引导项时，请使用grub-set-default命令。


## 开机过程的问题解决

很多时候，可能要我做了某些设置，或不正常关机，而导致系统的 filesystem 错乱，因此 Linux 可能无法顺利开机，可以先尝试进入 rescue 模式去处理，下面讲解几个常见的问题

## 忘记 root 密码

原理是：只要能挂载到原来的根目录，就可以重新设置下 root 密码

在新版的 systemd 的管理机制中，默认的 rescue 模式无法直接取得 root 权限，还是需要使用 root 密码才能进入 rescure 环境，可以通过 `rd.break` 的核心参数来处理

`rd.break` 是在 Ram Disk 里的操作系统状态，因此不能直接取得原本的 Linux 系统操作环境，所以还是需要 chroot 的支持，至于 SELinux 的问题，可能还要加上某些特殊的流程才能顺利的搞定 root 密码的救援

开机进入选单编辑模式，如下图

![image-20200401114254117](http://p6ui.toweydoc.tech:20080/images/stydocs/image-20200401114254117.png)

按 ctrl + x 重启后，开机画面会出现如下类似的画面，这应该是在 RAM Disk 的环境，并不是原本的环境，因此根目录下的数据与你原本的系统无关，而且你的系统应该会被挂载到 `/sysroot` 目录下，需要这样操作

```bash
Generating "/run/initramfs/rdsosreport.txt"

Enter emergency mode. Exit the shell to continue.
Type "journalctl" to view system logs.
You might want to save "/run/initramfs/rdsosreport.txt" to a USB stick or /boot
after mounting them and attach it to a bug report.

# 无需输入密码就取得了 root 权限
switch_root:/# 
# 检查挂载点
switch_root:/# mount
...
/dev/mapper/centos-root on /sysroot type xfs (ro,relatime,attr,inode64,noquo
# 这里的权限是 ro? 不能写入，只可以读，重新挂载成可读写的
switch_root:/# mount -o remount,rw /sysroot
# 切回原本的系统环境
switch_root:/# chroot /sysroot

sh-4.2# echo "你的新密码" | passwd --stdin root
sh-4.2# touch /.autorelabel		# 很重要，变回 SELinux 的安全本文
sh-4.2# exit

switch_root:/# reboot

```

下面进行疑问解释：

- `chroot 目录`：

  表示将你的根目录「暂时」切换到 指定的目录。上面的 `sysroot` 目录我们知道是原本的系统根目录，所以就可以处理了

- 为何需要 `.autorelabel`

  在 `rd.break` 的 RAM Disk 环境下，系统是没有 SELinux 的，而刚刚更改了 `/etc/shadow` （更改密码导致），所以这个文件的 SELinux 安全本文的特性将会被取消，如果没有让系统再开机时自动恢复 SELinux 的安全本文，将产生无法登陆的问题（在SELinux 为 Enforcing 的模式下）。使用 `/.autorelabel`  表示让系统再开机时自动使用预设的 SELinux type 重新写入 SELinux 安全本文到每个文件上去

由于 `/.autorelabel` 开机恢复需要不少时间，还可以使用如下方式

- 在 rd.break 模式下，修改完 root 密码后， 将 `/etc/selinux/config`  内的 SELinux 类型改为 permissive
- 重新启动后，使用 root 身份下达 `restorecon -Rv /etc` 仅修改 /etc 下的文件
- 重新修改 `/etc/selinux/config` 内的 SELinux 类型为 enforcing，然后执行 `setenfore` 即可

## 开机直接以 root 执行 bash 的方法

还可以直接开机取得系统根目录后，让系统直接给我们一个 bash。

配置方法同样是在 linux 哪一行添加参数，不用  rd.break，而是使用 `init=/bin/bash`，同样不需要 root 密码就可以获取到 root 权限

该 bash 无法完整的操作系统，这个原理是将 PID=1 的第一个程序改为了 bash，所以最多还是用在救援方面。同样需要 remount 根目录才可以

```bash
# 直接就在根目录，所以只需要改成写模式就可以了，后续流程和上面的一样
switch_root:/# mount -o remount,rw /
```

## 因文件系统错误而无法开机

如果因为设置错误导致无法开机时，就更简单了，通常设置错误导致无法开机的文件是 `/etc/fstab` 文件，修改完成后，又没有通过  `mount -a`  来测试就重启系统了，那么就无法开机成功了，这种情况的问题大多数为下图所示

![image-20200401131409238](http://p6ui.toweydoc.tech:20080/images/stydocs/image-20200401131409238.png)

提示输入 root 密码进入救援，之后重新挂载写模式 `mount -o remount,rw /`，就可以编辑错误的设置了

如果是因为不正常关机后，导致文件系统不一致（Inconsistend）的情况，也可能出现相同的问题，如果是扇区错乱的情况，请看上图第 2 行，fsck 告知是 `/dev/md0` 错误，此时你应该利用 fsck.ext3 去检测 `/dev/md0` 才是，等到系统发现错误，并且出现 `clear[Y/N]` 时，输入 Y 尝试恢复

如果是 XFS 文件系统的话，可能需要使用  xfs_repair 指令来处理，`fsck/xfs_repair` 的处理过程可能会很长，如果你的 partition 上的 filesystem 有过多的数据顺坏时即使 `fsck/xfs_repair` 完成后，可能因为损坏了系统槽，导致某些关键系统文件数据的损坏，那么依旧是无法进入 Linux 的。此时就只能将系统中重要的数据复制出来，然后重新安装，并且检验下是否是实体硬盘有损坏的现象


## 重点回顾

- Linux 不可随意关机，否则容易造成文件系统错乱或则其他无法开机的问题
- 开机流程主要是：BIOS、MBR、Loader、kernel+initramfs、systemd 等流程
- Loader 具有提供选单、加载核心文件、转交控制权给其他 loader 等功能
- boot loader 可以安装在 MBR 或则是每个分区槽的 boot sector 区域中
- initramfs 可以提供核心在开机过程中所需要的最重要的模块，通常与磁盘及文件系统有关的模块
- systemd 的配置文件主要来自  `/etc/systemd/system/default.target` 项目
- 额外的设备与模块对应，可写入 `/etc/modprobe.d/*.conf` 中
- 核心模块的管理可使用 lsmod、modinfo、rmmod、insmod、modprobe 等指令
- modprobe 主要参考 `/lib/modules/$(uanem -r)/modules.dep` 的设置来加载与卸载核心模块
- grub2 的配置文件与相关文件系统定义文件大多放再 `/boot/grub2` 目录中，配置文件名为 grub.cfg
- grub2 对磁盘的代号设置与 Linux 不同，主要通过检测的顺序来设置。如 `(hd0) (hd0,1)` 等
- grub.cfg 内每个选单与 menuentry 有关，而直接指定核心开机时，至少需要 linux16 以及 initrd16 等两个项目
- grub.cfg 内设置 loader 控制权移交时，最重要的为 `chainloader+1` 配置
- 若想要重建 initramfs，可使用 dracut 或 mkinitrd 指令
- 重新安装 grub2 到 MBR 或 boot sector 时，可以利用 grub2-install 来处理
- 想要进入救援模式，可在开机选单过程中，在 linux16 的项目后加入 `rd.break` 或 `init=/bin/bash` 等方式进入
- 可以对 grub2 的个别选单设置不同的密码

## 本章练习

## 通过光盘进入救援模式

利用光盘来处理系统的错误导致无法开机的问题：

- 目标：了解救援光盘的功能
- 前提：了解 grub 的原理，并且知道如何使用 chroot 功能

1. 利用光盘开机时，看到开机项目后，选择 `Troubleshooting  -> Rescur a CentOS system` 进入救援模式

2. 该光盘会找出目前你的主机里面与 CentOS 7.x 相关的操作系统，并将该操作系统汇总成一个 chroot 的环境等待你的处理，有 3 个模式可以选择：

   1. continue：继续成为可擦写挂载
   2. Read-Only：将检测到的操作系统变成只读挂载
   3. Skip：忽略当次救援动作

   这里我们需要选择 continue

3. 如果你安装了多个 CentOS 7.x 操作系统（多重操作系统），那就会出现选单让你选择想要处理的根目录是哪一个

4. 然后系统会将检测到的信息通知你，一般来说可能会再屏幕上显示类似 `chroot /mnt/sysimage` 的信息，此时按下确认键开始挂载

5. 确认之后，会给你一个 shell ，可以先用 df 看下挂载情况是否正确，若不正确，你可以自行手动挂载其他未被挂载的 partition。等一切搞定后，利用 `chroot /mnt/sysimage` 来转成你原本的操作系统环境。

救援模式环境就准备好了，处理完问题之后，就可以重新开机了

## 简答题部分

1. 忘记了 root 密码，使用 rd.break 的核心参数重新启动，并且修改完 root 密码，重新启动后可以顺利开机，但是使用所有的账户都无法登陆系统，是为什么？

   最有可能的原因是 `/.autorelabel` 没有建立，且 SELinux ENforcing 的模式的原因；这样的情况，就只能重新进入救援模式，增加该文件，让系统开机重新恢复默认的安全本文

2. 万一不幸，一些模块无法让 Linux 核心捕捉到，但是偏偏这个核心就能支持该模块，需要让该模块在开机时就被加载，如何做？

   应该写入 `/etc/modprobe.d/*.conf` 文件，他是模块加载相关的地方，还可以写入 `/etc/sysconfig/modules/*`

3. 如何在 grub2 开机过程中，指定已 multi-user.target 来开机

   在开机进入 boot loader 后，利用 grub shell 功能，即按 e 键进入编辑模式，找到 linux16 的后面增加  systemd.unit=multi-user.target 就能够进入纯文本模式了

4. 如果不小心先安装 Linux 再安装 Windows 导致 boot loader 无法找到 Linux 的开机选单，如何挽救？

   方法有很多，例如：

   - 借助第三方软件，安装类似 spfdisk 的软件在 MBR 里，因为它同时认识 Linux 与 windows，可以利用它来进入 Linux
   - 使用类似 KNOPPIX 的 Live CD 以光盘开机进入 LInux 之后，再以 chroot 软件切换到根目录，然后重新安装 grub 等 boot loader，同样也可以重新让两个操作系统存在

   总之，原理都是需要知道  MBR、Super block、boot loader 之间的相关性，才能知道怎么做