# Linux 基础教程

## 🚀概述

Linux是一个操作系统(OS)

20世纪80年代，由于Unix 版权的限制，荷兰阿姆斯特丹Vrije大学的Andrew S. Tanenbaum教授决定写一个系统，名为MINIX(即小型的UNIX)，并开放全部源代码给大学教学和研究工作。李纳斯·托瓦兹在赫尔辛基大学读书时也使用了Andrew教授的Minix系统，但他觉得实在太难用，于是也决定自己开发一个操作系统。

李纳斯·托瓦兹(Linus Torvalds)在1991年初，开始基于Minix(Unix变种)进行开发，同年九月，开发完成内核的0.01版本，命名为Linux。

1960年代末，肯·汤普逊和丹尼斯·里奇一起参与了一个项目，由贝尔实验室、麻省理工学院、以及通用电气公司联合开发了一套多使用者分时作业系统，名叫Multics(MULTiplexed Information and Computing System)，后来由于种种原因Multics计划失败。之后，他和丹尼斯·里奇花了一个月的时间用之前他们设计的B语言开发了一套全新的操作系统，并起名叫做 Unics(UNiplexed Information and Computing System)，后来，Unics慢慢就变成了Unix。

第一版的Unix是基于B语言来开发的。B语言在进行系统编程时不够强大。汤普逊和丹尼斯·里奇对其进行了改造，并于1971年发明了C语言。1973年他们用C语言对 Unix系统进行了重新编写。

## 📥安装与下载

详细下载安装教程：[点击跳转](https://blog.csdn.net/da_ge_de_nv_ren/article/details/128408962)

![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/10a899e0648f41e4a1a2cd091c4b503c.png)

## 🧾目录结构

Linux 的一切资源都挂载在 / 节点下。  
**/bin：** Binary的缩写。存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行。  
**/boot：** 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。  
**/dev：** Device的缩写。该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。  
**/etc：** Etcetera的缩写。这个目录用来存放所有的系统管理所需要的配置文件和子目录。  
**/home：** 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。  
**/lib：** Library的缩写。这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。  
**/lib64：** 64位相关的库会放在这。  
**/media：** linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。  
**/mnt：** 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。  
**/opt：** optional的缩写。这是给主机额外安装软件所摆放的目录。  
**/proc：** Processes的缩写。/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里  
**/root：** 该目录为系统管理员，也称作超级权限者的用户主目录。  
**/run：** 运行目录  
**/sbin：** s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。  
**/srv：** 该目录存放一些服务启动之后需要提取的数据。  
**/sys：** 虚拟文件系统。和 /proc/ 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息  
**/tmp：** temporary的缩写这个目录是用来存放一些临时文件的。  
**/usr：** unix system resources缩写。用于存储系统软件资源。  
**/var：** 用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等

## 🧾VI/VIM

VI是Unix操作系统和类Unix操作系统中最通用的文本编辑器。  
VIM编辑器是从VI发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM 与VI编辑器完全兼容。

![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/1e539d9cf1be42218a4b27a659908b54.png)  
基本上 vi/vim 共分为三种模式，分别是一般模式，编辑模式和命令模式。  
![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/e33ebfd4bbb445bd9b1c630cde96a543.png)

### 一般模式

刚刚启动 vi/vim，便进入了一般模式(默认模式)。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。在此模式可以复制黏贴，删除等操作。若想要编辑文本，进入一般模式，按下i，切换到编辑模式。

| 按键       | 说明                                               |
| ---------- | -------------------------------------------------- |
| x          | 向后删除一个字符，相当于 del                       |
| X          | 向前删除一个字符，相当于backspace                  |
| nx         | n 为数字，连续向后删除 n 个字符                    |
| dd         | 删除游标所在的那一整行(常用)                       |
| ndd        | n 为数字。删除光标所在的向下 n 行                  |
| d1G        | 删除光标所在到第一行的所有数据                     |
| dG         | 删除光标所在到最后一行的所有数据                   |
| d$         | 删除游标所在处，到该行的最后一个字符               |
| d0         | 删除游标所在处，到该行的最前面一个字符             |
| yy         | 复制游标所在的那一行(常用)                         |
| nyy        | n 为数字。复制光标所在的向下 n 行                  |
| y1G        | 复制游标所在行到第一行的所有数据                   |
| yG         | 复制游标所在行到最后一行的所有数据                 |
| y0         | 复制光标所在的那个字符到该行行首的所有数据         |
| y$         | 复制光标所在的那个字符到该行行尾的所有数据         |
| p          | 将已复制的数据在光标下一行贴上                     |
| P          | 将已复制的数据在光标上一行贴上                     |
| J          | 将光标所在行与下一行的数据结合成同一行             |
| c          | 重复删除多个数据，例：向下删除 10 行：10cj         |
| u          | 复原前一个动作                                     |
| Ctrl+r     | 重做上一个动作                                     |
| +          | 光标移动到非空格符的下一行                         |
| \-         | 光标移动到非空格符的上一行                         |
| n`<`space>  | n 表示数字，光标会向右移动这一行的 n 个字符        |
| 0 或Home   | 移动到这一行的最前面字符处                         |
| $ 或End    | 移动到这一行的最后面字符处                         |
| H          | 光标移动到这个屏幕的最上方那一行的第一个字符       |
| M          | 光标移动到这个屏幕的中央那一行的第一个字符         |
| L          | 光标移动到这个屏幕的最下方那一行的第一个字符       |
| G          | 移动到这个档案的最后一行                           |
| nG         | n 为数字。移动到这个档案的第 n 行                  |
| gg         | 移动到这个档案的第一行                             |
| n`<`Enter>  | n 为数字。光标向下移动 n 行                        |
| /n         | n为要搜索的内容。向光标之下寻找一个名称为n的字符串 |
| ?n         | 向光标之上寻找一个字符串名称为n的字符串            |
| n          | 重复前一个搜寻的动作                               |
| N          | 与 n 相反，反向进行前一个搜寻动作                  |
| h 或 ←     | 光标向左移动一个字符                               |
| j 或 ↓     | 光标向下移动一个字符                               |
| k 或 ↑     | 光标向上移动一个字符                               |
| l 或 →     | 光标向右移动一个字符                               |
| Ctrl+ f    | 屏幕向下移动一页，相当于Page Down按键              |
| Ctrl + b\] | 屏幕向上移动一页，相当于Page Up按键                |
| Ctrl+ d    | 屏幕向下移动半页                                   |
| Ctrl + u   | 屏幕向上移动半页                                   |

### 编辑模式

在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式。在编辑模式当中，左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮。

| 按键 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| i, I | i 为从目前光标所在处输入， I 在目前所在行的第一个非空格符处开始输入 |
| a, A | a 为从目前光标所在的下一个字符处开始输入， A 为从光标所在行的最后一个字符处开始输入 |
| o, O | o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行 |
| r, R | r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止 |

### 命令模式

在一般模式之中，只要按下 ：或 / 就可以进入命令模式。

| 按键                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| :w                    | 保存                                                         |
| :w!                   | 若文件属性为只读时，强制写入该档案。不过，能不能写入， 还跟你对该档案的档案权限有关 |
| :q                    | 退出                                                         |
| :q!                   | 强制退出                                                     |
| :wq                   | 保存并退出                                                   |
| ZZ                    | 效果等同于保存并退出                                         |
| ZQ                    | 效果等同于 :q!                                               |
| :w \[filename\]       | 将编辑的数据储存成另一个文件                                 |
| :r \[filename\]       | 在编辑的数据中，读入另一个文件的数据。将filename这个档案内容加到游标所在行后面 |
| :n1,n2 w \[filename\] | 将 n1 到 n2 的内容储存成 filename 这个档案                   |
| :! command            | 暂时离开 vi 到指令行模式下执行 command 的显示结果！例：:! ls /home 即可在 vi 当中察看 /home 底下以 ls 输出的档案信息 |
| :set nu               | 显示行号                                                     |
| :set nonu             | 取消行号                                                     |
| :noh                  | 取消高亮显示                                                 |
| : s/old/new           | 替换当前匹配到的第一个 old 为 new                            |
| : s/old/new/g         | 替换当前匹配到所有的 old 为 new                              |
| :%s/old/new           | 替换文档中每一行匹配到的第一个 old 为 new                    |
| :%s/old/new/g         | 替换文档中匹配到所有的 old 为 new                            |

## 🌐网络配置

VMware安装完成后会在宿主机上生成两块虚拟网卡，这两块网卡与虚拟机管理的两个虚拟交换机相连。  
![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/b0579cfde19d470781b509c494d02fea.png)  
VMware管理了3个特殊的虚拟交换机：VMnet0（用于桥接模式），VMnet8（用于NAT模式），VMnet1（用于仅主机模式）。  
![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/4cf85bd57b944b6f9478ecf8999cc3a8.png)  
VMware提供了3种网络工作模式：Bridged(桥接模式)，NAT（网络地址转换模式），Host-Only（仅主机模式)。

**🌐桥接模式：**

📎 虚拟机直接连接外部物理网络的模式，主机起到了网桥的作用。这种模式下，虚拟机可以直接访问外部网络，并且对外部网络是可见的。

👉将宿主机的网卡通过虚拟网桥与VMware管理的虚拟交换机VMnet0相连，所有网络连接设置为桥接模式的虚拟机都会连接到虚拟交换机VMnet0上。

👉这样所有的虚拟机与宿主机以及与宿主机在同一个局域网下的主机之间都是可以相互访问的。

👉在桥接模式下，虚拟机IP地址需要与宿主机在同一个网段，如果需要联网，则虚拟机的网关和DNS也需要与宿主机被桥接的网卡一致。  
![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/59868aa2fe134a97930c9fb9c061efa6.png)  
📍 虚拟网桥会转发宿主机网卡接收到的广播和组播信息，以及目标为虚拟交换机网段的单播。所以，与虚拟交换机机连接的虚拟网卡，如: eth0、ens33等能接收到路由器发出的DHCP信息及路由更新。

📍桥接模式是通过虚拟网桥将主机上的网卡与虚拟交换机VMnet0连接在一起，虚拟机上的虚拟网卡都连接在虚拟交换机VMnet0上，在桥接模式下，虚拟机IP必须与宿主机的IP在同一网段且子网掩码、网关与DNS也要与宿主机网卡的一致。

📍桥接模式的虚拟机会占用宿主机所在局域网内的IP地址资源。如果宿主机所在局域网中做了IP地址管理，比如IP地址需要公司网络部门审批通过后才能使用，那么虚拟机的IP地址也会受此管理规则的约束。

**🌐NAT模式：**

📎虚拟机和主机构建一个专用网络，并通过虚拟网络地址转换(NAT)设备对IP进行转换。虚拟机通过共享主机IP可以访问外部网络，但外部网络无法访问虚拟机。

👉如果你的网络ip资源紧缺，但又希望虚拟机能够联网，NAT模式是最好的选择。

👉NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网  
![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/ea02a23281b348199e1db08aa66f8e21.png)  
📍使用NAT模式，就是让虚拟机借助NAT（网络地址转换功能)，通过宿主机所在的网络来访问互联网。

📍在虚拟机连接Vmnet8虚拟交换机时，虚拟机会将虚拟NAT设备及虚拟DHCP服务器连接到Vmnet8虚拟交换机上。依靠虚拟的NAT设备及虚拟的DHCP设备，如果你的宿主机已经联网了，那么你的虚拟机也就可以联网。

📍同时宿主机上的虚拟网卡VMwareNetwork Adapter VMnet8也会连接到Vmnet8虚拟交换机上，用于宿主机和虚拟机的通信。如果禁用掉宿主机上的虚拟网卡VMwareNetwork Adapter VMnet8，虚拟机仍然是可以上网的，只是宿主无法再访问VMnet8网段下的虚拟机了，但是虚拟机仍然可以访问宿主机。

📍虚拟网卡VMwareNetwork Adapter VMnet8只是作为主机与虚拟机通信的接口，虚拟机并不是依靠虚拟网卡VMware Network Adapter VMnet8来联网的。

📍由于NAT服务协议对外部网络隐蔽内部网络，因此虚拟机可以通过NAT服务器访问宿主机所在局域网内的其他真实主机，但这些真实主机且不能反过来访问虚拟机。

**🌐仅主机模式**

📎虚拟机只与主机共享一个专用网络，与外部网络无法通信。

👉仅主机模式就是NAT模式去掉了虚拟NAT设备，使虚拟机无法与公网进行通信，而宿主机使用虚拟网卡VMware Network Adapter VMnet1连接VMnet1虚拟交换机来与虚拟机进行通信。

👉仅主机模式将虚拟机与公网隔开，使虚拟机成为一个独立的系统，只能与宿主机相互通讯。

![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/6d8985b634a34302803d65e8c957e0ed.png)  
📍仅主机模式通过宿主机的虚拟网卡VMwareNetwork Adapter VMnet1来连接虚拟交换机VMnet1，来达到宿主机与虚拟机通信的目的，但是虚拟机不能主动与宿主机通信，是单向连通的。

📍如果想要在仅主机模式下联网，可以将能联网的主机网卡共享给VMware Network Adapter VMnet1，这样就可以实现虚拟机联网。

### 常用命令

#### **📚 ifconfig**

📔 用于显示或设置网络设备。可设置网络设备的状态，或是显示目前的设置

📃启动关闭指定网卡

```shell
ifconfig eth0 down
ifconfig eth0 up
```

📃为网卡配置和删除IPv6地址

```shell
ifconfig eth0 add 33ffe:3240:800:1005::2/ 64 # 为网卡设置IPv6地址

ifconfig eth0 del 33ffe:3240:800:1005::2/ 64 # 为网卡删除IPv6地址
```

📃用ifconfig修改MAC地址

```shell
ifconfig eth0 down # 关闭网卡
ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE # 修改MAC地址
ifconfig eth0 up # 启动网卡
ifconfig eth1 hw ether 00:1D:1C:1D:1E # 关闭网卡并修改MAC地址 
ifconfig eth1 up # 启动网卡
```

📃配置IP地址

```shell
# 给eth0网卡配置IP地址
ifconfig eth0 192.168.1.56 

# 给eth0网卡配置IP地址,并加上子掩码
ifconfig eth0 192.168.1.56 netmask 255.255.255.0 

# 给eth0网卡配置IP地址,加上子掩码,加上个广播地址
ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255
```

📃启用和关闭ARP协议

```shell
ifconfig eth0 arp   # 开启
ifconfig eth0 -arp  # 关闭
```

📃设置最大传输单元

```shell
# 设置能通过的最大数据包大小为 1500 bytes
 ifconfig eth0 mtu 1500 
```

#### 📚ping

📔 命令用于检测主机。执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。

### 修改静态IP

```shell
//用Vim进入ifcfg- ens33配置文件，将动态改成静态
vim /etc/sysconfig/network-scripts/ifcfg- ens33
```

![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/c974d6617fe743b1ae6d9f4ab63a8212.png)

```shell
# 重启网路
service network restart
```

**❓可能会遇到的问题：**

❗ 物理机能ping通虚拟机，但是虚拟机ping不通物理机，一般都是因为物理机的防火墙问题,把防火墙关闭就行

❗虚拟机能Ping通物理机，但是虚拟机Ping不通外网，一般都是因为DNS的设置有问题

❗虚拟机Ping www.baidu.com显示域名未知等信息，一般查看GATEWAY和DNS设置是否正确

❗如果以上全部设置完还是不行，需要关闭NetworkManager服务

```shell
systemctl stop NetworkManager  # 关闭
systemctl disable NetworkManager # 禁用
```

❗如果检查发现 systemctl status network有问题需要检查ifcfg-ens33

### 修改主机名

```shell
hostname //查看主机名
```

```shell
vim /etc/hostname //进入配置文件修改主机名，修改完成后需要重启
```

```shell
hostname set-hostname 修改的主机名  // 更好的修改方式，不用重启
```

**在hosts文件中添加**

```shell
vim /etc/hosts //进入hosts配置文件，进行添加
```

![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/1529d21b3a1341ee90f283006a9c5776.png)  
找到电脑目录 C:\\Windows\\System32\\drivers\\etc下的hosts文件将192.168.111.100 hhh 添加进去

打开DOS窗口输入 `Ping hhh` 测试是否可以Ping通

### 远程登录

Dos窗口登录  
![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/5d1d43f781264227af27b117ff7d847b.png)  
通常在工作过程中，公司中使用的真实服务器或者是云服务器，都不允许除运维人员之外的员工直接接触，因此就需要通过远程登录的方式来操作。目前，比较主流的有Xshell, SSH Secure Shell, SecureCRT,FinalShell。

## 💻系统管理

计算机中，一个正在执行的程序或命令，被叫做“进程”，启动一次之后一直存在、常驻内存的进程，一般被称作“服务”。

### 常用命令

#### **📚 service命令** (CentOS6)

📔用来控制系统服务的实用工具，它以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。

🔦 查看服务的方法： `/etc/init.d/服务名`

📝 service 服务名 start | stop | restart | status

| 语法        | 说明             |
| ----------- | ---------------- |
| –status-all | 显示所服务的状态 |
| \-h         | 显示帮助信息     |

📃显示所有服务的状态：

```shell
service --status-all
```

#### 📚 systemctl命令

📔systemctl命令来自于英文词组”system control“的缩写，其功能是用于管理系统服务。从RHEL/CentOS7版本之后初始化进程服务init被替代成了systemd服务，systemd初始化进程服务的管理是通过systemctl命令完成的，从功能上涵盖了之前service、chkconfig、init、setup等多条命令的大部分功能。

🔦 查看服务的方法：`/usr/lib/systemd/system`

📝 service start | stop | restart | status 服务名

| 参数                       | 说明               |
| -------------------------- | ------------------ |
| start                      | 启动服务           |
| stop                       | 停止服务           |
| restart                    | 重启服务           |
| enable                     | 使某服务开机自启   |
| disable                    | 关闭某服务开机自启 |
| status                     | 查看服务状态       |
| list -units --type=service | 列举所有已启动服务 |

📃参考实例

```shell
# 启动指定的服务
systemctl start sshd
# 停止指定的服务
systemctl stop sshd
# 重启指定的服务
systemctl restart sshd
# 查看指定服务的运行状态
systemctl status sshd
# 将指定的服务加入到开机启动项中
systemctl enable sshd
# 将指定的服务从开机启动项中取消
systemctl disable sshd
# 显示系统中所有已启动的服务列表信息
systemctl list-units --type=service
```

#### 📚setup命令

📔setup命令是一个基于文本界面的系统管理工具，集成了用户认证管理、防火墙管理、网络管理和系统服务管理。

| setup面板                    | 说明                 |
| ---------------------------- | -------------------- |
| Authentication configuration | 用户管理认证         |
| Firewall configuration       | 防火墙管理           |
| Network configuration        | 网络管理             |
| System services              | 系统服务自动启动管理 |

📃进入setup管理界面

```shell
setup
```

#### 📚chkconfig命令

📔用于检查，设置系统的各种服务。这是Red Hat公司遵循GPL规则所开发的程序，它可查询操作系统在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。

📝 `chkconfig [--add][--del][--list][系统服务] 或 chkconfig [--level <等级代号>][系统服务][on/off/reset]`

| 参数             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| –add             | 增加所指定的系统服务，让 chkconfig 指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。 |
| –del             | 删除所指定的系统服务，不再由 chkconfig 指令管理，并同时在系统启动的叙述文件内删除相关数据。 |
| –level`<`等级代号> | 指定读系统服务要在哪一个执行等级中开启或关闭。               |

🔖chkconfig 没有参数运行时，显示用法。如果在服务名后面指定了on，off或者reset，那么chkconfig 会改变指定服务的启动信息。on和off分别指服务被启动和停止，reset指重置服务的启动信息，无论有问题的初始化脚本指定了什么。on和off开关，系统默认只对运行级2，3，4，5有效，但是reset可以对所有运行级有效。

🔖level选项可以指定要查看的运行级而不一定是当前运行级。对于每个运行级，只能有一个启动脚本或者停止脚本。当切换运行级时，init不会重新启动已经启动的服务，也不会再次去停止已经停止的服务。

📃参考实例

```shell
chkconfig --list  # 列出所有的系统服务

chkconfig --add httpd # 将httpd添加为受chkconfi管理的服务：

chkconfig --del httpd # 删除httpd服务

chkconfig --level 35 httpd on  # 在级别3和5上设定服务为“on”，开机自动启动也是配置这个

chkconfig --level 01246 httpd off  # 在其级别上设为off

# 为了确认你的配置被正确的修改了，我们可以列出服务运行级别，如下所示：
# chkconfig --list httpd
httpd   0:off   1:off    2:off    3:on    4:off    5:on    6:off
```

#### 📚firewall-cmd命令

📔用于防火墙策略管理，是firewalld服务的配置工具。使用firewall-cmd命令修改的防火墙策略会立即生效，但重启后失效，因此推荐要加上permanent参数。

| 参数                      | 说明                   |
| ------------------------- | ---------------------- |
| –state                    | 显示当前服务运行状态   |
| –zone=public --list-ports | 查看所有打开运行的端口 |
| –permanent                | 策略写入到永久生效表中 |
| –reload                   | 不重启立即加载         |
| –list-all-zones           | 查看区域信息情况       |
| –panic-on                 | 拒绝所有包             |
| –panic-off                | 取消拒绝状态           |
| –query-panic              | 查看是否拒绝           |

📃查看当前防火墙状态

```shell
firewall-cmd --state
```

📃查看防火墙当前放行端口号列表

```shell
firewall-cmd --zone=public --list-ports
```

📃重新加载防火墙策略，立即生效

```shell
firewall-cmd --reload
```

📃查看当前防火墙默认使用区域名称

```shell
firewall-cmd --get-default-zone 
```

📃参考实例

```shell
# 开放某个端口，如8080端口
firewall-cmd --zone=public --add-port=8080/tcp --permanent

# 重新加载配置
firewall-cmd --reload

# 查看防火墙锁开放的端口
firewall-cmd --zone=public --list-ports

# 查看某个端口的访问权限，如8080
firewall-cmd --zone=public --query-port=8080/tcp
# 关闭某个端口的防火墙，如8080端口
firewall-cmd --zone=public --remove-port=8080/tcp --permanent

# 放通某个端口段
firewall-cmd --permanent --zone=public --add-port=1000-2000/tcp

# 放通某个IP访问，默认允许
firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address=192.168.1.169 accept'

# 禁止某个IP访问
firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address=10.0.0.42 drop'

# 放通某个IP访问某个端口
firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address=192.168.1.169 port protocol=tcp port=6379 accept'

# 移除以上规则
firewall-cmd --permanent --remove-rich-rule='rule family=ipv4 source address=192.168.1.169 port protocol=tcp port=6379 accept'

# 放通某个IP段访问
firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address=10.0.0.0/24 accept'
```

### 运行级别

CentOS6

`开机`➡`BIOS` ➡`/boot` ➡ `init进程`➡`运行级别` ➡ `运行级别对应的服务`

🔦查看默认级别: `vi /etc/inittab`

**❄️Linux系统有`7`种运行级别(runlevel)：`常用的级别是3和5`**

  **运行级别0：** 系统停机状态，系统默认运行级别不能设为0，否则不能正常启动。
    
  **运行级别1：** 单用户工作状态，root权限，用于系统维护，禁止远程登陆。
    
  **运行级别2：** 多用户状态(没有NFS：网络文件系统)，不支持网络。
    
  **运行级别3：** 完全的多用户状态(有NFS：网络文件系统)，登陆后进入控制台命令行模式。
    
  **运行级别4：** 系统未使用，保留。
    
  **运行级别5：** X11控制台，登陆后进入图形GUI模式。
    
  **运行级别6：** 系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动。

❄️**CentOS7 的运行级别简化为：**

   **multi-user.target** 等价于原运行级别3，多用户有网，无图形界面）
    
   **graphical.target** 等价于原运行级别5，多用户有网，有图形界面

**📃查看当前运行级别**

```shell
systemctl get-default
```

**📝修改当前运行级别**

```shell
systemctl set-default xxx.target
```

### 防火墙开闭

CentOS 7版本后防火墙默认使用的是firewalld

**📃查看防火墙状态**

```shell
systemctl status firewalld.service
```

🖇运行上述命令后，如果看到有绿色字样标注的“active（running）”，说明防火墙是开启状态。

**📃关闭运行的防火墙**

```shell
systemctl stop firewalld.service
```

🖇关闭后，可查看防火墙状态，当显示disavtive（dead）的字样，说明CentOS 7防火墙已经关闭。

🖇上面的命令只是临时关闭了CentOS 7防火墙，当重启操作系统后，防火墙服务还是会再次启动。如果想要永久关闭防火墙则还需要开机禁用防火墙服务。

**📃开机禁用防火墙服务**

```shell
systemctl disable firewalld.service
```

**📃启动防火墙**

```shell
systemctl start firewalld
```

**📃开机启用防火墙**

```shell
systemctl enable firewalld
```

### 关机重启命令

在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是不会停止的，除非特殊情况下，不得已才会关机。

#### 📚shutdown命令

📔可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。shutdown命令作用同于poweroff命令。

| 参数 | 说明                                   |
| ---- | -------------------------------------- |
| \-f  | 重新启动时不执行fsck                   |
| \-F  | 重新启动时执行fsck                     |
| \-h  | 将系统关机                             |
| \-c  | 取消关机任务                           |
| \-k  | 发送信息给所有用户                     |
| \-n  | 不调用init程序进行关机                 |
| \-r  | 将系统重启                             |
| \-t  | 送出警告信息和删除信息之间要延迟多少秒 |

📃参考实例

```shell
# 立即关机
shutdown -h now

# 指定 10 分钟后关机
shutdown -h 10

# 立即重新启动计算机
shutdown -r now

# 设定当前的服务器指定时间自动关机，格式为”小时:分钟“：
shutdown -h 21:00

# 设定当前的服务器5分钟后关机，同时发送警告信息给所有已登录的用户：
shutdown +5 "System will shutdown after 5 minutes" 

# 取消当前服务器上已有的关机任务：
shutdown -c 
```

#### 📚sync命令

📔用于数据同步,sync命令是在关闭Linux系统时使用的。

🔖sync命令用于强制被改变的内容立刻写入磁盘，更新信息速度非常快， 在Linux/Unix系统中，在文件或数据处理过程中一般先放到内存缓冲区中，等到适当的时候再写入磁盘，以提高系统的运行效率。

🔖sync命令则可用来强制将内存缓冲区中的数据立即写入磁盘中。用户通常不需执行sync命令，系统会自动执行update或bdflush操作，将缓冲区的数据写入磁盘。只有在update或bdflush无法执行或用户需要非正常关机时，才需手动执行sync命令。

| 参数     | 说明                 |
| -------- | -------------------- |
| –help    | 显示命定详细帮助信息 |
| –version | 显示版本号           |

📃参考实例

```shell
# 显示帮助信息
sync --help

# 显示版本
sync --version
```

#### 📚halt命令

📔用于关闭当前服务器系统，类似于poweroff与shutdown命令，没有太大差别。

| 参数                                         | 说明 |
| -------------------------------------------- | ---- |
| \-n : 在关机前不做将记忆体资料写回硬盘的动作 |      |
| \-w 模拟关机，把过程写入到日志文件           |      |
| \-d 不写入日志纪录                           |      |
| \-f 强制关机或重启                           |      |
| \-i 关机或重启前关掉所有的网络服务           |      |
| \-p : 当关机的时候，顺便做关闭电源的动作     |      |

📃参考实例

```shell
# 关闭系统
halt
# 关闭系统并关闭电源
halt -p
 
# 关闭系统，但不留下纪录
halt -d

# 强制关闭当前服务器系统：
halt -f
```

#### 📚poweroff命令

📔用来关闭计算机操作系统并且切断系统电源。如果确认系统中已经没有用户存在且所有数据都已保存，需要立即关闭系统，可以使用poweroff命令。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| \-n  | 关闭操作系统时不执行sync操作                                 |
| \-w  | 不真正关闭操作系统，仅在日志文件“/var/log/wtmp”中            |
| \-d  | 关闭操作系统时，不将操作写入日志文件“/var/log/wtmp”中添加相应的记录 |
| \-f  | 强制关闭操作系统                                             |
| \-i  | 关闭操作系统之前关闭所有的网络接口                           |
| \-h  | 关闭操作系统之前将系统中所有的硬件设置为备用模式             |

📃参考实例

```shell
# 关闭计算机操作系统并且切断系统电源：
poweroff
# 使用-h参数关闭操作系统之前将系统中所有的硬件设置为备用模式
poweroff -h
```

#### 📚reboot命令

📔用于重新启动计算机。

| 参数 | 说明                             |
| ---- | -------------------------------- |
| \-n  | 直接重启系统，不保存当前资料     |
| \-w  | 模拟重启过程，将过程写入到日志中 |
| \-d  | 重启系统但不将过程写入到日志中   |
| \-f  | 强制重启系统                     |
| \-i  | 关闭所有的网络服务，然后重启系统 |

📃参考实例

```shell
# 重启当前系统
reboot
 
# 模拟重启当前系统：
reboot -w
```

## 💼常用命令

Shell可以看作是一个命令解释器，为我们提供了交互式的文本控制的界面。我们可以通过终端控制台来输入命令，由 shell进行解释并最终交给内核执行。

SH(Bourne Shell)是UNIX最初使用的shell，BASH(Bourne Again Shell)Linux默认的，是Bourne Shell的扩展

### 输出重定向 `>` 和追加 `>>` 

| 参数                | 说明                        |
| ------------------- | --------------------------- |
| ls -l > 文件        | 将列表的内容写入文件a.txt中 |
| ls -al >> 文件      | 列表的内容追加到文件的末尾  |
| cat 文件1 > 文件2   | 将文件1的内容覆盖到文件2    |
| echo “内容” >> 文件 | 将内容写入到文件            |

### 帮助常用命令

#### 📚man命令

📔man命令来自于英文单词manual的缩写，中文译为帮助手册，其功能是用于查看命令、配置文件及服务的帮助信息。一份完整的帮助信息包含以下信息：

| 名称        | 意义                     |
| ----------- | ------------------------ |
| NAME        | 命令的名称               |
| SYNOPSIS    | 参数的大致使用方法       |
| DESCRIPTION | 介绍说明                 |
| EXAMPLES    | 演示（附带简单说明）     |
| OVERVIEW    | 概述                     |
| DEFAULTS    | 默认的功能               |
| OPTIONS     | 具体的可用选项（带介绍） |
| ENVIRONMENT | 环境变量                 |
| FILES       | 用到的文件               |
| SEE ALSO    | 相关的资料               |
| HISTORY     | 维护历史与联系方式       |

| 参数 | 说明                         |
| ---- | ---------------------------- |
| \-a  | 在所有的man帮助手册中搜索    |
| \-d  | 检查新加入的文件是否有错误   |
| \-f  | 显示给定关键字的简短描述信息 |
| \-p  | 指定内容时使用分页程序       |
| \-M  | 指定man手册搜索的路径        |
| \-w  | 显示文件所在位置             |

| 快捷键  | 说明                 |
| ------- | -------------------- |
| q       | 退出                 |
| Enter   | 按行下翻             |
| Space   | 按页下翻             |
| b       | 上翻一页             |
| /字符串 | 在手册页中查找字符串 |

📃参考实例

```shell
# 查看指定命令的帮助信息：
man ls

//查看指定配置文件的帮助信息
//如果即有passwd命令，又有/etc/passwd文件，则需要手动指定帮助信息的编号。编号规则：普通命令为1，函数为2，库文件为3，设备为4，配置文件为5，游戏为6，宏文件为7，系统命令为8，内核程序为9，TK指令为10。
man 5 passwd

# 找到某个命令的帮助信息的存储位置
man -w ls

# 找到某个配置文件的帮助信息的存储位置
man -w 5 passwd

# man查看内置命令
[pinkpig@Demo100 ~]$ man -f cd
cd (1)               - GNU Bourne-Again SHell (GNU 命令解释程序 “Bourne二...
cd (3tcl)            - 改变工作目录
cd (1p)              - change the working directory
[pinkpig@Demo100 ~]$ man 1p cd
[pinkpig@Demo100 ~]$ man 3 cd
```

**📍 一部分基础功能的系统命令是直接内嵌在shell 中的，系统加载启动之后会随着shell一起加载，常驻系统内存中。这部分命令被称为“内置(built-in)命令”﹔相应的其它命令被称为“外部命令”。**

#### 📚help命令

📔用于显示帮助信息，能够输出Shell内部命令的帮助内容，但对于外部命令则无法使用，需要用man或info命令进行查看。

| 参数 | 说明                        |
| ---- | --------------------------- |
| \-d  | 输出每个命令的简短描述      |
| \-s  | 输出短格式的帮助信息        |
| \-m  | 以man手册的格式显示帮助信息 |

📃参考实例

```shell
# 以默认格式显示指定命令的帮助信息
help cd

# 以短格式显示指定命令的帮助信息
help -s cd

# 以简短格式显示指定命令的帮助信息
help -d cd

# 以man命令格式显示指定命令的帮助信息
help -m cd
```

#### 📚type命令

📔用来显示指定命令的类型，判断给出的指令是内部指令还是外部指令。

| 参数     | 说明                     |
| -------- | ------------------------ |
| lias     | 别名                     |
| keyword  | 关键字，Shell保留字      |
| function | 函数，Shell函数          |
| builtin  | 内建命令，Shell内建命令  |
| file     | 文件，磁盘文件，外部命令 |
| unfound  | 没有找到                 |

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| \-t  | 判断给定参数的命令类型。如果输出 file、alias、builtin 则分别表示 外部命令、命令别名、内置命令。 |
| \-p  | 如果给出的参数是外部命令，则显示其绝对路径。                 |
| \-a  | 显示所有可能的类型，包括别名、内置命令、函数等。             |
| \-f  | 只返回shell函数的信息。                                      |

📃参考实例

```shell
# 显示指定命令的所有信息
type -a ls

# 显示外部命令的绝对路径
type -p ls

# 查看命令类型
type -t ls
```

#### 📚clear命令

📔clear命令用于清除屏幕。这个命令将会刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。

#### 📚reset命令

📔reset命令其实和 tset 是一同个命令，用于重置终端机的状态，将终端机设置为原始状态。

#### 📚tset命令

📔tset命令的作用是可以进行终端初始化。默认终端类型为“unknown”。

### 文件常用命令

#### 📚pwd命令

📔pwd命令来自于英文词组”print working directory“的缩写，其功能是用于显示当前工作目录的路径，即显示所在位置的绝对路径。

📃参考实例

```shell
# 查看当前工作目录路径
pwd
```

#### 📚cd命令

📔cd命令来自于英文词组”change directory“的缩写，其功能是用于更改当前所处的工作目录，路径可以是绝对路径，也可以是相对路径，若省略不写则会跳转至当前使用者的家目录。`~` 也表示为 home 目录 的意思， `.` 则是表示目前所在的目录，`..`则表示目前目录位置的上一层目录。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| \-P  | 如果切换的目标目录是一个符号链接，则直接切换到符号链接指向的目标目录 |
| \-L  | 如果切换的目标目录是一个符号链接，则直接切换到符号链接名所在的目录 |
| –    | 仅使用”-“选项时，当前目录将被切换到环境变量”OLDPWD”对应值的目录 |
| ~    | 切换至当前用户目录                                           |
| …    | 切换至当前目录位置的上一级目录                               |

📃参考实例

```shell
# 切换当前工作目录至/etc
cd /etc

# 切换至当前用户的家目录：
cd ~

# 进入到上一级所在目录（家目录→根目录）
cd ..

# 返回到上一次所在目录（根目录→家目录）
cd -

# 跳到目前目录的上上两层
cd ../..
```

#### 📚ls命令

📔ls命令来自于英文单词list的缩写，其功能是列举出指定目录下的文件名称及其属性。默认不加参数的情况下，ls命令会列出当前工作目录中的文件信息。

| 参数   | 说明                                            |
| ------ | ----------------------------------------------- |
| \-a    | 显示所有文件及目录 (包括以“.”开头的隐藏文件)    |
| \-l    | 使用长格式列出文件及目录的详细信息              |
| \-r    | 将文件以相反次序显示(默认依英文字母次序)        |
| \-t    | 根据最后的修改时间排序                          |
| \-A    | 同 -a ，但不列出 “.” (当前目录) 及 “…” (父目录) |
| \-S    | 根据文件大小排序                                |
| \-R    | 递归列出所有子目录                              |
| \-d    | 查看目录的信息，而不是里面子文件的信息          |
| \-i    | 输出文件的inode节点信息                         |
| \-m    | 水平列出文件，以逗号间隔                        |
| \-X    | 按文件扩展名排序                                |
| –color | 输出信息中带有着色效果                          |

📃参考实例

```shell
# 输出当前目录中的文件（默认不含隐藏文件）
ls

# 输出当前目录中的文件（含隐藏文件）
ls -a

# 输出文件的长格式，包含属性详情信息
ls -l

# 输出指定目录中的文件列表
ls /etc

# 输出文件名称及inode属性块号码
ls -i

# 搭配通配符一起使用，输出指定目录中所有以sd开头的文件名称
ls /dev/sd*

# 依据文件大小进行排序，输出指定目录中文件属性详情信息
ls -Sl /etc
```

#### 📚mkdir命令

📔来自于英文词组“make directories”的缩写，其功能是用来创建目录文件。

| 参数 | 说明                         |
| ---- | ---------------------------- |
| \-p  | 递归创建多级目录             |
| \-m  | 建立目录的同时设置目录的权限 |
| \-z  | 设置安全上下文               |
| \-v  | 显示目录的创建过程           |

📃参考实例

```shell
# 在当前工作目录中，建立一个目录文件
mkdir dir1

# 在当前工作目录中，创建一个目录文件并设置700权限，不让除所有主以外任何人读、写、执行它
mkdir -m 700 dir2

# 在当前工作目录中，一次性创建多个目录文件
mkdir dir3 dir4 dir5

# 在系统根目录中，一次性创建多个有嵌套关系的目录文件
mkdir -p /dir1/dir2/dir3/dir4/dir5
```

#### 📚rmdir命令

📔来自于英文词组“remove directory”的缩写，其功能是用于删除空目录文件。

❗ rmdir命令仅能够删除空内容的目录文件，如需删除非空目录时，则需要使用带有-R参数的rm命令进行操作。而rmdir命令的-p递归删除操作亦不意味着能删除目录中已有的文件，而是要求每个子目录都必须是空的。

| 参数 | 说明                                                       |
| ---- | ---------------------------------------------------------- |
| \-p  | 用递归的方式删除指定的目录路径中的所有父级目录，非空则报错 |
| \-v  | 显示命令的详细执行过程                                     |

📃参考实例

```shell
# 删除指定的空目录
rmdir Documents

# 删除指定的空目录，及其内的子空目录
rmdir -p Documents

# 删除指定的空目录，并显示删除的过程
rmdir -v Documents
```

#### 📚rm命令

📔来自于英文单词remove的缩写，其功能是用于删除文件或目录，一次可以删除多个文件，或递归删除目录及其内的所有子文件。

| 参数  | 说明                     |
| ----- | ------------------------ |
| \-f   | 强制删除（不二次询问）   |
| \-i   | 删除前会询问用户是否操作 |
| \-r/R | 递归删除                 |
| \-v   | 显示指令的详细执行过程   |

📃参考实例

```shell
# 删除某个文件，默认会进行二次确认，敲击y进行确认
rm anaconda-ks.cfg 

# 删除某个文件，强制操作不需要二次确认：
rm -f initial-setup-ks.cfg 

# 删除某个目录及其内的子文件或子目录，一并都强制删除
rm -rf Documents

# 强制删除当前工作目录内的所有以.txt为后缀的文件
rm -f *.txt

# 强制清空服务器系统内的所有文件
rm -rf /*
```

#### 📚cp命令

📔来自于英文单词copy的缩写，用于将一个或多个文件或目录复制到指定位置。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| \-f  | 若目标文件已存在，则会直接覆盖原文件                         |
| \-i  | 若目标文件已存在，则会询问是否覆盖                           |
| \-p  | 保留源文件或目录的所有属性                                   |
| \-r  | 递归复制文件和目录                                           |
| \-d  | 当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录 |
| \-l  | 对源文件建立硬连接，而非复制文件                             |
| \-s  | 对源文件建立符号连接，而非复制文件                           |
| \-b  | 覆盖已存在的文件目标前将目标文件备份                         |
| \-v  | 详细显示cp命令执行的操作过程                                 |
| \-a  | 等价于“pdr”选项                                              |

📃参考实例

```shell
# 在当前工作目录中，将某个文件复制一份，并定义新文件名称
cp anaconda-ks.cfg kickstart.cfg

# 在当前工作目录中，将某个目录复制一份，并定义新目录名称
cp -r Documents Doc

复制某个文件时，保留其原始权限及用户归属信息
cp -a kickstart.cfg ks.cfg

# 将某个文件复制到/etc目录中，并覆盖已有文件，不进行询问
cp -f ks.cfg /etc

# 将多个文件一同复制到/etc目录中，如已有目标文件名称则默认询问是否覆盖
cp anaconda-ks.cfg ks.cfg /etc
```

#### 📚mv命令

📔自于英文单词move的缩写，用于对文件进行剪切和重命名。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| \-i  | 若存在同名文件，则向用户询问是否覆盖                         |
| \-f  | 覆盖已有文件时，不进行任何提示                               |
| \-b  | 当文件存在时，覆盖前为其创建一个备份                         |
| \-n: | 不要覆盖任何已存在的文件或目录                               |
| \-u  | 当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作 |

📃参考实例

```shell
# 在当前工作目录中，对某个文件进行剪切后粘贴（重命名）操作
mv anaconda-ks.cfg ks.cfg

# 将某个文件移动到/etc目录中，保留文件原始名称
mv ks.cfg /etc

# 将某个目录移动到/etc目录中，并定义新的目录名称
mv Documents /etc/docs

# 将/home目录中所有的文件都移动到当前工作目录中，遇到已存在文件则直接覆盖
mv -f /home/* .
```

#### 📚cat命令

📔自于英文单词concatenate的缩写，其功能是用于查看文件内容。cat命令适合查看内容较少的、纯文本的文件。

| 参数 | 说明                           |
| ---- | ------------------------------ |
| \-n  | 显示行数（空行也编号）         |
| \-s  | 显示行数（多个空行算一个编号） |
| \-b  | 显示行数（空行不编号）         |
| \-E  | 每行结束处显示$符号            |

📃参考实例

```shell
# 查看某个文件的内容
cat anaconda-ks.cfg

# 查看某个文件的内容，并显示行号
cat -n anaconda-ks.cfg

# 搭配空设备文件和输出重定向操作符，将某个文件内容清空
cat /dev/null > anaconda-ks.cfg 

# 持续写入文件内容，直到碰到EOF符后才会结束并保存

# 搭配输出重定向操作符，将光盘设备制作成镜像文件
[root@Demo ~]# cat /dev/cdrom > rhel.iso
[root@Demo ~]# ls rhel.iso  -lh
-rw-r--r--. 1 root root 6.7G May  2 00:43 rhel.iso
[root@Demo ~]# file rhel.iso 
rhel.iso: DOS/MBR boot sector; partition 2 : ID=0xef, start-CHS (0x3ff,254,63), end-CHS (0x3ff,254,63), startsector 23128, 19888 sectors
```

#### 📚more命令

📔用于分页显示文本文件内容。如果文本文件中的内容较多较长，使用cat命令读取后则很难看清，这时使用more命令进行分页查看就更加合适，可以把文本内容一页一页的显示在终端界面上，用户每按一次回车即向下一行，每按一次空格即向下一页，直至看完为止。

| 参数      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| \-num     | 指定每屏显示的行数                                           |
| \-l       | more在通常情况下把 ^L 当作特殊字符, 遇到这个字符就会暂停,-l选项可以阻止这种特性 |
| \-f       | 计算实际的行数，而非自动换行的行数                           |
| \-p       | 先清除屏幕再显示文本文件的剩余内容                           |
| \-c       | 与-p相似，不滚屏，先显示内容再清除旧内容                     |
| \-s       | 多个空行压缩成一行显示                                       |
| \-u       | 禁止下划线                                                   |
| +/pattern | 在每个文档显示前搜寻该字(pattern)，然后从该字串之后开始显示  |
| +num      | 从第 num 行开始显示                                          |

📃参考实例

```shell
# 分页显示指定的文本文件内容
more anaconda-ks.cfg 

# 先进行清屏操作，随后以每次10行内容的格式显示指定的文本文件内容
more -c -10 anaconda-ks.cfg

# 分页显示指定的文本文件内容，遇到连续两行以上空白行的情况，则以一行空白行显示
more -s anaconda-ks.cfg

# 从第10行开始，分页显示指定的文本文件内容
more +10 anaconda-ks.cfg 
```

#### 📚less命令

📔less 指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。

| 参数 | 说明                               |
| ---- | ---------------------------------- |
| \-b  | 设置缓冲区的大小                   |
| \-e  | 当文件显示结束后自动退出           |
| \-f  | 强制打开文件                       |
| \-g  | 只标志最后搜索的关键词             |
| \-i  | 忽略搜索时的大小写                 |
| \-m  | 显示阅读进度百分比                 |
| \-N  | 显示每行的行号                     |
| \-o  | 将输出的内容在指定文件中保存起来   |
| \-Q  | 不使用警告音                       |
| \-s  | 显示连续空行为一行                 |
| \-S  | 在单行显示较长的内容，而不换行显示 |
| \-x  | 将TAB字符显示为指定个数的空格字符  |

📃参考实例

```shell
# 分页查看指定的文件内容
less anaconda-ks.cfg 

# 分页查看指定的文件内容及行号
less -N anaconda-ks.cfg 

# 分页显示指定命令的输出结果
history | less
```

#### 📚echo命令

📔输出字符串或提取后的变量值

🔖echo是用于在终端设备上输出指定字符串或变量提取后值的命令。能够给用户一些简单的提醒信息，也可以将输出的指定字符串内容同管道符一起传递给后续命令作为标准输入信息再来进行二次处理，又或者同输出重定向符一起操作，将信息直接写入到文件中。

🔖如需提取变量值，需在变量名称前加入$符号做提取，变量名称一般均为大写形式。

| 参数      | 说明                             |
| --------- | -------------------------------- |
| \-n       | 不输出结尾的换行符               |
| \-e “\\a” | 发出警告音                       |
| \-e “\\b” | 删除前面的一个字符               |
| \-e “\\c” | 结尾不加换行符                   |
| \-e “\\f” | 换行，光标扔停留在原来的坐标位置 |
| \-e “\\n” | 换行，光标移至行首               |
| \-e “\\r” | 光标移至行首，但不换行           |
| \-E       | 禁止反斜杠转移，与-e参数功能相反 |

📃参考实例

```shell
# 输出指定字符串到终端设备界面
echo LinuxCool

# 输出某个变量值内容
echo $PATH

# 搭配转义符一起使用，输出纯字符串内容
echo \$PATH

# 搭配输出重定向符一起使用，将字符串内容直接写入文件中
echo "Hello World" > Document

# 搭配反引号执行命令，并将执行结果输出
echo `uptime`

# 输出带有换行符的内容
echo -e "First\nSecond\nThird"

# 指定删除字符串中某些字符，随后将内容输出。结果：12456
echo -e "123\b456" 
```

#### 📚head命令

📔显示文件开头的内容，默认为前10行。

| 参数       | 说明                     |
| ---------- | ------------------------ |
| \-v        | 总是显示文件名的头信息   |
| \-q        | 不显示文件名的头信息     |

📃参考实例

```shell
# 指定显示文件的前5行内容
head -n 5 anaconda-ks.cfg 

# 指定显示文件的前20个字符
head -c 20 anaconda-ks.cfg 
```

#### 📚tail命令

📔用于查看文件尾部内容，默认为后10行。如果指定了多个文件，则会在显示的每个文件内容前面加上文件名来加以区分。

| 参数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| \-c           | 输出文件尾部的N（N为整数）个字节内容                         |
| \-f           | 持续显示文件最新追加的内容                                   |
| \-n           | 输出文件的尾部N（N位数字）行内容                             |
| –retry        | 即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。 |
| –pid=<进程号> | 与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令 |

📃参考实例

```shell
# 指定显示某个文件尾部的后5行内容
tail -n 5 initial-setup-ks.cfg 

# 指定显示某个文件尾部的后15个字节
tail -c 15 initial-setup-ks.cfg 

# 持续刷新显示某个文件尾部的后10行内容
tail -f /var/log/messages

# 显示文件 notes.log 的内容，从第 20 行至文件末尾
tail -n +20 notes.log
```

#### 📚ln命令

📔自于英文单词link的缩写，中文译为“链接”，其功能是用于为某个文件在另外一个位置建立同步的链接。

🔖Linux系统中的链接文件有两种形式，一种是硬链接（hard link），另一种是软链接（symbolic link）。

🔖软连接相当于Windows系统中的快捷方式文件，原始文件被移动或删除后，软连接文件也将无法使用，而硬链接则是通过将文件的inode属性块进行了复制 ，因此把原始文件移动或删除后，硬链接文件依然可以使用。

| 参数 | 说明                                                 |
| ---- | ---------------------------------------------------- |
| \-b  | 为每个已存在的目标文件创建备份文件                   |
| \-d  | 此选项允许“root”用户建立目录的硬链接                 |
| \-f  | 强制创建链接，即使目标文件已经存在                   |
| \-n  | 把指向目录的符号链接视为一个普通文件                 |
| \-i  | 交互模式，若目标文件已经存在，则提示用户确认进行覆盖 |
| \-s  | 对源文件建立符号链接，而非硬链接                     |
| \-v  | 详细信息模式，输出指令的详细执行过程                 |

📃参考实例

```shell
# 为指定的源文件创建快捷方式（默认为硬链接形式）
ln anaconda-ks.cfg ana.cfg

# 为指定的源文件创建快捷方式（设定为软连接形式）
ln -s initial-setup-ks.cfg ini.cfg

# 在指定的源文件创建快捷方式，并输出制作的过程信息
ln -v anaconda-ks.cfg ana.cfg
```

#### 📚history命令

📔显示与管理历史命令记录。Linux系统默认会记录用户所执行过的所有命令，可以使用history命令查阅它们，也可以对其记录进行修改和删除操作。

| 参数 | 说明                       |
| ---- | -------------------------- |
| \-a  | 写入命令记录               |
| \-c  | 清空命令记录               |
| \-d  | 删除指定序号的命令记录     |
| \-n  | 读取命令记录               |
| \-r  | 读取命令记录到缓冲区       |
| \-s  | 将指定的命令添加到缓冲区   |
| \-w  | 将缓冲区信息写入到历史文件 |

### 时间日期常用命令

#### 📚date命令

📔用来显示或设定系统的日期与时间。

| 参数 | 说明                                      |
| ---- | ----------------------------------------- |
| \-d  | 通过字符串显示时间格式，字符串不能是’now’ |
| \-s  | 根据字符串设置系统时间                    |
| \-u  | 显示目前的格林威治时间                    |
| \-r  | 显示文件的上次修改时间                    |

📍若是不以加号作为开头，则表示要设定时间，而时间格式为 `MMDDhhmm[[CC]YY][.ss]`，其中`MM`为月份，`DD` 为日，`hh` 为小时，`mm` 为分钟，`CC` 为年份前两位数字，`YY` 为年份后两位数字，`ss` 为秒数。

📍当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 `-` 符号，比如说 `date '+%-H:%-M:%-S'` 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。

📍当您以 root 身分更改了系统时间之后，请记得以 `clock -w` 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续保持最新的正确值。

📃参考实例

```shell
# 以默认格式输出系统当前的日期与时间信息
date

# 按照“年-月-日”的指定格式输出系统当前的日期信息
date "+%Y-%m-%d"

# 按照“小时:分钟:秒”的指定格式输出系统当前的时间信息
date "%H:%M:%S"

# 输出昨天日期
date -d "1 day ago" +"%Y-%m-%d"

# 输出 2 秒后的时间
date -d "2 second" +"%Y-%m-%d %H:%M.%S"

# 时间格式转换
date -d "2009-12-12" +"%Y/%m/%d %H:%M.%S"

# 按自己的格式输出
date '+usr_time: $1:%M %P -hey'
```

📃时间加减操作

```shell
date +%Y%m%d                   # 显示年月日
date -d "+1 day" +%Y%m%d       # 显示后一天的日期
date -d "-1 day" +%Y%m%d       # 显示前一天的日期
date -d "-1 month" +%Y%m%d     # 显示上一月的日期
date -d "+1 month" +%Y%m%d     # 显示下一月的日期
date -d "-1 year" +%Y%m%d      # 显示前一年的日期
date -d "+1 year" +%Y%m%d      # 显示下一年的日期
```

📃设定时间

```shell
date -s                         # 设置当前时间，只有root权限才能设置，其他只能查看
date -s 20120523                # 设置成20120523，这样会把具体时间设置成00:00:00
date -s 01:01:01                # 设置具体时间，不会对日期做更改
date -s "01:01:01 2012-05-23"   # 这样可以设置全部时间
date -s "01:01:01 20120523"     # 这样可以设置全部时间
date -s "2012-05-23 01:01:01"   # 这样可以设置全部时间
date -s "20120523 01:01:01"     # 这样可以设置全部时间
```

#### 📚cal命令

📔显示日历。

🔖cal命令的名字来自英语单词“Calendar”。改命令用来显示当前日历，或者指定日期的公历（公历是现在国际通用的历法，又称格列历，通称阳历。）如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份 。

| 参数 | 说明                           |
| ---- | ------------------------------ |
| \-l  | 单月分输出日历                 |
| \-3  | 显示最近三个月的日历           |
| \-s  | 将星期天作为月的第一天         |
| \-m  | 将星期一作为月的第一天         |
| \-j  | 显示在当年中的第几天（儒略日） |
| \-y  | 显示当年的日历                 |

📃参考实例

```shell
# 显示当前月份的日历
cal

# 显示近期三个月的日历(当前月，上一个月和下一个月)
cal -3  
                                                        
# 显示指定年月的日历，如显示2020年2月的日历
cal 2 2020
```

### 用户管理常用命令

#### 📚useradd命令

📔创建并设置用户信息。

🔖useradd命令来自于英文词组“User add”的全拼，其功能是用于创建并设置用户信息。使用useradd命令可以自动的完成创建用户的信息、基本组、家目录等工作，并在创建的过程中对用户初始信息进行定制。

🔖已创建的用户则需使用chmod命令修改账户信息，passwd命令修改密码信息。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| \-D  | 改变新建用户的预设值                                         |
| \-c  | 添加备注文字                                                 |
| \-d  | 新用户每次登陆时所使用的家目录                               |
| \-e  | 用户终止日期，日期的格式为YYYY-MM-DD                         |
| \-f  | 用户过期几日后永久停权。当值为0时用户立即被停权，而值为-1时则关闭此功能，预设值为-1 |
| \-g  | 指定用户对应的用户组                                         |
| \-G  | 定义此用户为多个不同组的成员                                 |
| \-m  | 用户目录不存在时则自动创建                                   |
| \-M  | 不建立用户家目录，优先于/etc/login.defs文件设定              |
| \-n  | 取消建立以用户名称为名的群组                                 |
| \-r  | 建立系统帐号                                                 |
| \-u  | 指定用户id                                                   |

📃参考实例

```shell
# 创建指定的用户信息
useradd user1

# 创建指定的用户信息，但不创建家目录，亦不让登录系统
useradd -M -s /sbin/nologin user2

# 创建指定的用户信息，并自定义UID值
useradd -u 6688 user3

# 创建指定的用户信息，并追加指定组为该账户的扩展组
useradd -G root user4

# 创建指定的用户信息，并指定过期时间
useradd -e "2023/01/01" user5

# 为新添加的用户指定home目录
useradd -d /home/myd user6
```

#### 📚passwd命令

📔 修改用户的密码值。

🔖passwd命令来自于英文单词password的缩写。同时也可以对用户进行锁定等操作，但需要管理员身份才可以执行。

| 参数 | 说明                         |
| ---- | ---------------------------- |
| \-d  | 删除已有密码                 |
| \-l  | 锁定用户的密码值，不允许修改 |
| \-u  | 解锁用户的密码值，允许修改   |
| \-e  | 下次登陆强制修改密码         |
| \-k  | 用户在期满后能仍能使用       |
| \-S  | 查询密码状态                 |

📃参考实例

```shell
# 修改当前登录用户的密码值
passwd

# 修改指定用户的密码值
passwd linuxprobe

# 锁定指定用户的密码值，不允许其进行修改
passwd -l linuxprobe

# 解锁指定用户的密码值，允许其进行修改
passwd -u linuxprobe

# 强制指定的用户在下次登陆时必须重置其密码
passwd -e linuxprobe

# 删除指定用户的密码值
passwd -d linuxprobe

# 查看指定用户的密码状态
passwd -S linuxprobe
```

#### 📚su命令

📔 切换用户身份。

🔖su命令来自于英文单词“switch user”的缩写。管理员切换至任意用户身份而无需密码验证，而普通用户切换至任意用户身份均需密码验证。另外添加单个减号（-）参数为完全的身份变更，不保留任何之前用户的环境变量信息。

| 参数          | 说明                                       |
| ------------- | ------------------------------------------ |
| 单个减号（-） | 完全身份变更                               |
| \-c           | 执行完指定的指令后，即恢复原来的身份       |
| \-f           | 适用于csh与tsch，使shell不用去读取启动文件 |
| \-l           | 改变身份时，也同时变更工作目录             |
| \-m           | 变更身份时，不要变更环境变量               |
| \-s           | 指定要执行的shell                          |

📃参考实例

```shell
# 变更至指定用户身份
su user1

# 完全变更至指定用户身份
su - user1
```

#### 📚id命令

📔 显示用户与用户组信息。

🔖UID是指用户身份的唯一识别号码，相当于人类社会的身份证号码，而GID则指用户组的唯一识别号码，用户仅有一个基本组，但可以有多个扩展组。

| 参数 | 说明                             |
| ---- | -------------------------------- |
| \-g  | 显示用户所属群组的ID             |
| \-G  | 显示用户扩展群组的ID             |
| \-n  | 显示用户所属群组或扩展群组的名称 |
| \-r  | 显示实际ID                       |
| \-u  | 显示用户ID                       |

📃参考实例

```shell
# 显示当前用户的身份信息
id

# 显示当前用户的所属群组GID
id -g

# 显示当前用户的身份码UID
id -u

# 查询当前用户的身份信息
id linuxprobe

# 查看创建了哪些用户
cat /etc/passwd
```

#### 📚who命令

📔 用于显示当前登录用户信息，包含登录的用户名、终端、日期时间、进程等信息，帮助运维人员了解当前系统的登入用户情况。

| 参数 | 说明                             |
| ---- | -------------------------------- |
| \-a  | 全面信息                         |
| \-b  | 系统最近启动时间                 |
| \-d  | 死掉的进程                       |
| \-l  | 系统登录进程                     |
| \-H  | 带有列标题打印用户名，终端和时间 |
| \-t  | 系统上次锁定时间                 |
| \-u  | 已登录用户列表                   |

📃参考实例

```shell
# 查看当前登录用户信息
who

# 查看当前登录用户信息，并加上标题
who -H

# 查看当前全部的登录全部用户信息
who -H -a

# 查看系统的最近启动时间
who -b
```

#### 📚userdel命令

📔删除用户账户。

🔖userdel命令来自于英文词组“user delete”的缩写。Linux系统中一切都是文件，用户信息被保存到了/etc/passwd、/etc/shadow以及/etc/group文件中，因此使用userdel命令实际就是帮助我们删除了指定用户在上述三个文件中的对应信息。

| 参数 | 说明                           |
| ---- | ------------------------------ |
| \-f  | 强制删除用户账号               |
| \-r  | 删除用户主目录及其中的任何文件 |

📃参考实例

```shell
# 删除指定的用户账户信息
userdel linuxcool

# 删除指定的用户账户信息及家目录
userdel -r linuxcool
```

#### 📚sudo命令

📔授权普通用户执行管理员命令。

🔖sudo命令来自于英文词组“super user do”的缩写，中文译为“超级用户才能干的事”。使用sudo服务可以授权某个指定的用户去执行某些指定的命令，在满足工作需求的前提下尽可能少的放权，保证服务器的安全。

🔖配置sudo服务可以直接编辑配置文件/etc/sudoers，亦可以执行visudo命令进行设置，一切妥当后普通用户便能够使用sudo命令进行操作了。

| 参数 | 说明                       |
| ---- | -------------------------- |
| \-v  | 本次需要验证当前用户的密码 |
| \-k  | 下次强制验证当前用户的密码 |
| \-b  | 将要执行的指令放在后台执行 |
| \-p  | 更改需要密码验证时的提示语 |
| \-s  | 指定默认调用的SHELL解释器  |

📃参考实例

```shell
# 查看当前用户有哪些被sudo服务授权的命令
sudo -l

# 使用某个被sudo服务允许的用户身份来执行管理员的重启命令
sudo -u linuxprobe "reboot"

# 使用当前用户身份，基于sudo命令来执行管理员的重启命令
sudo reboot

# 以root权限执行上一条命令
$ sudo !!
```

#### 📚usermod命令

📔 修改用户账号信息。

🔖usermod命令来自于英文词组“user modify”的缩写，其功能是用于修改用户账号中的各项参数。

| 参数          | 说明                               |
| ------------- | ---------------------------------- |
| \-c<备注>     | 修改用户账号的备注文字             |
| \-d<登入目录> | 修改用户登入时的家目录             |
| \-e<有效期限> | 修改账号的有效期限                 |
| \-f<缓冲天数> | 修改在密码过期后多少天即关闭该账号 |
| \-g<群组>     | 修改用户所属的群组                 |
| \-G<群组>     | 修改用户所属的附加群组             |
| \-l<账号名称> | 修改用户账号名称                   |
| \-L           | 锁定用户密码，使密码无效           |
| \-s           | 修改用户登入后所使用的shell        |
| \-u           | 修改用户ID                         |
| \-U           | 解除密码锁定                       |

📃参考实例

```shell
修改指定用户的家目录路径
usermod -d /home user1

修改指定用户的UID号码
usermod -u 6688 user1

修改指定用户的名称为user2
usermod -l user2 user1

锁定指定用户的账户，临时不允许登录系统
usermod -L user1

解锁指定用户的账户，再次允许登录系统
usermod -U user1
```

### 用户组管理常用命令

#### 📚groupadd命令

📔创建新的用户组。

🔖groupadd命令来自于英文词组“group add”。每个用户在创建时都有一个与其同名的基本组，后期可以使用groupadd命令创建出新的用户组信息，让多个用户加入到指定的扩展组中。

| 参数 | 说明                          |
| ---- | ----------------------------- |
| \-g  | 指定新建工作组的id            |
| \-r  | 创建系统工作组                |
| \-K  | 覆盖配置文件“/ect/login.defs” |
| \-o  | 允许添加组ID号不唯一的工作组  |

📃参考实例

```shell
# 创建一个新的用户组
groupadd user1

# 创建一个新的用户组，并指定GID号码
groupadd -g 6688 user1

# 创建一个新的用户组，设定为系统工作组
groupadd -r user1
```

#### 📚groupdel命令

📔删除用户组。

🔖groupdel命令用于删除指定的工作组，本命令要修改的系统文件包括/ect/group和/ect/gshadow。

🔖userdel修改系统账户文件，删除与 GROUP 相关的所有项目。给出的组名必须存在。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。

📃参考实例

```shell
# 使用groupdel命令删除user1工作组
groupdel user1

# 查看user1组是否删除成功
more /etc/group|grep user1 
```

#### 📚groupmod命令

📔更改群组识别码或名称。

🔖用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议先删除旧的，再建立新的。

| 参数 | 说明                   |
| ---- | ---------------------- |
| \-g  | 设置欲使用的群组识别码 |
| \-o  | 重复使用群组识别码     |
| \-n  | 设置欲使用的群组名称   |

📃参考实例

```shell
# 更改user1用户组为root
groupmod -n root user1
```

### 文件基本属性

- Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。

- 为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。

- 在 Linux 中我们可以使用 `ll` 或者 `ls –l` 命令来显示一个文件的属性以及文件所属的用户和组。

- 在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。


  >若是 d 则是目录；  
  >若是 - 则是文件；  
  >若是 l 则表示为链接文档(link file)； 
  >若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；  
  >若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。  

🔻接下来的字符中，以三个为一组，且均为`rwx`的三个参数的组合。其中， `r` 代表可读(read)、 `w` 代表可写(write)、 `x` 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 `-` 而已。

🔺 每个文件的属性由左边第一部分的 10 个字符来确定。  
![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/753075efdfbe4549adb3b353523c08b8.png)  
🌥 第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者)拥有该文件的权限。

🌦 第4-6位确定属组（所有者的同组用户）拥有该文件的权限。

🌧 第7-9位确定其他用户拥有该文件的权限。

⛈ 第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限。

🌩 第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 - 字符表示没有写权限。

🌨 第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 - 字符表示，则没有执行权限。  
![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/c8e7c5c0c9f340428d66c3646894fa29.png)  
☃️ 如果查看到是文件：链接数指的是硬链接个数。

⛄️ 如果查看的是文件夹：链接数指的是子文件夹个数。

### 文件权限常用命令

#### 📚chmod命令

📔 改变文件或目录权限。

🔖chmod命令来自于英文词组”change mode“的缩写。默认只有文件的所有者和管理员可以设置文件权限，普通用户只能管理自己文件的权限属性。

🔖设置权限时可以使用数字法，亦可使用字母表达式，对于目录文件建议加入-R参数进行递归操作，意味着不仅对于目录本身，也对目录内的子文件/目录都进行新权限的设定。

📎 Linux/Unix 的文件调用权限分为三级 : `文件所有者（Owner）`、`用户组（Group）`、`其它用户（Other Users）`。

![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/cb3b2acfadf54b23bf6c35055fe45a58.png)  
📎 只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。  
![在这里插入图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/1790487a98b34ebfa1d572a102ff69b2.png)

🔦 **语法：** `chmod [ {ugoa} {+-=} {rwx} ] 文件或目录`

🔦 **语法：** `chmod [ mode=421 ] 文件或目录`

`u` 表示该文件的拥有者，`g` 表示与该文件的拥有者属于同一个群体(group)者，`o` 表示其他以外的人，`a` 表示这三者皆是。

`+` 表示增加权限、`-` 表示取消权限、`=` 表示唯一设定权限。

`r` 表示可读取，`w` 表示可写入，`x` 表示可执行，`X` 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| \-c  | 若该文件权限确实已经更改，才显示其更改动作                   |
| \-f  | 若该文件权限无法被更改也不显示错误讯息                       |
| \-v  | 显示权限变更的详细资料                                       |
| \-R  | 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) |

📍 chmod命令可以使用八进制数来指定权限。

📍 文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。

📍 文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。

| #    | 权限           | rwx    | 二进制 |
| ---- | -------------- | ------ | ------ |
| 7    | 读 + 写 + 执行 | r w x  | 111    |
| 6    | 读 + 写        | r w -  | 110    |
| 5    | 读 + 执行      | r - x  | 101    |
| 4    | 只读           | r - -  | 100    |
| 3    | 写 + 执行      | \- w x | 011    |
| 2    | 只写           | \- w - | 010    |
| 1    | 只执行         | \- - x | 001    |
| 0    | 无             | \- - - | 000    |

**例：765 解释：**

  - 所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。
  
  - 用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。
  
  - 其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。

📃参考实例

```shell
# 设定某个文件的权限为775
chmod 775 anaconda-ks.cfg

# 设定某个文件让任何人都可以读取
chmod a+r anaconda-ks.cfg 

# 设定某个目录及其内子文件任何人都可以读取和读取
chmod -R a+r Documents

# 设定某个二进制命令文件上新增SUID特殊权限位
chmod u+s /sbin/reboot 

# 将文件 file1.txt 设为所有人皆可读取
chmod ugo+r file1.txt

# 将文件 file1.txt 设为所有人皆可读取
chmod a+r file1.txt

# 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入
chmod ug+w,o-w file1.txt file2.txt

# 为 ex1.py 文件拥有者增加可执行权限
chmod u+x ex1.py

# 将目前目录下的所有文件与子目录皆设为任何人可读取
chmod -R a+r *

# 此外chmod也可以用数字来表示权限如
chmod 777 file
```

#### 📚chown命令

📔 改变文件或目录的用户和用户组信息。

🔖chown命令来自于英文词组”Change owner“的缩写。管理员可以改变一切文件的所属信息，而普通用户只能改变自己文件的所属信息。

🔦 **语法格式：** `chown [参数] 所属主:所属组 文件`

| 参数 | 说明                                       |
| ---- | ------------------------------------------ |
| \-R  | 对目前目录下的所有文件与目录进行相同的变更 |
| \-c  | 显示所属信息变更信息                       |
| \-f  | 若该文件拥有者无法被更改也不要显示错误     |
| \-h  | 只对于链接文件进行变更，而非真正指向的文件 |
| \-v  | 显示拥有者变更的详细资料                   |

📃参考实例

```shell
# 改变指定文件的所属主与所属组
chown root:root /etc/fstab

# 改变指定文件的所属主与所属组，并显示过程
chown -c linuxprobe:linuxprobe /etc/fstab

# 改变指定目录及其内所有子文件的所属主与所属组
chown -R root:root /etc

# 把 /var/run/httpd.pid 的所有者设置 root
chown root /var/run/httpd.pid

# 将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup
chown runoob:runoobgroup file1.txt

# 将当前前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup
chown -R runoob:runoobgroup *

# 把 /home/runoob 的关联组设置为 512 （关联组ID），不改变所有者
chown :512 /home/runoob
```

#### 📚chgrp命令

📔 更改文件用户组。

🔖chgrp是英语单词“change group”的缩写，命令的作用和其中文释义一样，为用于变更文件或目录的所属群组。

| 参数       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| \-c        | 效果类似”-v”参数，但仅回报更改的部分                         |
| \-f        | 不显示错误信息                                               |
| \-h        | 对符号连接的文件作修改，而不更动其他任何相关文件             |
| \-R        | 递归处理，将指定目录下的所有文件及子目录一并处理             |
| \-v        | 显示指令执行过程                                             |
| –reference | 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同 |

📃参考实例

```shell
# 改变文件的群组属性
chgrp -v linuxcool file

# 根据指定文件改变文件的群组属性
chgrp --reference=file_1 file_2

# 将/usr/linuxcool及其子目录下的所有文件的用户组改为cool
chgrp -R cool /usr/linuxcool
```

### 搜索文件常用命令

#### 📚find命令

📔 根据路径和条件搜索指定文件。

🔖find命令可以使用的参数很多，并且支持正则表达式，结合管道符后能够实现更加复杂的功能。

🔖find命令通常进行的是从根目录（/）开始的全盘搜索，有别于whereis、which、locate……等等的有条件或部分文件的搜索。对于服务器负载较高的情况，建议不要在高峰时期使用find命令的模糊搜索，会相对消耗较多的系统资源。

| 参数               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| \-name             | 匹配名称                                                     |
| \-perm             | 匹配权限（mode为完全匹配，-mode为包含即可）                  |
| \-user             | 匹配所有者                                                   |
| \-group            | 匹配所有组                                                   |
| \-mtime -n +n      | 匹配修改内容的时间（-n指n天以内，+n指n天以前）               |
| \-atime -n +n      | 匹配访问文件的时间（-n指n天以内，+n指n天以前）               |
| \-ctime -n +n      | 匹配修改文件权限的时间（-n指n天以内，+n指n天以前）           |
| \-nouser           | 匹配无所有者的文件                                           |
| \-nogroup          | 匹配无所有组的文件                                           |
| \-newer f1 !f2     | 匹配比文件f1新但比f2旧的文件                                 |
| \-type b/d/c/p/l/f | 匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件） |
| \-size             | 匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件） |
| \-prune            | 忽略某个目录                                                 |
| \-exec …… {};      | 后面可跟用于进一步处理搜索结果的命令                         |

📃参考实例

```shell
# 全盘搜索系统中所有以.conf结尾的文件
find / -name *.conf

# 在/home目录中搜索所有属于指定用户的文件
find /home -user linuxprobe

# 列出当前工作目录中的所有文件、目录以及子文件信息
find .

# 在/var/log目录下搜索所有指定后缀的文件，后缀不需要大小写
find /var/log -iname "*.log"

# 在/var/log目录下搜索所有后缀不是.log的文件
find /var/log ! -name "*.log"

# 搜索当前工作目录中的所有近7天被修改过的文件
find . -mtime +7

# 全盘搜索系统中所有类型为目录，且权限为1777的目录文件
find / -type d -perm 1777

# 全盘搜索系统中所有类型为普通文件，且可以执行的文件信息
find / -type f -perm /a=x 

# 全盘搜索系统中所有后缀为.mp4的文件，并删除所有查找到的文件
find / -name "*.mp4" -exec rm -rf {} \;

# 将当前目录及其子目录下所有文件后缀为 .c 的文件列出来
find . -name "*.c"

# 将当前目录及其子目录中的所有文件列出
find . -type f

# 将当前目录及其子目录下所有最近 20 天内更新过的文件列出
find . -ctime  20

# 查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们
find /var/log -type f -mtime +7 -ok rm {} \;

# 查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件
find . -type f -perm 644 -exec ls -l {} \;

# 查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径
find / -type f -size 0 -exec ls -l {} \;
```

#### 📚updatedb命令

📔 创建或更新数据库文件。

🔖updatedb命令用来创建或更新 slocate/locate 命令所必需的数据库文件。

🔖updatedb命令的执行过程较长，因为在执行时它会遍历整个系统的目录树，并将所有的文件信息写入 slocate/locate 数据库文件中。

🔖slocate 本身具有一个数据库，里面存放了系统中文件与目录的相关信息。

🔖使用updatedb命令可以创建或更新locate所使用的数据库。如果数据库已经存在，它的数据是重复使用，以避免重读并没有改变的目录。updatedb通常每天由cron运行来更新默认的数据库。

| 参数 | 说明                                              |
| ---- | ------------------------------------------------- |
| \-o  | 忽略默认的数据库文件，使用指定的slocate数据库文件 |
| \-U  | 更新指定目录的slocate数据库                       |
| \-v  | 显示执行的详细过程                                |

📃参考实例

```shell
# 检测一个未存在的文件file.txt
locate file.txt    

# 使用 -U 参数可以指定要更新 slocate 数据库的目录
updatedb -U /root/file/

# 创建或更新mlocate数据库
updatedb

# 创建mlocate数据库，只扫描/etc目录，写入数据库到db_file文件
updatedb -o db_file -U /etc
```

#### 📚locate命令

📔快速查找文件或目录。

🔖locate命令与find命令进行全局搜索不同，locate命令是基于了数据文件（/var/lib/locatedb）进行的定点查找，由于缩小了搜索范围，因此快速快很多。

🔖Linux系统需定期执行下updatedb命令对数据库文件进行更新，然后再使用locate命令进行查找，这样才会更加准确。

| 参数 | 说明                 |
| ---- | -------------------- |
| \-c  | 只输出找到的数量     |
| \-d  | 指定数据库所在的目录 |
| \-i  | 忽略大小写           |

📃参考实例

```shell
updatedb 

# 搜索带有指定关键词的文件
locate network

# 在指定的目录下，搜索带有指定关键词的文件
locate /etc/network

# 查找 passwd 文件
locate passwd

# 搜索 etc 目录下所有以 sh 开头的文件
locate /etc/sh

# 忽略大小写搜索当前用户目录下所有以 r 开头的文件
locate -i ~/r
```

#### 📚which命令

📔查找命令文件。

🔖which命令能够快速搜索二进制程序所对应的位置。如果我们既不关心同名文件（find与locate），也不关心命令所对应的源代码和帮助文件（whereis），仅仅是想找到命令本身所在的路径，那么就使用which命令。

| 参数 | 说明                       |
| ---- | -------------------------- |
| \-n  | 指定文件名长度（不含路径） |
| \-p  | 指定文件名长度（含路径）   |
| \-w  | 指定输出时栏位的宽度       |
| \-V  | 显示版本信息               |

📃参考实例

```shell
# 查找某个指定命令文件所在位置
which reboot

# 查找多个指定命令文件所在位置
which shutdown poweroff
```

#### 📚whereis命令

📔显示命令及相关文件的路径。

🔖whereis命令用来定位命令的二进制程序、源代码文件和man手册页等相关文件的路径。

🔖whereis命令查找速度非常快，因为它不是在磁盘中乱找，而是在一个数据库中查询;

🔖数据库是linux系统自动创建的，包含有本地所有文件的信息，并且每天通过自动执行updatedb命令更新一次。

🔖whereis命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到， 原因就是该数据库文件没有被更新。

| 参数 | 说明                              |
| ---- | --------------------------------- |
| \-b  | 查找二进制程序或命令              |
| \-B  | 从指定目录下 查找二进制程序或命令 |
| \-m  | 查找man手册文件                   |
| \-M  | 从指定目录下 查找man手册文件      |
| \-s  | 只查找源代码文件                  |
| \-S  | 从指定目录下 查找源代码文件       |
| \-f  | 不显示文件名前的路径名称          |
| \-u  | 查找不包含指定类型的文件          |

📃参考实例

```shell
# 显示ln命令的程序和man手册页的位置
whereis ln

# 显示ln命令的二进制程序的路径
whereis -b ln

# 显示ln命令的man手册页的路径
whereis -m ln
```

#### 📚grep命令

📔用于查找文件里符合条件的字符串。

🔖grep来自于英文词组“global search regular expression and print out the line”的缩写，意思是用于全面搜索的正则表达式，并将结果输出。

🔖通常会将grep命令与正则表达式搭配使用，参数作为搜索过程中的补充或对输出结果的筛选，命令模式十分灵活。

🔖与之容易混淆的是egrep命令和fgrep命令。如果把grep命令当作是标准搜索命令，那么egrep则是扩展搜索命令，等价于“grep -E”命令，支持扩展的正则表达式。而fgrep则是快速搜索命令，等价于“grep -F”命令，不支持正则表达式，直接按照字符串内容进行匹配。

🔖管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。

| 参数 | 说明                                                       |
| ---- | ---------------------------------------------------------- |
| \-i  | 忽略大小写                                                 |
| \-c  | 只输出匹配行的数量                                         |
| \-l  | 只列出符合匹配的文件名，不列出具体的匹配行                 |
| \-n  | 列出所有的匹配行，显示行号                                 |
| \-h  | 查询多文件时不显示文件名                                   |
| \-s  | 不显示不存在、没有匹配文本的错误信息                       |
| \-v  | 显示不包含匹配文本的所有行                                 |
| \-w  | 匹配整词                                                   |
| \-x  | 匹配整行                                                   |
| \-r  | 递归搜索                                                   |
| \-q  | 禁止输出任何结果，已退出状态表示搜索是否成功               |
| \-b  | 打印匹配行距文件头部的偏移量，以字节为单位                 |
| \-o  | 与-b结合使用，打印匹配的词据文件头部的偏移量，以字节为单位 |
| \-F  | 匹配固定字符串的内容                                       |
| \-E  | 支持扩展的正则表达式                                       |

📃参考实例

```shell
# 搜索某个文件中，包含某个关键词的内容
grep root /etc/passwd

# 搜索某个文件中，以某个关键词开头的内容
grep ^root /etc/passwd

# 搜索多个文件中，包含某个关键词的内容
grep linuxprobe /etc/passwd /etc/shadow

# 搜索多个文件中，包含某个关键词的内容，不显示文件名称
grep -h linuxprobe /etc/passwd /etc/shadow

# 输出在某个文件中，包含某个关键词行的数量
grep -c root /etc/passwd /etc/shadow

# 搜索某个文件中，包含某个关键词位置的行号及内容
grep -n network anaconda-ks.cfg 

# 搜索某个文件中，不包含某个关键词的内容
grep -v nologin /etc/passwd

# 搜索当前工作目录中，包含某个关键词内容的文件，未找到则提示
grep -l root *

# 搜索当前工作目录中，包含某个关键词内容的文件，未找到不提示
grep -sl root *

# 递归搜索，不仅搜索指定目录，还搜索其内子目录内是否有关键词文件
grep -srl root /etc

# 搜索某个文件中，精准匹配到某个关键词的内容（搜索词应与整行内容完全一样才会显示，有别于一般搜索）
grep -x cd anaconda-ks.cfg 
grep -x cdrom anaconda-ks.cfg 

# 判断某个文件中，是否包含某个关键词，通过返回状态值输出结果（0为包含，1为不包含），方便在Shell脚本中判断和调用
grep -q linuxprobe anaconda-ks.cfg 
echo $?

grep -q linuxcool anaconda-ks.cfg 
echo $?

# 搜索某个文件中，空行的数量
grep -c ^$ anaconda-ks.cfg 
```

### 解压缩常用命令

#### 📚gzip命令

📔 压缩和解压文件。

🔖gzip命令来自于英文单词gunzip的缩写。gzip是一款使用广泛的压缩工具，文件经过压缩后一般会以.gz后缀结尾，与tar命令合用后即为.tar.gz后缀。

🔖gzip命令对文本文件的压缩比率通常能达到60%~70%，压缩后可以很好的提升存储空间的使用率，还能够在网络传输文件时减少等待时间。

| 参数                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| \-a                 | 使用ASCII文字模式                                            |
| \-d                 | 解开压缩文件                                                 |
| \-f                 | 强行压缩文件                                                 |
| \-k                 | 保留原文件                                                   |
| \-l                 | 列出压缩文件的相关信息                                       |
| \-L                 | 显示版本与版权信息                                           |
| \-c                 | 把压缩后的文件输出到标准输出设备，不去更动原始文件           |
| \-r                 | 递归处理，将指定目录下的所有文件及子目录一并处理             |
| \-q                 | 不显示警告信息                                               |
| \-n                 | 压缩文件时，不保存原来的文件名称及时间戳记                   |
| \-N                 | 压缩文件时，保存原来的文件名称及时间戳记                     |
| \-t                 | 测试压缩文件是否正确无误                                     |
| \-S<压缩字尾字符串> | 更改压缩字尾字符串。                                         |
| \-v                 | 显示指令执行过程                                             |
| \-V                 | 显示版本信息                                                 |
| \-<压缩效率>        | 压缩效率是一个介于1－9的数值，预设值为"6"，指定愈大的数值，压缩效率就会愈高 |
| –best               | 此参数的效果和指定"-9"参数相同                               |
| –fast               | 此参数的效果和指定"-1"参数相同                               |

📃参考实例

```shell
# 将指定的文件进行压缩，压缩包默认会以“原文件名.gz”保存到当前工作目录下，原文件会被自动删除
gzip anaconda-ks.cfg

# 解压指定的压缩包文件，并显示解压过程。解压后的文件会保存在当前工作目录下，压缩包会被自动删除
gzip -dv anaconda-ks.cfg.gz 

# 将指定的文件进行压缩，但是不删除原文件
[root@linuxcool ~]# gzip -k initial-setup-ks.cfg

# 显示指定文件的压缩信息
gzip -l initial-setup-ks.cfg.gz 
```

#### 📚gunzip命令

📔解压提取文件内容。

🔖gunzip命令来自于英文词组”Gnu unzip“的缩写。gunzip通常被用来解压那些被基于gzip格式压缩过的文件，也就是那些.gz结尾的压缩包。

| 参数                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| \-a                 | 使用ASCII文字模式                                            |
| \-c                 | 把解压后的文件输出到标准输出设备                             |
| \-f                 | 强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接 |
| \-h                 | 在线帮助                                                     |
| \-l                 | 列出压缩文件的相关信息                                       |
| \-L                 | 显示版本与版权信息                                           |
| \-n                 | 解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理 |
| \-N                 | 解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上 |
| \-q                 | 不显示警告信息                                               |
| \-r                 | 递归处理，将指定目录下的所有文件及子目录一并处理             |
| \-S<压缩字尾字符串> | 更改压缩字尾字符串                                           |
| \-t                 | 测试压缩文件是否正确无误                                     |
| \-v                 | 显示指令执行过程                                             |
| \-V                 | 显示版本信息                                                 |

📃参考实例

```shell
# 解压指定的压缩包文件
gunzip Filename.gz

# 解压指定的压缩包文件，并输出解压过程
gunzip -v Filename.gz

# 测试指定的压缩包文件内容是否损坏，能够正常解压
gunzip -t Filename.gz
```

#### 📚zip命令

📔压缩文件。

🔖通过zip命令可以将文件打包成.zip格式的压缩包，里面会附含文件的名称、路径、创建时间、上次修改时间等等信息，与tar命令相似。

| 参数            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| \-A             | 调整可执行的自动解压缩文件                                   |
| \-b<工作目录>   | 指定暂时存放文件的目录                                       |
| \-c             | 替每个被压缩的文件加上注释                                   |
| \-d             | 从压缩文件内删除指定的文件                                   |
| \-D             | 压缩文件内不建立目录名称                                     |
| \-f             | 更新现有的文件                                               |
| \-F             | 尝试修复已损坏的压缩文件                                     |
| \-g             | 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件 |
| \-i<范本样式>   | 只压缩符合条件的文件                                         |
| \-j             | 只保存文件名称及其内容，而不存放任何目录名称                 |
| \-J             | 删除压缩文件前面不必要的数据                                 |
| \-L             | 显示版权信息                                                 |
| \-m             | 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中 |
| \-n<字尾字符串> | 不压缩具有特定字尾字符串的文件                               |
| \-o             | 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同 |
| \-q             | 不显示指令执行过程                                           |
| \-r             | 递归处理，将指定目录下的所有文件和子目录一并处理             |
| \-S             | 包含系统和隐藏文件                                           |
| \-t<日期时间>   | 把压缩文件的日期设成指定的日期                               |
| \-T             | 检查备份文件内的每个文件是否正确无误                         |
| \-u             | 与 -f 参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。 |
| \-v             | 显示指令执行过程或显示版本信息                               |
| \-w             | 在文件名称里假如版本编号，本参数仅在VMS操作系统下有效        |
| \-x<范本样式>   | 压缩时排除符合条件的文件                                     |
| \-X             | 不保存额外的文件属性                                         |
| \-y             | 直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效 |
| \-z             | 替压缩文件加上注释                                           |
| \-$             | 保存第一个被压缩文件所在磁盘的卷册名称                       |
| \-<压缩效率>    | 压缩效率是一个介于1-9的数值                                  |

📃参考实例

```shell
# 将指定目录及其内全部文件都打包成zip格式压缩包文件
zip -r backup1.zip /etc

# 将当前工作目录内所有以.cfg为后缀的文件打包
zip -r backup2.zip *.cfg

# 更新压缩包文件中某个文件
zip -dv backup2.zip anaconda-ks.cfg 

# 将/home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip
zip -q -r html.zip /home/html

# 如果在我们在 /home/html 目录下，可以执行以下命令
zip -q -r html.zip *

# 从压缩文件 cp.zip 中删除文件 a.c
zip -dv cp.zip a.c
```

#### 📚unzip命令

📔解压缩zip格式文件。

🔖unzip命令用于解压缩zip格式文件，虽然Linux系统中更多的使用tar命令进行对压缩包的管理工作，但有时也会收到同Windows系统常用的.zip和.rar格式的压缩包文件。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| \-c  | 将解压缩的结果显示到屏幕上，并对字符做适当的转换             |
| \-f  | 更新现有的文件                                               |
| \-l  | 显示压缩文件内所包含的文件                                   |
| \-p  | 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换 |
| \-t  | 检查压缩文件是否正确                                         |
| \-v  | 执行时显示详细的信息                                         |
| \-z  | 仅显示压缩文件的备注文字                                     |
| \-a  | 对文本文件进行必要的字符转换                                 |
| \-b  | 不要对文本文件进行字符转换                                   |
| \-C  | 压缩文件中的文件名称区分大小写                               |
| \-j  | 不处理压缩文件中原有的目录路径                               |
| \-L  | 将压缩文件中的全部文件名改为小写                             |
| \-n  | 解压缩时不要覆盖原有的文件                                   |
| \-o  | 不必先询问用户，unzip执行后覆盖原有文件                      |
| \-q  | 执行时不显示任何信息                                         |

📃参考实例

```shell
# 将压缩包文件解压到当前工作目录中
unzip latest.zip

# 将压缩包文件解压到指定的目录中
unzip latest.zip -d /home

# 测试压缩包文件是否完整，文件有无损坏
unzip -t latest.zip
```

#### 📚tar命令

📔压缩和解压缩文件。

🔖tar命令能够制作出Linux系统中常见的.tar、.tar.gz、.tar.bz2等格式的压缩包文件。对于RHEL7、CentOS7版本以后的系统，解压时可以不加压缩格式参数（如z或j），系统能自动进行分析并解压。

| 参数                  | 说明                                                 |
| --------------------- | ---------------------------------------------------- |
| \-A                   | 新增文件到以存在的备份文件                           |
| \-B                   | 设置区块大小                                         |
| \-c                   | 建立新的备份文件                                     |
| \-C                   | <目录> 仅压缩指定目录里的内容或解压缩到指定目录      |
| \-d                   | 记录文件的差别                                       |
| \-x                   | 从归档文件中提取文件                                 |
| \-t                   | 列出备份文件的内容                                   |
| \-z                   | 通过gzip指令压缩/解压缩文件，文件名最好为\*.tar.gz   |
| \-Z                   | 通过compress指令处理备份文件                         |
| \-f<备份文件>         | 指定备份文件                                         |
| \-v                   | 显示指令执行过程                                     |
| \-r                   | 添加文件到已经压缩的文件                             |
| \-u                   | 添加改变了和现有的文件到已经存在的压缩文件           |
| \-j                   | 通过bzip2指令压缩/解压缩文件，文件名最好为\*.tar.bz2 |
| \-v                   | 显示操作过程                                         |
| \-l                   | 文件系统边界设置                                     |
| \-k                   | 保留原有文件不覆盖                                   |
| \-m                   | 保留文件不被覆盖                                     |
| \-w                   | 确认压缩文件的正确性                                 |
| \-p                   | 保留原来的文件权限与属性                             |
| \-P                   | 使用文件名的绝对路径，不移除文件名称前的“/”号        |
| \-N <日期格式>        | 只将较指定日期更新的文件保存到备份文件里             |
| – -exclude=<范本样式> | 排除符合范本样式的文件                               |
| – -remove-files       | 归档/压缩之后删除源文件                              |

📃参考实例

```shell
# 使用gzip压缩格式对某个目录进行打包操作，显示压缩过程，压缩包规范后缀为.tar.gz
tar czvf backup1.tar.gz /etc

# 使用bzip2压缩格式对某个目录进行打包操作，显示压缩过程，压缩包规范后缀为.tar.bz2
tar cjvf backup2.tar.bz2 /etc

# 将当前工作目录内所有以.cfg为后缀的文件打包，不进行压缩
tar cvf backup3.tar *.cfg

# 将当前工作目录内的所有以.cfg为后缀的文件打包，不进行压缩，并删除原始文件
tar cvf backup4.tar *.cfg --remove-files

# 解压某个压缩包到当前工作目录
tar xvf backup4.tar 

# 解压某个压缩包到/etc目录
tar xvf backup4.tar -C /etc

# 查看某个压缩包内文件信息（无需解压）
tar tvf backup4.tar 
```

### 磁盘和分区常用命令

#### 📚tree命令

📔以树状图形式列出目录内容。

| 参数          | 说明                               |
| ------------- | ---------------------------------- |
| \-a           | 显示所有文件和目录                 |
| \-C           | 彩色显示                           |
| \-d           | 仅显示目录名称                     |
| \-D           | 显示文件更改时间                   |
| \-f           | 显示完整的相对路径名称             |
| \-g           | 显示文件所属群组名称               |
| \-i           | 不以阶梯状列出文件或目录名称       |
| \-l           | 直接显示连接文件所指向的原始目录   |
| \-n           | 不在文件和目录清单上加上色彩       |
| \-N           | 直接列出文件和目录名称             |
| \-p           | 列出权限标示                       |
| \-P<范本样式> | 只显示符合范本像是的文件或目录名称 |
| \-s           | 列出文件或目录大小                 |
| \-t           | 用文件和目录的更改时间排序         |
| \-u           | 列出文件或目录的拥有者名称         |
| \-x           | 将范围局限在现行的文件系统中       |
| \-L           | 层级显示                           |

📃参考实例

```shell
显示当前工作目录下的文件层级情况
tree

以文件和目录的更改时间进行排序
tree -t

以带有相对路径的形式，显示当前工作目录下的文件层级情况
 tree -f

只显示目录的层级关系情况
tree -d
```

#### 📚du命令

📔查看文件或目录的大小。

🔖du命令来自于英文词组“Disk Usage”的缩写。不要将df和du命令混淆，df是用于查看磁盘或分区使用情况的命令，而du命令则是用于按照指定容量单位来查看文件或目录在磁盘中的占用情况。

| 参数                   | 说明                           |
| ---------------------- | ------------------------------ |
| \-a                    | 显示目录中所有文件大小         |
| \-k                    | 以KB为单位显示文件大小         |
| \-m                    | 以MB为单位显示文件大小         |
| \-g                    | 以GB为单位显示文件大小         |
| \-h                    | 以易读方式显示文件大小         |
| \-s                    | 仅显示总计                     |
| \-exclude=<目录或文件> | 略过指定的目录或文件           |
| –max-depth=<目录层数>  | 超过指定层数的目录后，予以忽略 |

📃参考实例

```shell
# 以易读的容量格式显示指定目录内各个文件的大小信息
du -h /etc

# 以易读的容量格式显示指定目录内总文件的大小信息
du -sh /etc 

# 显示指定文件的大小信息（默认单位为K）
du anaconda-ks.cfg 
```

#### 📚df命令

📔显示系统上磁盘空间的使用量情况。

🔖df命令来自于英文词组”Disk Free“的缩写。df命令显示的磁盘使用量情况含可用、已有及使用率等信息，默认单位为Kb，建议使用-h参数进行单位换算。

| 参数               | 说明                                 |
| ------------------ | ------------------------------------ |
| \-a                | 显示所有系统文件                     |
| \-B <块大小>       | 指定显示时的块大小                   |
| \-h                | 以容易阅读的方式显示                 |
| \-H                | 以1000字节为换算单位来显示           |
| \-i                | 显示索引字节信息                     |
| \-k                | 指定块大小为1KB                      |
| \-l                | 只显示本地文件系统                   |
| \-t <文件系统类型> | 只显示指定类型的文件系统             |
| \-T                | 输出时显示文件系统类型               |
| – -sync            | 在取得磁盘使用信息前，先执行sync命令 |

📃参考实例

```shell
# 带有容量单位的显示系统全部磁盘使用量情况
df -h

# 带有容量单位的显示指定磁盘分区使用量情况
df -h /boot

# 显示系统中所有文件系统格式为xfs的磁盘分区使用量情况
df -t xfs
```

#### 📚free命令

📔显示系统内存使用量情况，包含物理和交换内存的总量、使用量和空闲量情况。

| 参数 | 说明                         |
| ---- | ---------------------------- |
| b    | 以Byte显示内存使用情况       |
| \-k  | 以kb为单位显示内存使用情况   |
| \-m  | 以mb为单位显示内存使用情况   |
| \-g  | 以gb为单位显示内存使用情况   |
| \-s  | 持续显示内存                 |
| \-t  | 显示内存使用总合             |
| \-h  | 以易读的单位显示内存使用情况 |

📃参考实例

```shell
# 以默认的容量单位显示内存使用量信息
free

# 以MB位单位显示内存使用量信息
free -m

# 以易读的单位显示内存使用量信息
free -h

# 以易读的单位显示内存使用量信息，每个10秒刷新一次
free -hs 10
```

#### 📚lsblk

📔查看系统的磁盘使用情况。来自于英文词组”list block“的缩写。

| 参数 | 说明                     |
| ---- | ------------------------ |
| \-a  | 显示所有设备             |
| \-b  | 以字节单位显示设备大小   |
| \-d  | 不显示 slaves 或 holders |
| \-e  | 排除设备                 |
| \-f  | 显示文件系统信息         |
| \-h  | 显示帮助信息             |
| \-i  | 仅使用字符               |
| \-m  | 显示权限信息             |
| \-l  | 使用列表格式显示         |
| \-n  | 不显示标题               |
| \-o  | 输出列                   |
| \-P  | 使用key=”value”格式显示  |
| \-r  | 使用原始格式显示         |
| \-t  | 显示拓扑结构信息         |

📃参考实例

```shell
# 显示系统中所有磁盘设备的使用情况信息
lsblk -a

# 显示系统中磁盘设备的归属及权限信息
lsblk -m

# 显示系统中所有SCSI类型的磁盘设备信息
lsblk -S

# 以列表格式显示磁盘设备信息，并且不显示标题
sblk -nl
```

#### 📚mount命令

📔把文件系统挂载到目录。

🔖文件系统指的是被格式化过的硬盘或分区设备，进行挂载操作后，用户便可以在挂载目录中使用硬盘资源。默认情况下Linux系统并不会像Windows系统那样自动的挂载光盘和U盘设备，需要自行完成。

| 参数 | 说明                                     |
| ---- | ---------------------------------------- |
| \-t  | 指定挂载类型                             |
| \-l  | 显示已加载的文件系统列表                 |
| \-h  | 显示帮助信息并退出                       |
| \-V  | 显示程序版本                             |
| \-n  | 加载没有写入文件“/etc/mtab”中的文件系统  |
| \-r  | 将文件系统加载为只读模式                 |
| \-a  | 加载文件“/etc/fstab”中描述的所有文件系统 |

📃参考实例

```shell
# 查看当前系统中已有的文件系统信息（可结合管道符与grep命令进行过滤）
mount 

# 挂载/etc/fstab文件中所有已定义的设备文件
mount -a

# 将光盘设备挂载到指定目录
mount /dev/cdrom /media/cdrom

# 强制以xfs文件系统挂载硬盘设备到指定目录
mount -t xfs /dev/sdb /disk
```

#### 📚umount命令

📔把文件系统挂载到目录。

🔖umount命令来自于英文单词unmount的缩写。umount卸载命令只需要提供设备名或挂载目录之一即可。

| 参数 | 说明                                |
| ---- | ----------------------------------- |
| \-a  | 卸载/etc/mtab中记录的所有文件系统   |
| \-h  | 显示帮助                            |
| \-n  | 卸载时不要将信息存入/etc/mtab文件中 |
| \-r  | 尝试以只读的方式重新挂入文件系统    |
| \-t  | 仅卸载选项中所指定的文件系统        |
| \-v  | 执行时显示详细的信息                |
| \-V  | 显示版本信息                        |

📃参考实例

```shell
# 卸载指定的文件系统
umount /dev/sdb

# 卸载指定的文件系统并显示过程
umount -v /dev/cdrom
```

#### 📚fdisk命令

📔管理磁盘的分区信息。

🔖fdisk命令来自于英文词组“Partition table manipulator for Linux”的缩写，其功能是用于管理磁盘的分区信息。fdisk命令可以用于对磁盘进行分区操作，根据实际情况进行合理划分。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| \-b  | 指定每个分区的大小                                           |
| \-l  | 列出指定的外围设备的分区表状况                               |
| \-s  | 将指定的分区大小输出到标准输出上，单位为区块                 |
| \-u  | 搭配”-l”参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址 |
| \-v  | 显示版本信息                                                 |

📃参考实例

```shell
# 查看当前系统的分区情况
fdisk -l

# 管理指定硬盘的分区
fdisk /dev/sda
```

#### 📚cfdisk命令

📔磁盘分区。

🔖cfdisk是用来磁盘分区的程序，它十分类似DOS的fdisk，具有互动式操作界面而非传统fdisk的问答式界面，您可以轻易地利用方向键来操控分区操作。cfdisk指令是一个基于鼠标的、用于硬盘分区的程序。输入指令cfdisk之后，将出现上面的图形界面，它是基于鼠标进行操作的，利用它可以进行磁盘的分区操作。

| 参数 | 说明                                           |
| ---- | ---------------------------------------------- |
| \-a  | 在程序里不用反白代表选取，而以箭头表示         |
| \-c  | 忽略BIOS的数值，直接指定磁盘的柱面数目         |
| \-P  | 显示分区表的内容                               |
| \-s  | 忽略BIOS的数值，直接指定磁盘的磁区数目         |
| \-v  | 显示版本信息                                   |
| \-z  | 不读取现有的分区，直接当作没有分区的新磁盘使用 |

📃参考实例

```shell
# 进行磁盘分区
cfsik 

# 进行磁盘分区，使用箭头进行操作，而不使用反白表示
cfsik -a
```

#### 📚mkfs命令

📔对设备进行格式化文件系统操作。

🔖mkfs命令来自于英文词组“make file system”的缩写。在挂载使用硬盘空间前的最后一步，运维人员需要对整块硬盘或指定分区进行格式化文件系统操作，Linux系统支持的文件系统包含ext2、ext3、ext4、xfs、fat、msdos、vfat、minix等多种格式。

| 参数 | 说明                 |
| ---- | -------------------- |
| \-V  | 详细显示模式         |
| \-t  | 给定档案系统的型式   |
| \-c  | 检查该设备是否有损坏 |

📃参考实例

```shell
# 对指定的硬盘进行格式化文件系统操作
mkfs -t ext4 /dev/sdb
 
# 对指定的硬盘进行格式化文件系统操作，并输出详细过程信息
mkfs -V -t xfs /dev/sdb
```

### 进程管理常用命令

#### 📚ps命令

📔显示进程状态。

🔖ps命令来自于英文词组”process status“的缩写。使用ps命令可以查看到进程的所有信息，例如进程的号码、发起者、系统资源使用占比（处理器与内存）、运行状态等等。帮助我们及时的发现哪些进程出现”僵死“或”不可中断“等异常情况。经常会与kill命令搭配使用来中断和删除不必要的服务进程，避免服务器的资源浪费。

| 参数               | 说明                                             |
| ------------------ | ------------------------------------------------ |
| a                  | 显示现行终端机下的所有程序，包括其他用户的程序   |
| \-A                | 显示所有程序                                     |
| c                  | 显示每个程序真正的指令名称，而不包含路径         |
| \-d                | 显示所有程序，但不包括阶段作业管理员的程序       |
| e                  | 列出程序时，显示每个程序所使用的环境变量         |
| \-f                | 显示UID,PPIP,C与STIME栏位                        |
| g                  | 显示现行终端机下的所有程序，包括所属组的程序     |
| h                  | 不显示标题列                                     |
| \-H                | 显示树状结构，表示程序间的相互关系               |
| \-l                | 采用详细的格式来显示程序状况                     |
| \-N                | 显示所有的程序，除了执行ps指令终端机下的程序之外 |
| r                  | 只列出现行终端机正在执行中的程序                 |
| \-T                | 显示现行终端机下的所有程序                       |
| u                  | 以用户为主的格式来显示程序状况                   |
| v                  | 采用虚拟内存的格式显示程序状况                   |
| \-w或w             | 采用宽阔的格式来显示程序状况                     |
| x                  | 显示所有程序，不以终端机来区分                   |
| –cols <每列字符数> | 设置每列的最大字符数                             |
| –lines <显示列数>  | 设置显示画面的列数                               |

**ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义:**

- \-A 列出所有的进程
  
- \-w 显示加宽可以显示较多的资讯
  
- \-au 显示较详细的资讯
  
- aux 显示所有包含其他使用者的进程
  

**au(x) 输出格式 :**`USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND`

- USER: 行程拥有者
- PID: 进程的ID号
- %CPU: 占用的 CPU 的百分比
- %MEM: 占用理内存的百分比
- VSZ: 占用的虚拟内存大小，单位KB
- RSS: 占用理内存的大小，单位KB
- TTY: 改进程是在哪个终端中运行的。对于CentOS来说，tty1是图像化界面，tty2-tty6是本地的字符界面终端。pst/0-255代表虚拟终端
- STAT: 该行程的状态:
    - R: 运行状态
    - D: 无法中断的休眠状态 (通常 IO 的进程)
    - R: 正在执行中
    - S: 静止状态(睡眠状态)
    - s: 包含子进程
    - l: 多线程
    - +: 前台显示
    - T: 暂停执行
    - Z: 不存在但暂时无法消除，僵尸状态
    - W: 没有足够的记忆体分页可分配
    - <: 高优先序的行程
    - N: 低优先序的行程
    - L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)
- START: 进程开始时间
- TIME: 执行的时间
- COMMAND:所执行的指令

📃参考实例

```shell
# 显示系统中全部的进程信息，含详细信息
ps aux 

# 结合输出重定向，将当前进程信息保留备份至指定文件
ps aux > backup.txt

# 结合管道操作符，将当前系统运行状态中指定进程信息过滤出来
ps -ef | grep ssh

# 结合管道操作符，将当前系统运行状态中指定用户的进程信息过滤出来
ps -u root

# 结合管道操作符与sort命令，依据处理器使用量（第三列）情况降序排序
ps aux | sort -rnk 3

# 结合管道操作符与sort命令，依据内存使用量（第四列）情况降序排序
ps aux | sort -rnk 4

# 显示所有进程信息，连同命令行
ps -ef

# 显示指定用户信息
ps -u root 

# 显示 php 的进程
ps -ef | grep php

# 显示进程信息
ps -A 
```

#### 📚kill命令

📔杀死进程。

🔖Linux系统中如需结束某个进程，既可以使用如service或systemctl的管理命令来结束服务，也可以使用kill命令直接结束进程信息。如使用kill命令后进程并没有被结束，则可以使用信号9进行强制杀死动作。

| 参数 | 说明                           |
| ---- | ------------------------------ |
| \-l  | 列出系统支持的信号             |
| \-s  | 指定向进程发送的信号           |
| \-a  | 不限制命令名和进程号的对应关系 |
| \-p  | 不发送任何信号                 |

**最常用的信号是：**

- 1 (HUP)：重新加载进程。
- 9 (KILL)：杀死一个进程。
- 15 (TERM)：正常停止一个进程。

📃参考实例

```shell
# 列出系统支持的全部信号列表
kill -l

# 结束某个指定的进程（数字为对应的PID值）
kill 1518

# 强制结束某个指定的进程（数字为对应的PID值）
kill -9 1518
```

#### 📚pstree命令

📔以树状图显示进程。

🔖Linux系统中pstree命令的英文全称是“process tree”，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。

| 参数 | 说明                                                     |
| ---- | -------------------------------------------------------- |
| \-a  | 显示每个程序的完整指令，包含路径，参数或是常驻服务的标示 |
| \-c  | 不使用精简标示法                                         |
| \-G  | 使用VT100终端机的列绘图字符                              |
| \-h  | 列出树状图时，特别标明现在执行的程序                     |

📃参考实例

```shell
# 特别表明在运行的进程
pstree -apnh # 显示进程间的关系

# 同时显示用户名称
pstree -u # 显示用户名称

# 显示当前所有进程的进程号和进程id
pstree -p

# 显示所有进程的所有详细信息，遇到相同的进程名可以压缩显示
pstree  -a
```

#### 📚top命令

📔 实时显示系统运行状态。

🔖top命令的功能是用于实时显示系统运行状态，包含处理器、内存、服务、进程等重要资源信息。

| 参数     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| q        | 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行 |
| c        | 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称 |
| S        | 累积模式，会将己完成或消失的子进程 ( dead child process ) 的 CPU time 累积起来 |
| s        | 安全模式，将交谈式指令取消, 避免潜在的危机                   |
| b        | 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内 |
| \-d <秒> | 改变显示的更新速度                                           |
| \-s      | 安全模式，不允许交互式指令                                   |
| \-i      | 不显示任何闲置或僵死的行程                                   |
| \-n      | 设定显示的总次数，完成后将会自动退出                         |

📃参考实例

```shell
# 以默认格式显示系统运行信息
top

# 以默认格式显示系统运行信息，但提供完整的进程路径及名称
top -c  
  
# 以批处理模式显示程序信息
top -b

# 设定每隔5秒刷新一次信息
top -d 5

# 设定总显示次数为3回，随后自动退出命令
top -n 3
```

#### 📚netstat命令

📔 显示网络状态。

🔖netstat命令来自于英文词组”network statistics“的缩写，其功能是用于显示各种网络相关信息，例如网络连接状态、路由表信息、接口状态、NAT、多播成员等等。

| 参数 | 说明                                     |
| ---- | ---------------------------------------- |
| \-a  | 显示所有连线中的Socket                   |
| \-p  | 显示正在使用Socket的程序识别码和程序名称 |
| \-l  | 仅列出在监听的服务状态                   |
| \-t  | 显示TCP传输协议的连线状况                |
| \-u  | 显示UDP传输协议的连线状况                |
| \-i  | 显示网络界面信息表单                     |
| \-r  | 显示路由表信息                           |
| \-n  | 直接使用IP地址，不通过域名服务器         |

📃参考实例

```shell
# 显示系统网络状态中的所有连接信息
netstat -a

# 显示系统网络状态中的UDP连接信息
netstat -nu

# 显示系统网络状态中的UDP连接端口号使用信息
netstat -apu 

# 显示网卡当前状态信息
netstat -i 

# 显示网络路由表状态信息
netstat -r

# 找到某个服务所对应的连接信息
netstat -ap | grep ssh
```

### 定时常用命令

#### 📚crontab命令

📔管理定时计划任务。

🔖crontab命令来自于英文词组“cron table”的缩写。定时计划任务，就计划好的任务，到了时间就会自动执行，在Linux系统中的crond是一个定时计划任务服务，用户只要能够按照正确的格式（分、时、日、月、星期、命令）写入到配置文件中，那么就会按照预定的周期时间自动的执行下去，而crontab命令则是用于配置的工具名称。

| 参数 | 说明         |
| ---- | ------------ |
| \-e  | 编辑任务     |
| \-l  | 列出任务     |
| \-r  | 删除任务     |
| \-u  | 指定用户名字 |

**时间格式：** `f1 f2 f3 f4 f5 program`

- 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。
  
- 当 f1 为 \* 时表示每分钟都要执行 program，f2 为 \* 时表示每小时都要执行程序，其余类推。
  
- 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其余类推。
  
- 当 f1 为 \*/n 时表示每 n 分钟个时间间隔执行一次，f2 为 \*/n 表示每 n 小时个时间间隔执行一次，其余类推。
  
- 当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其余类推。
  

📃参考实例

```shell
每一分钟执行一次 /bin/ls
* * * * * /bin/ls

在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 /usr/bin/backup
0 6-12/3 * 12 * /usr/bin/backup

周一到周五每天下午 5:00 寄一封信给 alex@domain.name：
0 17 * * 1-5 mail -s "hi" alex@domain.name \< /tmp/maildata

每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分....执行 echo "haha"
20 0-23/2 * * * echo "haha"

0 */2 * * * /sbin/service httpd restart  意思是每两个小时重启一次apache 

50 7 * * * /sbin/service sshd start  意思是每天7：50开启ssh服务 

50 22 * * * /sbin/service sshd stop  意思是每天22：50关闭ssh服务 

0 0 1,15 * * fsck /home  每月1号和15号检查/home 磁盘 

1 * * * * /home/bruce/backup  每小时的第一分执行 /home/bruce/backup这个文件 

00 03 * * 1-5 find /home "*.xxx" -mtime +4 -exec rm {} \;  每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。

30 6 */10 * * ls  意思是每月的1、11、21、31日是的6：30执行一次ls命令

# 管理当前用户的计划任务
crontab -e  

# 管理指定用户的计划任务
crontab -e -u user1

# 查看当前用户的已有计划任务列表
crontab -l 
```

### 软件包管理

#### 📚rpm命令

📔RPM软件包管理器。

🔖rpm命令来自于英文词组”RedHat Package Manager“的缩写，中文译为红帽软件包管理器，其功能是用于在Linux系统下对软件包进行安装、卸载、查询、验证、升级等工作。

| 参数 | 说明                                   |
| ---- | -------------------------------------- |
| \-a  | 查询所有的软件包                       |
| \-e  | 卸载软件包                             |
| \-f  | 查询文件或命令属于哪个软件包           |
| \-i  | 安装软件包                             |
| \-l  | 显示软件包的文件列表                   |
| \-p  | 查询指定的rpm软件包                    |
| \-q  | 查询软件包                             |
| \-h  | 安装软件包时列出标记                   |
| \-R  | 显示软件包的依赖关系                   |
| \-s  | 显示文件状态，本参数需配合”-l”参数使用 |
| \-U  | 升级软件包                             |
| \-v  | 显示命令执行过程                       |
| \-vv | 详细显示指令执行过程                   |

📃参考实例

```shell
# 正常安装软件包
rpm -ivh cockpit-185-2.el8.x86_64.rpm 

# 显示系统已安装过的全部RPM软件包
rpm -qa

# 查询某个软件的安装路径
rpm -ql cockpit

# 卸载某个通过RPM软件包安装的服务
rpm -evh cockpit

# 升级某个软件包
rpm -Uvh cockpit-185-2.el8.x86_64.rpm 
```

#### 📚yum命令

📔基于RPM的软件包管理器。

🔖yum命令来自于英文词组”YellowdogUpdater,Modified“的缩写，其功能是用于在Linux系统中基于RPM技术进行软件包的管理工作。yum技术通用于RHEL、CentOS、Fedora、OpenSUSE等主流系统，可以让系统管理人员交互式的自动化更新和管理软件包，实现从指定服务器自动下载、更新、删除软件包的工作。

🔖yum软件仓库及命令能够自动处理软件依赖关系，一次性安装所需全部软件，无需繁琐的操作。

| 参数         | 说明                                           |
| ------------ | ---------------------------------------------- |
| \-h          | 显示帮助信息                                   |
| \-y          | 对所有的提问都回答“yes”                        |
| \-c          | 指定配置文件                                   |
| \-q          | 安静模式                                       |
| \-v          | 详细模式                                       |
| \-t          | 检查外部错误                                   |
| \-d          | 设置调试等级（0-10）                           |
| \-e          | 设置错误等级（0-10）                           |
| \-R          | 设置yum处理一个命令的最大等待时间              |
| \-C          | 完全从缓存中运行，而不去下载或者更新任何头文件 |
| install      | 安装rpm软件包                                  |
| update       | 更新rpm软件包                                  |
| check-update | 检查是否有可用的更新rpm软件包                  |
| remove       | 删除指定的rpm软件包                            |
| list         | 显示软件包的信息                               |
| search       | 检查软件包的信息                               |
| info         | 显示指定的rpm软件包的描述信息和概要信息        |
| clean        | 清理yum过期的缓存                              |
| shell        | 进入yum的shell提示符                           |
| resolvedep   | 显示rpm软件包的依赖关系                        |
| localinstall | 安装本地的rpm软件包                            |
| localupdate  | 显示本地rpm软件包进行更新                      |
| deplist      | 显示rpm软件包的所有依赖关系                    |

📃参考实例

```shell
# 清理原有的软件仓库信息缓存
yum clean all

# 建立最新的软件仓库信息缓存
yum makecache

# 安装指定的服务及相关软件包
yum install httpd

# 更新指定的服务及相关软件包
yum update httpd

# 卸载指定的服务及相关软件包
yum remove httpd

# 显示可安装的软件包组列表
yum grouplist 

# 显示指定服务的软件信息
yum info httpd
```

## 🌐 SHELL编程

### 概述

🖋 Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。

🖊 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。

🖌 Shell 脚本（shell script），是一种为 shell 编写的脚本程序。

🖍 Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。

**📃 Linux 的 Shell 种类众多，常见的有：**

Bourne Shell（/usr/bin/sh或/bin/sh）  
Bourne Again Shell（/bin/bash）  
C Shell（/usr/bin/csh）  
K Shell（/usr/bin/ksh）  
Shell for Root（/sbin/sh）  
……

**📃 sh/bash/csh/Tcsh/ksh/pdksh等shell的区别：**

  **sh(全称 Bourne Shell)：** 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。
  
  **Bourne Shell：** 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。
  
  **bash(全称 Bourne Again Shell)：** LinuxOS 默认的，它是 Bourne Shell 的扩展。 与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。
  
  **csh(全称 C Shell)：** 是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。
  
  **Tcsh：** 是 Linux 提供的 C Shell 的一个扩展版本。Tcsh 包括命令行编辑，可编程单词补全，拼写校正，历史命令替换，作业控制和类似 C 语言的语法，他不仅和 Bash Shell 提示符兼容，而且还提供比 Bash Shell 更多的提示符参数。
  
  **ksh(全称 Korn Shell)：** 集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell 完全兼容。
  
  **pdksh：** 是 Linux 系统提供的 ksh 的扩展。pdksh 支持人物控制，可以在命令行上挂起，后台执行，唤醒或终止程序。

**📃 Linux 提供的 Shell 解析器有**

```shell
[root@Demo ~]$ cat /etc/shells
/bin/sh
/bin/bash
/usr/bin/sh
/usr/bin/bash
/bin/tcsh
/bin/csh
```

**📃 bash 和 sh 的关系**

```shell
[root@Demo bin]$ ll | grep bash
-rwxr-xr-x. 1 root root 941880 5 月 11 2016 bash
lrwxrwxrwx. 1 root root 4 5 月 27 2017 sh -> bash
```

**📃 Centos 默认的解析器是 bash**

```shell
[root@Demo bin]$ echo $SHELL
/bin/bash
```

### 编写shell脚本

脚本以 `#!/bin/bash` 开头（指定解析器）

`#!` 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。

打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 helloworld.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行。

```shell
[root@Demo shells]$ touch helloworld.sh
[root@Demo shells]$ vim helloworld.sh

// 在 helloworld.sh 中输入如下内容

#!/bin/bash
echo "helloworld"
```

`#!` 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。

`echo` 命令用于向窗口输出文本。

### 脚本的常用执行方式

**📝 采用 bash 或 sh+脚本的相对路径或绝对路径（不用赋予脚本+x 权限）**

📃 sh+脚本的相对路径

```shell
[root@Demo shells]$ sh ./helloworld.sh
Helloworld
```

📃 sh+脚本的绝对路径

```shell
[root@Demo shells]$ sh /home/shells/helloworld.sh
helloworld
```

📃 bash+脚本的相对路径

```shell
[root@Demo shells]$ bash ./helloworld.sh
Helloworld
```

📃 bash+脚本的绝对路径

```shell
[root@Demo shells]$ bash /home/shells/helloworld.sh
Helloworld
```

🖇 这种执行方法，本质是 bash 解析器帮你执行脚本，所以脚本本身不需要执权限。

**📝 采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）**

📃 首先要赋予 helloworld.sh 脚本的+x 权限

```shell
[root@Demo shells]$ chmod +x helloworld.sh
```

📃 相对路径

```shell
[root@Demo shells]$ ./helloworld.sh
Helloworld
```

📃 绝对路径

```shell
[root@Demo shells]$ /home/shells/helloworld.sh
Helloworld
```

🖇 这种执行方法，本质是脚本需要自己执行，所以需要执行权限。

**📝 在脚本的路径前加上 “.” 或者 source**

📃 编写以下脚本

```shell
[root@Demo shells]$ cat test.sh
#!/bin/bash
A=5
echo $A
```

📃 分别用 sh，bash，./ 和 . 的方式来执行

```shell
[root@Demo shells]$ bash test.sh
5
[root@Demo shells]$ sh test.sh
5
[root@Demo shells]$ ./test.sh
5
[root@Demo shells]$ . test.sh
5
```

🔗 前两种方式都是在当前 shell 中打开一个子 shell 来执行脚本内容，当脚本内容结束，则子 shell 关闭，回到父 shell 中。

🔗 第三种，也就是使用在脚本路径前加“.”或者 source 的方式，可以使脚本内容在当前shell 里执行，而无需打开子 shell！这也是为什么我们每次要修改完/etc/profile 文件以后，需要 source 一下的原因。

🔗 开子 shell 与不开子 shell 的区别就在于，环境变量的继承关系，如在子 shell 中设置的当前变量，父 shell 是不可见的。

### 变量

**常用系统变量**

`$HOME`、`$PWD`、`$SHELL`、`$USER` 等

📃 查看系统变量的值

```shell
[root@Demo shells]$ echo $HOME
```

📃 显示当前 Shell 中所有变量

```shell
[root@Demo shells]$ set
```

📍 定义变量时，变量名不加美元符号

📍 变量名和等号之间不能有空格

📍 **变量名的命名须遵循规则：**

  命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
    
  中间不能有空格，可以使用下划线 \_。
    
  不能使用标点符号。
    
  不能使用bash里的关键字（可用help命令查看保留关键字）。

📍 使用一个定义过的变量，只要在变量名前面加美元符号即可。

📍 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界 (推荐给所有变量加上花括号)。

📍 已定义的变量，可以被重新定义。

📍 **变量类型：运行shell时，会同时存在三种变量：**

  **局部变量：** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
    
  **环境变量：** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
    
  **shell变量：** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。

📍 只读变量：使用 `readonly` 命令可以将变量定义为只读变量，只读变量的值不能被改变。

📍 删除变量：使用 `unset` 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。

📃 参考实例

```shell
# 定义变量 A
[root@Demo shells]$ A=5
[root@Demo shells]$ echo $A
5

# 给变量 A 重新赋值
[root@Demo shells]$ A=8
[root@Demo shells]$ echo $A
8

# 撤销变量 A
[root@Demo shells]$ unset A
[root@Demo shells]$ echo $A

# 声明静态的变量 B=2，不能 unset
[root@Demo shells]$ readonly B=2
[root@Demo shells]$ echo $B
2
[root@Demo shells]$ B=9
-bash: B: readonly variable 

# 在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算
[root@Demo shells]$ C=1+2
[root@Demo shells]$ echo $C
1+2

# 变量的值如果有空格，需要使用双引号或单引号括起来
[root@Demo shells]$ D=I love you
-bash: world: command not found
[root@Demo shells]$ D="I love you"
[root@Demo shells]$ echo $D
I love you

# 可把变量提升为全局环境变量，可供其他 Shell 程序使用
# 在 helloworld.sh 文件中增加 echo $B
[root@Demo shells]$ vim helloworld.sh

#!/bin/bash
echo "helloworld"
echo $B

[root@Demo shells]$ ./helloworld.sh
Helloworld
# 发现并没有打印输出变量 B 的值
# 使用 export 变量名
[root@Demo shells]$ export B
[root@Demo shells]$ ./helloworld.sh
helloworld
2
```

### Shell 注释

以 # 开头的行就是注释，会被解释器忽略，通过每一行加一个 # 号设置多行注释。

```shell
# 这是一个注释

##### 开始 #####
#
#
# 这里可以添加描述信息
#
#
##### 结束  #####
```

多行注释还可以使用以下格式

```shell
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
```

EOF 也可以使用其他符号

```shell
:<<
注释内容...
注释内容...
注释内容...
'

:<<!
注释内容...
注释内容...
注释内容...
!
```

### shell字符串

字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。

**单引号：**

  单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
    
  单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

**双引号**

  双引号里可以有变量。
    
  双引号里可以出现转义字符。

📃 拼接字符串

```shell
your_name="runoob"

# 使用双引号拼接,输出结果为：hello, runoob ! hello, runoob !
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1

# 使用单引号拼接,输出结果为：hello, runoob ! hello, ${your_name} !
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
```

📃 获取字符串长度

```shell
string="abcd"
echo ${#string}   # 输出 4

# 变量为数组时，${#string} 等价于 ${#string[0]}:

string="abcd"
echo ${#string[0]}   # 输出 4

# 计算字符长度也可是使用 length。
string="hello,everyone my name is mingming"  # string字符串里边有空格,所以需要添加双引号
expr length "$string"   # 输出:34

# 使用 expr 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身
expr 5+6     # 直接输出 5+6
expr 5 + 6   # 输出 11

# 对于某些运算符，还需要我们使用符号"\"进行转义，否则就会提示语法错误
expr 5 * 6       # 输出错误
expr 5 \* 6      # 输出30
```

📃 提取子字符串

```shell
# 以下实例从字符串第 2 个字符开始截取 4 个字符
string="runoob is a great site"
echo ${string:1:4}   # 输出 unoo
```

📃 查找子字符串

```shell
查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)
string="runoob is a great site"
echo `expr index "$string" io`  # 输出 4
```

📃 字符串截取

0️⃣ 定义字符串

```shell
var=http://www.aaa.com/123.htm
```

1️⃣ `#` 号截取，删除左边字符，保留右边字符

```shell
echo ${var#*//} # 结果是 ：www.aaa.com/123.htm
```

   📎 `#` 其中 var 是变量名，# 号是运算符，\*// 表示从左边开始删除第一个 // 号及左边的所有字符，即删除 http://

2️⃣## 号截取，删除左边字符，保留右边字符

```shell
echo ${var##*/} # 结果是 123.htm
```

   📎 `##*/` 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符，即删除 http://www.aaa.com/

3️⃣ %号截取，删除右边字符，保留左边字符

```shell
echo ${var%/*} # 结果是：http://www.aaa.com
```

   📎 `%/*` 表示从右边开始，删除第一个 / 号及右边的字符

4️⃣ %% 号截取，删除右边字符，保留左边字符

```shell
echo ${var%%/*} # 结果是：http:
```

   📎 `%%/*` 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符

5️⃣ 从左边第几个字符开始，及字符的个数

```shell
echo ${var:0:5} # 结果是：http:
```

   📎 其中的 0 表示左边第一个字符开始，5 表示字符的总个数。

6️⃣ 从左边第几个字符开始，一直到结束。

```shell
echo ${var:7} # 结果是 ：www.aaa.com/123.htm
```

   📎 其中的 7 表示左边第8个字符开始，一直到结束。

7️⃣ 从右边第几个字符开始，及字符的个数

```shell
echo ${var:0-7:3} # 结果是：123
```

   📎 其中的 0-7 表示右边算起第七个字符开始，3 表示字符的个数。

8️⃣ 从右边第几个字符开始，一直到结束。

```shell
echo ${var:0-7} # 结果是：123.htm
```

   📎 表示从右边第七个字符开始，一直到结束。

📍 左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示。

**\# ## % %%**:

  `#`、`##` 表示从左边开始删除。一个 `#` 表示从左边删除到第一个指定的字符；两个 `#` 表示从左边删除到最后一个指定的字符。
    
  `%`、`%%` 表示从右边开始删除。一个 `%` 表示从右边删除到第一个指定的字符；两个 `%` 表示从右边删除到最后一个指定的字符。
    
  删除包括了指定的字符本身。

📃 read 命令用于获取键盘输入信息

🔦 它的语法形式一般是：`read [-options] [variable...]`

```shell
# -p 参数由于设置提示信息
read -p "input a val:" a    #获取键盘输入的 a 变量数字
read -p "input b val:" b    #获取键盘输入的 b 变量数字
r=$[a+b]                    #计算a+b的结果 赋值给r  不能有空格
echo "result = ${r}"        #输出显示结果 r
```

### 传递参数

向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，其中 $0 为执行的文件名（包含文件路径），1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……

📃 参考实例

```shell
echo "Shell 传递参数实例！";
echo "执行的文件名：$0";
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";

$ chmod +x test.sh 
$ ./test.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3
```

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| $#   | 传递到脚本的参数个数                                         |
| $\*  | 以一个单字符串显示所有向脚本传递的参数。如"$\*“用「”」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。 |
| $$   | 脚本运行的当前进程ID号                                       |
| $!   | 后台运行的最后一个进程的ID号                                 |
| $@   | 与 ∗ 相同，但是使用时加引号，并在引号中返回每个参数。如 " \*相同，但是使用时加引号，并在引号中返回每个参数。如" ∗相同，但是使用时加引号，并在引号中返回每个参数。如"@“用「”」括起来的情况、以"$1" “ 2 " … " 2" … " 2"…"n” 的形式输出所有参数。 |
| $-   | 显示Shell使用的当前选项，与set命令功能相同。                 |
| $?   | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

📃 参考实例

```shell
echo "Shell 传递参数实例！";
echo "第一个参数为：$1";
echo "参数个数为：$#";
echo "传递的参数作为一个字符串显示：$*";

$ chmod +x test.sh 
$ ./test.sh 1 2 3
Shell 传递参数实例！
第一个参数为：1
参数个数为：3
传递的参数作为一个字符串显示：1 2 3
```

**$\*与 $@**

  都是引用所有参数。
    
  只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " \* " 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。

```shell
echo "-- \$* 演示 ---"
for i in "$*"; do
    echo $i
done

echo "-- \$@ 演示 ---"
for i in "$@"; do
    echo $i
done

$ chmod +x test.sh 
$ ./test.sh 1 2 3
-- $* 演示 ---
1 2 3
-- $@ 演示 ---
1
2
3
```

### Shell 数组

bash支持一维数组（不支持多维数组），并且没有限定数组的大小。

数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。

在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。定义数组的一般形式为： `数组名=(值1 值2 ... 值n)`

📃 例如：

```shell
array_name=(value0 value1 value2 value3)

# 或者
array_name=(
value0
value1
value2
value3
)

# 还可以单独定义数组的各个分量。可以不使用连续的下标，而且下标的范围没有限制。
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
```

读取数组

读取数组元素值的一般格式是：`${数组名[下标]}`

📃 例如：

```shell
valuen=${array_name[n]}

# 使用 @ 符号可以获取数组中的所有元素
echo ${array_name[@]}
```

获取数组的长度  
📃 例如：

```shell
# 获取数组长度的方法与获取字符串长度的方法相同
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
```

**关联数组**

Bash 支持关联数组，可以使用任意的字符串、或者整数作为下标来访问数组元素。关联数组使用 declare 命令来声明。

🔦 **语法格式：**`declare -A array_name`

- \-A 选项就是用于声明一个关联数组。
  
- 关联数组的键是唯一的。
  

📃 创建一个关联数组 site，并创建不同的键值

```shell
declare -A site=(["A"]="1" ["B"]="2" ["C"]="3")
```

📃 也可以先声明一个关联数组，然后再设置键和值

```shell
declare -A site
site["A"]="1"
site["B"]="2"
site["C"]="3"
```

📃 访问关联数组元素可以使用指定的键

```shell
declare -A site
site["A"]="1"
site["B"]="2"
site["C"]="3"

echo ${site["B"]}  # 执行脚本，输出结果：2
```

📃 在数组前加一个感叹号`!`可以获取数组的所有键

```shell
declare -A site
site["A"]="1"
site["B"]="2"
site["C"]="3"

echo "数组的键为: ${!site[*]}" # A B C
echo "数组的键为: ${!site[@]}" # A B C
```

📃 数组的值也可以写入变量

```shell
A=1
my_array=($A B C D)
echo "第一个元素为: ${my_array[0]}"  # 1
echo "第二个元素为: ${my_array[1]}"  # b
echo "第三个元素为: ${my_array[2]}"  # c
echo "第四个元素为: ${my_array[3]}"  # d
```

📃 字符串转数组

```shell
words="aaa bbb ccc"

#字符串转数组，空格是分隔符
array=(${words// / })  
#打印数组最后一个成员
echo ${array[${#array[*]}-1]}  # ccc
#打印数组长度
echo ${#array[*]}  # 3

#字符串不转换为数组，在循环实现以空格为分隔符打印每个成员
for word in ${words}; do
    echo ${word}       # aaabbbccc
done
```

📃 字符串替换

```shell
# 使用 string/pattern/string 进行首个 pattern 的替换
string="text, dummy, text, dummy"
echo ${string/text/TEXT}   # TEXT, dummy, text, dummy

# 使用 string//pattern/string 进行全部 pattern 的替换
string="text, dummy, text, dummy"
echo ${string//text/TEXT}  # TEXT, dummy, TEXT, dummy
```

### 运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。

`expr` 是一款表达式计算工具，使用它能完成表达式的求值操作。

```shell
val=`expr 2 + 2`
echo "两数之和为 : $val"   # 两数之和为 : 4
```

表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2。

**算术运算符**

假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                        | 举例                       |
| ------ | ------------------------------------------- | -------------------------- |
| +      | 加法                                        | `expr $a + $b` 结果为 30   |
| \-     | 减法                                        | `expr $a - $b` 结果为 -10  |
| \*     | 乘法                                        | `expr $a \* $b` 结果为 200 |
| /      | 除法                                        | `expr $b / $a` 结果为 2    |
| %      | 取余                                        | `expr $b % $a` 结果为 0    |
| \=     | 赋值                                        | a=$b 把变量 b 的值赋给 a   |
| \==    | 相等。用于比较两个数字，相同则返回 true     | \[ $a == $b \] 返回 false  |
| !=     | 不相等。用于比较两个数字，不相同则返回 true | \[ $a != $b \] 返回 true   |

🔗 条件表达式要放在方括号之间，并且要有空格。\[ a = = a== a\==b\] 是错误的，必须写成 \[ $a == $b \]。

**关系运算符**

假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                | 举例                       |
| ------ | --------------------------------------------------- | -------------------------- |
| \-eq   | 检测两个数是否相等，相等返回 true                   | \[ $a -eq $b \] 返回 false |
| \-ne   | 检测两个数是否不相等，不相等返回 true               | \[ $a -ne $b \] 返回 true  |
| \-gt   | 检测左边的数是否大于右边的，如果是，则返回 true     | \[ $a -gt $b \] 返回 false |
| \-lt   | 检测左边的数是否小于右边的，如果是，则返回 true     | \[ $a -lt $b \] 返回 true  |
| \-ge   | 检测左边的数是否大于等于右边的，如果是，则返回 true | \[ $a -ge $b \] 返回 false |
| \-le   | 检测左边的数是否小于等于右边的，如果是，则返回 true | \[ $a -le $b \] 返回 true  |

**布尔运算符**

假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                              | 举例                                     |
| ------ | ------------------------------------------------- | ---------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true | \[ ! false \] 返回 true                  |
| \-o    | 或运算，有一个表达式为 true 则返回 true           | \[ $a -lt 20 -o $b -gt 100 \] 返回 true  |
| \-a    | 与运算，两个表达式都为 true 才返回 true           | \[ $a -lt 20 -a $b -gt 100 \] 返回 false |

**逻辑运算符**

假定变量 a 为 10，变量 b 为 20:

| 运算符 | 说明       | 举例                                          |
| ------ | ---------- | --------------------------------------------- |
| &&     | 逻辑的 AND | \[\[ $a -lt 100 && $b -gt 100 \]\] 返回 false |
|        |            |                                               |

**字符串运算符**

假定变量 a 为 “abc”，变量 b 为 “efg”：

| 运算符 | 说明                                       | 举例                     |
| ------ | ------------------------------------------ | ------------------------ |
| \=     | 检测两个字符串是否相等，相等返回 true      | \[ $a = $b \] 返回 false |
| !=     | 检测两个字符串是否不相等，不相等返回 true  | \[ $a != $b \] 返回 true |
| \-z    | 检测字符串长度是否为0，为0返回 true        | \[ -z $a \] 返回 false   |
| \-n    | 检测字符串长度是否不为 0，不为 0 返回 true | \[ -n “$a” \] 返回 true  |
| $      | 检测字符串是否不为空，不为空返回 true      | \[ $a \] 返回 true       |

**文件测试运算符**

| 运算符   | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| \-b file | 检测文件是否是块设备文件，如果是，则返回 true                |
| \-c file | 检测文件是否是字符设备文件，如果是，则返回 true              |
| \-d file | 检测文件是否是目录，如果是，则返回 true                      |
| \-f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true |
| \-g file | 检测文件是否设置了 SGID 位，如果是，则返回 true              |
| \-k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true    |
| \-p file | 检测文件是否是有名管道，如果是，则返回 true                  |
| \-u file | 检测文件是否设置了 SUID 位，如果是，则返回 true              |
| \-r file | 检测文件是否可读，如果是，则返回 true                        |
| \-w file | 检测文件是否可写，如果是，则返回 true                        |
| \-x file | 检测文件是否可执行，如果是，则返回 true                      |
| \-s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true       |
| \-e file | 检测文件（包括目录）是否存在，如果是，则返回 true            |

其他检查符：

- \-S: 判断某文件是否 socket
  
- \-L: 检测文件是否存在并且是一个符号链接
  

### echo命令

用于字符串的输出。命令格式：`echo string`

📃 显示普通字符串

```shell
echo "It is a test"
# 这里的双引号完全可以省略，以下命令与上面实例效果一致
echo It is a test
```

📃 显示转义字符

```shell
echo "\"It is a test\""   # 结果将是:"It is a test"  同样，双引号也可以省略
```

📃 显示变量  
read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量

```shell
#!/bin/sh
read name 
echo "$name It is a test"
# 以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:
[root@www ~]# sh test.sh
OK                     #标准输入
OK It is a test        #输出
```

📃 显示换行

```shell
echo -e "OK! \n" # -e 开启转义
echo "It is a test"

# 输出结果：
OK!

It is a test
```

📃 显示不换行

```shell
#!/bin/sh
echo -e "OK! \c" # -e 开启转义 \c 不换行
echo "It is a test"
# 输出结果：OK! It is a test
```

📃 显示结果定向至文件

```shell
echo "It is a test" > myfile
```

📃 原样输出字符串，不进行转义或取变量(用单引号)

```shell
echo '$name\"'
# 输出结果： $name\"
```

📃 显示命令执行结果

```shell
echo `date`  # 结果将显示当前日期
```

**echo输出的字符串**

| 能否引用变量 | 能否引用转移符 | 能否引用文本格式符(如：换行符、制表符) |
| ------------ | -------------- | -------------------------------------- |
| 单引号       | 否             | 否                                     |
| 双引号       | 能             | 能                                     |
| 无引号       | 能             | 能                                     |

### read 命令

ead 命令一个一个词组地接收输入的参数，每个词组需要使用空格进行分隔；如果输入的词组个数大于需要的参数个数，则多出的词组将被作为整体为最后一个参数接收。

测试文件 test.sh 代码如下：

```shell
read firstStr secondStr
echo "第一个参数:$firstStr; 第二个参数:$secondStr"

# 执行测试：
$ sh test.sh 
一 二 三 四
第一个参数:一; 第二个参数:二 三 四
```

```shell
read -p "请输入一段文字:" -n 6 -t 5 -s password
echo -e "\npassword is $password"
```

**参数说明：**

- \-p 输入提示文字
- \-n 输入字符长度限制(达到6位，自动结束)
- \-t 输入限时
- \-s 隐藏输入内容

```shell
$ sh test.sh 
请输入一段文字:
password is abcdef
```

### printf 命令

printf 命令模仿 C 程序库（library）里的 printf() 程序。

printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。

printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认的 printf 不会像 echo 自动添加换行符，可以手动添加 \\n。

🔦 **printf 命令的语法：** `printf format-string [arguments...]`

**参数说明：**

- format-string: 为格式控制字符串
- arguments: 为参数列表。

```shell
$ echo "Hello, Shell"
Hello, Shell

$ printf "Hello, Shell\n"
Hello, Shell
```

```shell
printf "%-10s %-8s %-4s\n" 
printf "%-10s %-8s %-4.2f\n"
printf "%-10s %-8s %-4.2f\n"
printf "%-10s %-8s %-4.2f\n"
```

`%s %c %d %f` 都是格式替代符，`％s` 输出一个字符串，`％d` 整型输出，`％c` 输出一个字符，`％f` 输出实数，以小数形式输出。

`%-10s` 指一个宽度为 10 个字符（- 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。

`%-4.2f` 指格式化为小数，其中 .2 指保留2位小数。

**printf 的转义**

| 序列   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| \\a    | 警告字符，通常为ASCII的BEL字符                               |
| \\b    | 后退                                                         |
| \\c    | 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 |
| \\f    | 换页（formfeed）                                             |
| \\n    | 换行                                                         |
| \\r    | 回车（Carriage return）                                      |
| \\t    | 水平制表符                                                   |
| \\v    | 垂直制表符                                                   |
| \\     | 一个字面上的反斜杠字符                                       |
| \\ddd  | 表示1到3位数八进制值的字符。仅在格式字符串中有效             |
| \\0ddd | 表示1到3位的八进制值字符                                     |

### test 命令

Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。

**数值**

| 参数 | 说明           |
| ---- | -------------- |
| \-eq | 等于则为真     |
| \-ne | 不等于则为真   |
| \-gt | 大于则为真     |
| \-ge | 大于等于则为真 |
| \-lt | 小于则为真     |
| \-le | 小于等于则为真 |

**字符串**

| 参数       | 说明                     |
| ---------- | ------------------------ |
| \=         | 等于则为真               |
| !=         | 不相等则为真             |
| \-z 字符串 | 字符串的长度为零则为真   |
| \-n字符串  | 字符串的长度不为零则为真 |

**文件**

| 参数       | 说明                                 |
| ---------- | ------------------------------------ |
| \-e 文件名 | 如果文件存在则为真                   |
| \-r 文件名 | 如果文件存在且可读则为真             |
| \-w 文件名 | 如果文件存在且可写则为真             |
| \-x 文件名 | 如果文件存在且可执行则为真           |
| \-s 文件名 | 如果文件存在且至少有一个字符则为真   |
| \-d 文件名 | 如果文件存在且为目录则为真           |
| \-f 文件名 | 如果文件存在且为普通文件则为真       |
| \-c 文件名 | 如果文件存在且为字符型特殊文件则为真 |
| \-b 文件名 | 如果文件存在且为块特殊文件则为真     |

### IF判断

**if 语法格式：**

```shell
if condition
then
    command1 
    command2
    ...
    commandN 
fi
```

写成一行（适用于终端命令提示符）：

```shell
if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi
```

**if else 语法格式**

```shell
if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi
```

**if else-if else 语法格式**

```shell
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
```

📍 if else 的 \[…\] 判断语句中大于使用 -gt，小于使用 -lt。

📍 如果使用 ((…)) 作为判断语句，大于和小于可以直接使用 `>` 和 `<`。

📃 参考实例

```shell
a=10
b=20
if [ $a == $b ]
then
   echo "a 等于 b"
elif [ $a -gt $b ]
then
   echo "a 大于 b"
elif [ $a -lt $b ]
then
   echo "a 小于 b"
else
   echo "没有符合的条件"
fi

# 或者 

a=10
b=20
if (( $a == $b ))
then
   echo "a 等于 b"
elif (( $a > $b ))
then
   echo "a 大于 b"
elif (( $a < $b ))
then
   echo "a 小于 b"
else
   echo "没有符合的条件"
fi
```

```shell
# 与 test 命令结合使用
num1=$[2*3]
num2=$[1+5]
if test $[num1] -eq $[num2]
then
    echo '两个数字相等!'
else
    echo '两个数字不相等!'
fi
```

### for 循环

**for循环格式**

```shell
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
```

**或者**

```shell
for 变量 in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
```

📃 参考实例

```shell
for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done
# 输出结果：
The value is: 1
The value is: 2
The value is: 3
The value is: 4
The value is: 5


for str in This is a string
do
    echo $str
done
# 输出结果：
This
is
a
string
```

### while 语句

**语法格式**

```shell
while condition
do
    command
done
```

📃 参考实例

```shell
while(( $int<=5 ))
do
    echo $int
    let "int++"
done

# 输出结果
1
2
3
4
5
```

### until 循环

until 循环执行一系列命令直至条件为 true 时停止。

until 循环与 while 循环在处理方式上刚好相反。

一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。

**until 语法格式**

```shell
until condition  #condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。
do
    command
done
```

📃 参考实例

```shell
a=0

until [ ! $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done

# 输出结果为：
0
1
2
3
4
5
6
7
8
9
```

### case 语句

case … esac 为多选择语句，与其他语言中的 switch … case 语句类似，是一种多分支选择结构，每个 case 分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。

**语法格式**

```shell
case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2)
    command1
    command2
    ...
    commandN
    ;;
esac
```

case 取值后面必须为单词 in，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;; 。

取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 \* 捕获该值，再执行后面的命令。

📃 参考实例

```shell
echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac
```

### break 和 continue

break 命令允许跳出所有循环（终止执行后面的所有循环）。

continue 命令与 break 命令类似，它不会跳出所有循环，仅仅跳出当前循环。

📃 参考实例

```shell
#!/bin/bash
while :
do
    echo -n "输入 1 到 5 之间的数字:"
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的!"
            break
        ;;
    esac
done
```

```shell
#!/bin/bash
while :
do
    echo -n "输入 1 到 5 之间的数字: "
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的!"
            continue
            echo "结束"
        ;;
    esac
done
```

### 函数

#### basename

**基本语法：** `basename [string / pathname] [suffix]`

basename 命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。

basename 可以理解为取路径里的文件名称.

suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉。

📃 参考实例

```shell
# 截取该/home/user1/banzhang.txt 路径的文件名称
[root@Demo shells]$ basename /home/user1/banzhang.txt
banzhang.txt
[root@Demo shells]$ basename /home/user1/banzhang.txt .txt
banzhang
```

#### dirname

dirname 文件绝对路径

从给定的包含绝对路径的文件名中去除文件名，然后返回剩下的路径。

dirname 可以理解为取文件路径的绝对路径名称。

📃 参考实例

```shell
# 获取 banzhang.txt 文件的路径
[atguigu@hadoop101 ~]$ dirname /home/user1/banzhang.txt
/home/user1
```

#### 自定义函数

**定义格式**

```shell
[ function ] funname [()]

{

    action;

    [return int;]

}
```

可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。

参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）。

```shell
demoFun(){
    echo "这是我的第一个 shell 函数!"
}
echo "-----函数开始执行-----"
demoFun
echo "-----函数执行完毕-----"

# 输出结果
-----函数开始执行-----
这是我的第一个 shell 函数!
-----函数执行完毕-----
```

```shell
funWithReturn(){
    echo "这个函数会对输入的两个数字进行相加运算..."
    echo "输入第一个数字: "
    read aNum
    echo "输入第二个数字: "
    read anotherNum
    echo "两个数字分别为 $aNum 和 $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
echo "输入的两个数字之和为 $? !"

# 输出类似下面：
这个函数会对输入的两个数字进行相加运算...
输入第一个数字: 
1
输入第二个数字: 
2
两个数字分别为 1 和 2 !
输入的两个数字之和为 3 !
```

在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…

📃 参考实例

```shell
funWithParam(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73

# 输出结果：
第一个参数为 1 !
第二个参数为 2 !
第十个参数为 10 !
第十个参数为 34 !
第十一个参数为 73 !
参数总数有 11 个!
作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !

# $10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。
```

| 参数处理 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| $#       | 传递到脚本或函数的参数个数                                   |
| $\*      | 以一个单字符串显示所有向脚本传递的参数                       |
| $$       | 脚本运行的当前进程ID号                                       |
| $!       | 后台运行的最后一个进程的ID号                                 |
| $@       | 与$\*相同，但是使用时加引号，并在引号中返回每个参数。        |
| $-       | 显示Shell使用的当前选项，与set命令功能相同。                 |
| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

### 输入/输出重定向

| 命令            | 说明                                               |
| --------------- | -------------------------------------------------- |
| command > file  | 将输出重定向到 file。                              |
| command < file  | 将输入重定向到 file。                              |
| command >> file | 将输出以追加的方式重定向到 file。                  |
| n > file        | 将文件描述符为 n 的文件重定向到 file。             |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |
| n >& m          | 将输出文件 m 和 n 合并。                           |
| n <& m          | 将输入文件 m 和 n 合并。                           |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |

> 文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。

**输出重定向**

**语法：**`command1 > file1`

上面这个命令执行command1然后将输出的内容存入file1。

任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用>>操作符。

📃 参考实例

```shell
$ echo "AAAAA" > users
$ cat users
AAAAA
$

# 如果不希望文件内容被覆盖，可以使用 >> 追加到文件末尾，例如：
$ echo "AAAAA" >> users
$ cat users
AAAAA
AAAAA
$
```

**输入重定向**

**语法：** `command1 < file1`

📃 参考实例

```shell
# 接着以上实例，我们需要统计 users 文件的行数,执行以下命令：
$ wc -l users
       2 users
       
#也可以将输入重定向到 users 文件：

$  wc -l < users
       2        
# 上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。


# 同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。
command1 < infile > outfile 
```

**一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：**

  标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。
    
  标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。
    
  标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。

默认情况下，command > file 将 stdout 重定向到 file，command `<`file 将stdin 重定向到 file。

如果希望 stderr 重定向到 file，可以这样写：

```shell
$ command 2>file
```

如果希望 stderr 追加到 file 文件末尾，可以这样写：

```shell
$ command 2>>file
```

表示标准错误文件(stderr)。如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：

```shell
$ command > file 2>&1
```

或者

```shell
$ command >> file 2>&1
```

如果希望对 stdin 和 stdout 都重定向，可以这样写：

```shell
$ command < file1 >file2
```

command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。

**Here Document**

Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。

它的基本的格式如下：

```shell
command << delimiter
    document
delimiter
```

它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。

> 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。  
> 开始的delimiter前后的空格会被忽略掉。

📃 参考实例

```shell
# 在命令行中通过 wc -l 命令计算 Here Document 的行数：
$ wc -l << EOF
    AAA
    BBB
    CCC
EOF
3          # 输出结果为 3 行
$
```

我们也可以将 Here Document 用在脚本中，例如：

```shell
#!/bin/bash
cat << EOF
    AAA
    BBB
    CCC
EOF
# 执行以上脚本，输出结果：
AAA
BBB
CCC
```

**/dev/null 文件**

如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null

```shell
$ command > /dev/null
```

`/dev/null` 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。

如果希望屏蔽 stdout 和 stderr，可以这样写：

```shell
$ command > /dev/null 2>&1
```

> 注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。  
> 这里的 2 和 > 之间不可以有空格，2> 是一体的时候才表示错误输出。

### 简单正则使用

正则表达式使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。在 Linux 中，grep，sed，awk 等文本处理工具都支持通过正则表达式进行模式匹配。

**常用的特殊字符**

`^` 匹配一行的开头

```shell
[root@Demo shells]$ cat /etc/passwd | grep ^a 
# 会匹配出所有以 a 开头的行
```

`$` 匹配一行的结束

```shell
[root@Demo shells]$ cat /etc/passwd | grep t$
# 会匹配出所有以 t 结尾的行
```

`.` 匹配一个任意的字符

```shell
[root@Demo shells]$ cat /etc/passwd | grep r..t
# 会匹配包含 rabt,rbbt,rxdt,root 等的所有行
```

`*` 不单独使用，他和上一个字符连用，表示匹配上一个字符 0 次或多次

```shell
[root@Demo shells]$ cat /etc/passwd | grep ro*t
# 会匹配 rt, rot, root, rooot, roooot 等所有行
```

**字符区间（中括号）：`[ ]`**

- \[ \] 表示匹配某个范围内的一个字符
- \[6,8\] ------ 匹配 6 或者 8
- \[0-9\] ------ 匹配一个 0-9 的数字
- \[0-9\]\* ------ 匹配任意长度的数字字符串
- \[a-z\] ------匹配一个 a-z 之间的字符
- \[a-z\]\* ------ 匹配任意长度的字母字符串
- \[a-c, e-f\] ----- 匹配 a-c 或者 e-f 之间的任意字符

`\` 表示转义，并不会单独使用。由于所有特殊字符都有其特定匹配模式，当我们想匹配某一特殊字符本身时（例如，我想找出所有包含 ‘$’ 的行），就会碰到困难。此时我们就要将转义字符和特殊字符连用，来表示特殊字符本身。

```shell
[root@Demo shells]$ cat /etc/passwd | grep ‘a\$b’ 
# 就会匹配所有包含 a$b 的行。注意需要使用单引号将表达式引起来
```

### 文本处理

#### cut 命令

cut 的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。

🌊 **语法：** `cut [参数] [file]`

cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。

如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| \-b  | 以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。 |
| \-c  | 以字符为单位进行分割。                                       |
| \-d  | 自定义分隔符，默认为制表符。                                 |
| \-f  | \-d一起使用，指定显示哪个区域。                              |
| \-n  | 取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除 |

📃 参考实例

```shell
# 当执行who命令时，会输出类似如下的内容：
$ who
rocrocket :0           2009-01-08 11:07
rocrocket pts/0        2009-01-08 11:23 (:0.0)
rocrocket pts/1        2009-01-08 14:15 (:0.0)

# 如果我们想提取每一行的第3个字节，如下：
$ who|cut -b 3
c
c
```

#### 文件包含

Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。

语法格式：

```shell
. filename   # 注意点号(.)和文件名中间有一空格
```

或

```shell
source filename
```

📃 参考实例

创建两个 shell 脚本文件。

1️⃣ test1.sh

```shell
#!/bin/bash
url="http://www.baidu.com"
```

2️⃣ test2.sh

```shell
#!/bin/bash
. ./test1.sh  #使用 . 号来引用test1.sh 文件，或者 source ./test1.sh
echo "百度地址：$url"
```

3️⃣ 为 test2.sh 添加可执行权限并执行

```shell
$ chmod +x test2.sh 
$ ./test2.sh 
```

**运行结果：** 百度地址：http://www.runoob.com

> 被包含的文件 test1.sh 不需要可执行权限。

#### sed 命令

sed 命令是利用脚本来处理文本文件。

sed 可依照脚本的指令来处理、编辑文本文件。

Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。

🌊 **语法：** `sed [-hnV][-e<script>][-f<script文件>][文本文件]`

| 参数            | 说明                                         |
| --------------- | -------------------------------------------- |
| \-e`<`script>     | 以选项中指定的script来处理输入的文本文件     |
| \-f`<`script文件> | 以选项中指定的script文件来处理输入的文本文件 |
| \-h             | 显示帮助                                     |
| \-n             | 仅显示script处理后的结果                     |
| \-V             | 显示版本信息                                 |

| 动作 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| a    | 新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行) |
| c    | 取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ |
| d    | 删除，因为是删除，所以 d 后面通常不接任何东西；              |
| i    | 插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行) |
| p    | 打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行 |
| s    | 取代，可以直接进行取代的工作！通常这个 s 的动作可以搭配正则表达式 |

📃 **参考实例**

0️⃣ **创建一个 testfile 文件**

```shell
$ cat testfile #查看testfile 中的内容  
HELLO LINUX!  
Linux is a free unix-type opterating system.  
This is a linux testfile!  
Linux test 
Google
Taobao
Runoob
Tesetfile
Wiki
```

**以行为单位的新增/删除**

1️⃣ 在 testfile 文件的第四行后添加一行，并将结果输出到标准输出

```shell
sed -e 4a\newLine testfile 
```

  使用 sed 命令后，输出结果如下

```shell
$ sed -e 4a\newLine testfile 
HELLO LINUX!  
Linux is a free unix-type opterating system.  
This is a linux testfile!  
Linux test 
newLine
Google
Taobao
Runoob
Tesetfile
Wiki
```

2️⃣ 将 testfile 的内容列出并且列印行号，同时，将第 2~5 行删除

```shell
$ nl testfile | sed '2,5d'
     1  HELLO LINUX!  
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

> sed 的动作为 2,5d， d 是删除的意思，因为删除了 2-5 行，所以显示的数据就没有 2-5 行，原本应该是要下达 sed -e 才对，但没有 -e 也是可以的，同时也要注意的是， sed 后面接的动作，请以 ‘…’ 两个单引号括住

3️⃣ 只要删除第 2 行

```shell
$ nl testfile | sed '2d' 
     1  HELLO LINUX!  
     3  This is a linux testfile!  
     4  Linux test 
     5  Google
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

4️⃣ 要删除第 3 到最后一行

```shell
$ nl testfile | sed '3,$d' 
     1  HELLO LINUX!  
     2  Linux is a free unix-type opterating system.  
```

5️⃣ 在第二行后(即加在第三行) 加上drink tea? 字样

```shell
$ nl testfile | sed '2a drink tea'
     1  HELLO LINUX!  
     2  Linux is a free unix-type opterating system.  
drink tea
     3  This is a linux testfile!  
     4  Linux test 
     5  Google
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

6️⃣ 如果是要在第二行前，命令如下

```shell
$ nl testfile | sed '2i drink tea' 
     1  HELLO LINUX!  
drink tea
     2  Linux is a free unix-type opterating system.  
     3  This is a linux testfile!  
     4  Linux test 
     5  Google
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

7️⃣如果是要增加两行以上，在第二行后面加入两行字，例如 Drink tea or … 与 drink beer?

```shell
$ nl testfile | sed '2a Drink tea or ......\
drink beer ?'

     1  HELLO LINUX!  
     2  Linux is a free unix-type opterating system.  
Drink tea or ......
drink beer ?
     3  This is a linux testfile!  
     4  Linux test 
     5  Google
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

> 每一行之间都必须要以反斜杠 \\ 来进行标记

**以行为单位的替换与显示**

1️⃣ 将第 2-5 行的内容取代成为 No 2-5 number

```shell
$ nl testfile | sed '2,5c No 2-5 number'
     1  HELLO LINUX!  
No 2-5 number
     6  Taobao
     7  Runoob
     8  Tesetfile
     9  Wiki
```

2️⃣仅列出 testfile 文件内的第 5-7 行

```shell
$ nl testfile | sed -n '5,7p'
     5  Google
     6  Taobao
     7  Runoob
```

**数据的搜寻并显示**

1️⃣ 搜索 testfile 有 oo 关键字的行

```shell
$ nl testfile | sed -n '/oo/p'
     5  Google
     7  Runoob
```

> 如果 root 找到，除了输出所有行，还会输出匹配行。

**数据的搜寻并删除**

1️⃣ 删除 testfile 所有包含 oo 的行，其他行输出

```shell
$ nl testfile | sed  '/oo/d'
     1  HELLO LINUX!  
     2  Linux is a free unix-type opterating system.  
     3  This is a linux testfile!  
     4  Linux test 
     6  Taobao
     8  Tesetfile
     9  Wiki
```

**数据的搜寻并执行命令**

1️⃣ 搜索 testfile，找到 oo 对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把 oo 替换为 kk，再输出这行

```shell
$ nl testfile | sed -n '/oo/{s/oo/kk/;p;q}'  # 最后的 q 是退出
     5  Gkkgle
```

**数据的查找与替换**

```shell
# sed 的查找与替换的与 vi 命令类似，语法格式如下
sed 's/要被取代的字串/新的字串/g'
```

1️⃣ 将 testfile 文件中每行第一次出现的 oo 用字符串 kk 替换

```shell
sed -e 's/oo/kk/' testfile
```

2️⃣ g 标识符表示全局查找替换，使 sed 对文件中所有符合的字符串都被替换，修改后内容会到标准输出，不会修改原文件

```shell
sed -e 's/oo/kk/g' testfile
```

3️⃣ 选项 i 使 sed 修改文件

```shell
sed -i 's/oo/kk/g' testfile
```

4️⃣ 批量操作当前目录下以 test 开头的文件

```shell
sed -i 's/oo/kk/g' ./test*
```

5️⃣ 使用 /sbin/ifconfig 查询 IP，将 IP 前，后的部分予以删除

```shell
$ /sbin/ifconfig eth0
eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84
inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
.....(以下省略).....

# 本机的 ip 是 192.168.1.100

# 将 IP 前面的部分予以删除
$ /sbin/ifconfig eth0 | grep 'inet addr' | sed 's/^.*addr://g'

# 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
# 接下来则是删除后续的部分，即：192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0

# 将 IP 后面的部分予以删除
$ /sbin/ifconfig eth0 | grep 'inet addr' | sed 's/^.*addr://g' | sed 's/Bcast.*$//g'
192.168.1.100
```

**多点编辑**

1️⃣ 一条 sed 命令，删除 testfile 第三行到末尾的数据，并把 HELLO 替换为 RUNOOB :

```shell
$ nl testfile | sed -e '3,$d' -e 's/HELLO/RUNOOB/'
     1  RUNOOB LINUX!  
     2  Linux is a free unix-type opterating system.  
```

> \-e 表示多点编辑，第一个编辑命令删除 testfile 第三行到末尾的数据，第二条命令搜索 HELLO 替换为 RUNOOB。

**直接修改文件内容**

1️⃣ regular\_express.txt 文件内容

```shell
$ cat regular_express.txt 
runoob.
google.
taobao.
facebook.
zhihu-
weibo-
```

2️⃣ 利用 sed 将 regular\_express.txt 内每一行结尾若为 . 则换成 !

```shell
$ sed -i 's/\.$/\!/g' regular_express.txt
$ cat regular_express.txt 
runoob!
google!
taobao!
facebook!
zhihu-
weibo-:q:q 
```

3️⃣利用 sed 直接在 regular\_express.txt 最后一行加入 # This is a test

```shell
$ sed -i '$a # This is a test' regular_express.txt
$ cat regular_express.txt 
runoob!
google!
taobao!
facebook!
zhihu-
weibo-
# This is a test
```

> $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增 # This is a test！

#### awk命令

AWK 是一种处理文本文件的语言，是一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。

AWK 是取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。

🌊 **语法：** `awk [选项参数] ‘/pattern1/{action1} /pattern2/{action2}...’ filename`

> pattern：表示 awk 在数据中查找的内容，就是匹配模式  
> action：在找到匹配内容时所执行的一系列命令

| 参数 | 说明                 |
| ---- | -------------------- |
| \-F  | 指定输入文件分隔符   |
| \-v  | 赋值一个用户定义变量 |

**基本使用**

0️⃣ log.txt文本内容

```shell
2 this is a test
3 Do you like awk
This's a test
10 There are orange,apple,mongo
```

1️⃣ **用法一：** `awk '{[pattern] action}' {filenames}` 行匹配语句 awk ‘’ 只能用单引号

每行按空格或TAB分割，输出文本中的1、4项

```shell
 $ awk '{print $1,$4}' log.txt
 2 a
 3 like
 This's
 10 orange,apple,mongo
```

格式化输出

```shell
 $ awk '{printf "%-8s %-10s\n",$1,$4}' log.txt
 2        a
 3        like
 This's
 10       orange,apple,mongo
```

2️⃣ **用法二：** `awk -F` -F相当于内置变量FS, 指定分割字符

使用","分割

```shell
 $  awk -F, '{print $1,$2}'   log.txt
 2 this is a test
 3 Do you like awk
 This's a test
 10 There are orange apple
```

使用内建变量分隔

```shell
 $ awk 'BEGIN{FS=","} {print $1,$2}'     log.txt
 2 this is a test
 3 Do you like awk
 This's a test
 10 There are orange apple
```

使用多个分隔符.先使用空格分割，然后对分割结果再使用","分割

```shell
 $ awk -F '[ ,]'  '{print $1,$2,$5}'   log.txt
 2 this test
 3 Do awk
 This's a
 10 There apple
```

1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣🔟

3️⃣ **用法三：** `awk -v` 设置变量

```shell
 $ awk -va=1 '{print $1,$1+a}' log.txt
 2 3
 3 4
 This's 1
 10 11
```

```shell
 $ awk -va=1 -vb=s '{print $1,$1+a,$1b}' log.txt
 2 3 2s
 3 4 3s
 This's 1 This'ss
 10 11 10s
```

4️⃣ **用法四：** `awk -f {awk脚本} {文件名}`

```shell
 $ awk -f cal.awk log.txt
```

**运算符**

| 运算符                      | 描述                             |
| --------------------------- | -------------------------------- |
| \= += -= \*= /= %= ^= \*\*= | 赋值                             |
| ?:                          | C条件表达式                      |
|                             |                                  |
| &&                          | 逻辑与                           |
| ~ 和 !~                     | 匹配正则表达式和不匹配正则表达式 |
| < <= > >= != ==             | 关系运算符                       |
| 空格                        | 连接                             |
| \+ -                        | 加，减                           |
| \* / %                      | 乘，除与求余                     |
| \+ - !                      | 一元加，减和逻辑非               |
| ^ \*\*\*                    | 求幂                             |
| ++ –                        | 增加或减少，作为前缀或后缀       |
| $                           | 字段引用                         |
| in                          | 数组成员                         |

📃 参考实例

过滤第一列大于2的行

```shell
$ awk '$1>2' log.txt

# 输出
3 Do you like awk
This's a test
10 There are orange,apple,mongo
```

过滤第一列等于2的行

```shell
$ awk '$1==2 {print $1,$3}' log.txt

# 输出
2 is
```

过滤第一列大于2并且第二列等于’Do’的行

```shell
$ awk '$1>2 && $2=="Do" {print $1,$2,$3}' log.txt 

# 输出
3 Do you
```

**内建变量**

| 变量        | 描述                                              |
| ----------- | ------------------------------------------------- |
| $n          | 当前记录的第n个字段，字段间由FS分隔               |
| $0          | 完整的输入记录                                    |
| ARGC        | 命令行参数的数目                                  |
| ARGIND      | 命令行中当前文件的位置(从0开始算)                 |
| ARGV        | 包含命令行参数的数组                              |
| CONVFMT     | 数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组 |
| ERRNO       | 最后一个系统错误的描述                            |
| FIELDWIDTHS | 字段宽度列表(用空格键分隔)                        |
| FILENAME    | 当前文件名                                        |
| FNR         | 各文件分别计数的行号                              |
| FS          | 字段分隔符(默认是任何空格)                        |
| IGNORECASE  | 如果为真，则进行忽略大小写的匹配                  |
| NF          | 一条记录的字段的数目                              |
| NR          | 已经读出的记录数，就是行号，从1开始               |
| OFMT        | 数字的输出格式(默认值是%.6g)                      |
| OFS         | 输出字段分隔符，默认值与输入字段分隔符一致。      |
| ORS         | 输出记录分隔符(默认值是一个换行符)                |
| RLENGTH     | 由match函数所匹配的字符串的长度                   |
| RS          | 记录分隔符(默认是一个换行符)                      |
| RSTART      | 由match函数所匹配的字符串的第一个位置             |
| SUBSEP      | 数组下标分隔符(默认值是/034)                      |

📃 参考实例

```shell
$ awk 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  log.txt
FILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS
---------------------------------------------
log.txt    2    1         5    1
log.txt    2    2         5    2
log.txt    2    3         3    3
log.txt    2    4         4    4
```

```shell
$ awk -F\' 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  log.txt
FILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS
---------------------------------------------
log.txt    2    1    '    1    1
log.txt    2    2    '    1    2
log.txt    2    3    '    2    3
log.txt    2    4    '    1    4
```

输出顺序号 NR, 匹配文本行号

```shell
$ awk '{print NR,FNR,$1,$2,$3}' log.txt
1 1 2 this is
2 2 3 Do you
3 3 This's a test
4 4 10 There are
```

指定输出分割符

```shell
$  awk '{print $1,$2,$5}' OFS=" $ "  log.txt
2 $ this $ test
3 $ Do $ awk
This's $ a $
10 $ There $
```

使用正则，字符串匹配，输出第二列包含 “th”，并打印第二列与第四列

```shell
$ awk '$2 ~ /th/ {print $2,$4}' log.txt     # ~ 表示模式开始。// 中是模式。
this a

# 输出包含 "re" 的行
$ awk '/re/ ' log.txt
10 There are orange,apple,mongo
```

忽略大小写

```shell
$ awk 'BEGIN{IGNORECASE=1} /this/' log.txt
2 this is a test
This's a test
```

模式取反

```shell
$ awk '$2 !~ /th/ {print $2,$4}' log.txt
Do like
a
There orange,apple,mongo

$ awk '!/th/ {print $2,$4}' log.txt
Do like
a
There orange,apple,mongo
```

**awk脚本**

BEGIN{ 这里面放的是执行前的语句 }

END {这里面放的是处理完所有的行后要执行的语句 }

📃 参考实例

有这么一个文件（成绩表）：

```shell
$ cat score.txt
Marry   2143 78 84 77
Jack    2321 66 78 45
Tom     2122 48 77 71
Mike    2537 87 97 95
Bob     2415 40 57 62
```

awk 脚本如下

```shell
$ cat cal.awk
#!/bin/awk -f
#运行前
BEGIN {
    math = 0
    english = 0
    computer = 0
 
    printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"
    printf "---------------------------------------------\n"}
#运行中
{
    math+=$3
    english+=$4
    computer+=$5
    printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5
}
#运行后
END {
    printf "---------------------------------------------\n"
    printf "  TOTAL:%10d %8d %8d \n", math, english, computer
    printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR 
  }
```

执行结果

```shell
$ awk -f cal.awk score.txt
NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL
---------------------------------------------
Marry  2143     78       84       77      239
Jack   2321     66       78       45      189
Tom    2122     48       77       71      196
Mike   2537     87       97       95      279
Bob    2415     40       57       62      159
---------------------------------------------
  TOTAL:       319      393      350
AVERAGE:     63.80    78.60    70.00

```