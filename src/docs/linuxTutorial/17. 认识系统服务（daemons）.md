# 认识系统服务（daemons）

在 Unix-Like 系统中，daemons 是什么？怎么管理它？怎么查询它？他们开启了多少个 ports？这些 ports 如何关闭？各种 port 代表什么服务？这些问题都是最基础需要注意的，尤其是在架设网站之前，这里的知识就显得更重要了

从 CentOS 7.x 开始，传统的 init 已经被舍弃，取而代之的是 systemd 这个程序，他们之间有什么差异？优缺点有哪些？如何管理不同种类的服务类型？以及如何取代原本的执行等级等等，这个是很重要的改变

## 什么是 daemon 与服务（service）

简单说，你启动一个程序，这个程序提供你一些功能，那么这个程序就是 daemon，程序运行后提供的功能就是 service

比如：crontab 提供的定时任务，crond 是 daemon，crond 启动后提供的功能就是 service

所以不需要去区分它们两个，基本上可以视作是说同一个东西，毕竟程序需启动后才能提供功能

关于 daemon 的命名方式，一般会再原程序后面添加字母 d ，使用 ps 和 top 观察时就会发现很多后缀为 d 的 daemon 程序

## 早期 System V 的 init 管理行为中 daemon 的主要分类（可选知识）

第 1 章中谈到过的 Unix 的 system v 版本，是个很纯种的 Unix 版本，在那个年代，启动系统服务的管理方式被称为 SysV 的 init 脚本程序的处理方式，也就是系统核心的第一个程序是 init，init 去唤醒所有的系统所需要的服务，无论是本地还是网络服务

基本上 init 的管理机制有几个特色：

- 服务的启动、关闭与观察等方式：

  所有的服务启动脚本通过放在 `/etc/init.d/` 下，基本上都是使用 bash shell script 所写成的脚本程序，管理方式如下：

  - 启动：`/etc/init.d/daemon start`
  - 关闭：`/etc/init.d/daemon stop`
  - 重新启动：`/etc/init.d/daemon restart`
  - 状态观察：`/etc/init.d/daemon status`

- 服务启动的分类

  init 服务的分类中，依据服务时独立启动或被一只总管程序管理而分为两大类：

  - 独立启动模式（stand alone）：服务独立启动，该服务直接常驻于内存中，提供本机或用户的服务行为，反应速度快
  - 总管程序（super daemon）：由特殊的 xinetd 或 inetd 这两个总管程序提供 socket 对应或 port 对应的管理。当没有用户要求某 socket 或 port 时，所需要的服务时不会被启动的。简单说当用户要求时就启动，要求结束就结束程序，缺点是通过总管程序启动有一定的延迟，好处是可以通过 super daemon 来管理

- 服务的想依赖性

  比如：你要启动网络服务，但是系统没有网络、你需要联机到外部取得认证服务器的联机，该联机需求需要另一个 A 服务来达成，但是 A 服务没有启动，这就是服务依赖性问题。 init 在管理员自己手动处理这些服务时，是没有办法协助相依的服务的唤醒的
  
- 执行等级的分类

  init 是开机后核心主动执行的，init 可根据用户自定义的执行等级（runlevel）来唤醒不同的服务，以进入不同的操作界面。基本上 LInux 提供 7 个执行等级：

  0. -
  1. 单人维护模式
  2. -
  3. 纯文本模式
  4. -
  5. 文字加图形界面
  6. -

  而各个执行等级的启动脚本是通过 `/etc/rc.d/rc[0-6]/SXXdaemon` 连结到 `/etc/init.d/daemon`，连结名 SXXdaemon 的功能为：

  - S：启动该服务
  - XX：是数值，启动顺序

  由于有 SXX 的设置，在开机时可以「依序执行」所有需要的服务，同时也能解决相依服务的问题。这点与管理员手动处理不太一样

- 指定执行等级默认要启动的服务

  若要建立如上提到的 SXXdaemon，不需要手动建立连结文件，可以通过如下指令来达成：

  - 预设启动：`chkconfig daemon on`
  - 预设不启动：`chkconfig daemon off`
  - 观察预设启动状态：`chkconfig --list daemon`

- 执行等级的切换行为

  当你要从纯文本界面（runlevel 3）切换到图形界面（5），不需要手动启动、关闭该执行等级的相关服务，只要 `init 5` 即可切换。 init 会主动分析 `/etc/rc.d/rc[35].d/` 这两个目录内的脚本，然后启动转换 runlevel 中需要的服务，就完成了整体的切换

基本上 init 主要功能如上描述，CentOS 7 已经不使用 init 来管理服务了，不过考虑到某些脚本没法使用 systemd 来出来，就简单讲解下

## systemd 使用的 unit 分类

从 CentOS 7.x 后，改用 systemd 启动服务管理机制。好处如下

- 平行处理所有服务，加速开机流程

  init 启动脚本是一项一项依序启动，不想依赖的服务也是一个一个等待启动，systemd 可以让所有服务同时启动，系统启动速度变快了

- 一经要求就响应的 on-demand 启动方式

  systemd 全部只有一个 systemd 服务搭配 systemctl 指令来处理，无需其他额外的指令来支持。

- 服务相互依赖自我检查

  systemd 可以自定义服务相依性检查，当你定义 B 依赖 A 时，你启动 B 服务时，会自动帮你启动 A 服务

- 依 daemon 功能分类

  systemd 旗下管理的服务非常多，先定义所有的服务为一个服务单位（unit），并将 unit 归类到不同的服务类型（type）去。systemd 将服务单位（unit）区分为 service、socket、target、path、snapshot、timer 等多种不同的类型（type），方便管理员的分类与记忆。而旧的 init 仅分为 stand alone 与 super daemon

- 将多个 saemons 集合成为一个群组

  systemd 将许多的功能集合成为一个所谓的 target 项目，只要在设计操作环境的配置，所以是集合了许多的 daemons，执行某个 target 就是执行好多个 daemon

  这个概念类似于 systemV 的 init 中的 runlevel 

- 向下兼容旧的 init 服务脚本

  但是更进阶的 systemd 功能没有办法支持 init 服务脚本，普通功能还是兼容的

systemd 某些地方无法完全取代 init，如：

	- 在 runlevel 的对应上，大概仅有 1、3、4 有对应到 systemd 的某些 target 类型
	- 全部的 systemd 都用 systemctl 管理，而systemctl 支持的语法有限制，无法像 `/etc/init.d/daemon` 那样纯脚本可以自定义参数，systemctl 不可自定义参数
	- 如果某个服务启动时管理员自己通过程序指令手动启动的（如手动执行 crond），那么 systemd 将无法管理该服务
	- systemd 启动过程中，无法与管理员通过 standard input 传入信息，因此，自行编写 systemd 的启动设置时，务必要取消互动机制，连通过启动时传进的标准输入信息也要避免

不过，光是同步启动服务脚本这个工具就可以节省很多开机时间，同时还有很多特殊的服务类型 type 可以提供更多的功能。

### systemd 的配置文件目录

systemd 将 daemon 执行脚本称为服务单位 unit，而每种服务单位按功能来区分时，分为不同的类型 type，类型太多，配置文件在以下位置

- `/usr/lib/systemd/system`：每个服务最主要的启动脚本设置，类似以前的 `/etc/init.d/`下的文件
- `/run/systemd/system`：系统执行过程中所产生的服务脚本，这些脚本的优先顺序比 `/usr/lib/systemd/system` 高
- `/etc/systemd/system`：管理员按主机系统的需求所建立的执行脚本，该目录类似 `/etc/rc.d/rc5.d/Sxx` 之类的功能，执行优先顺序比 `/run/systemd/system` 高

也就是说，系统开机会不会执行某些服务其实是看 `/run/systemd/system` 下的设置。该目录下是一大堆的连结文件。而实际执行的 systemd 启动脚本配置文件，都放置在 `/usr/lib/systemd/system` 目录下。

如果要修改某个服务启动的设置，应该去 `/usr/lib/systemd/system` 下修改，`/etc/systemd/system`仅连结到正确的执行脚本配置文件而已

### systemd 的 unit 类型分类说明

`可通过查看文件的扩展名，区分 /usr/lib/systemd/system` 下的数据 type。下面来查看几个服务启动脚本

```bash
[root@study ~]# ll /usr/lib/systemd/system/ | grep -E '(vsftpd|multi|cron)'
-rw-r--r--. 1 root root  318 Aug  9  2019 crond.service
-rw-r--r--. 1 root root  492 Aug  8  2019 multi-user.target
drwxr-xr-x. 2 root root  258 Jan 17 14:39 multi-user.target.wants
-rw-r--r--. 1 root root  623 Aug  9  2019 multipathd.service
lrwxrwxrwx. 1 root root   17 Jan 17 14:39 runlevel2.target -> multi-user.target
lrwxrwxrwx. 1 root root   17 Jan 17 14:39 runlevel3.target -> multi-user.target
lrwxrwxrwx. 1 root root   17 Jan 17 14:39 runlevel4.target -> multi-user.target
-rw-r--r--. 1 root root  171 Oct 31  2018 vsftpd.service
-rw-r--r--. 1 root root   89 Oct 31  2018 vsftpd.target
-rw-r--r--. 1 root root  184 Oct 31  2018 vsftpd@.service

```

`crond.service` 通过该文件可以看出来，crond 算是系统服务（service）；multi-user 是执行环节相关的类型（target type）；根据这些扩展名的类型，大概可以找到几种比较常见的 systemd 的服务类型

| 扩展名             | 主要服务功能                                                 |
| ------------------ | ------------------------------------------------------------ |
| .service           | 一般服务类型 service unit：主要是系统服务，包括服务器本身所需要的本地服务以及网络服务都是，比较经常使用到的大多是这种类型 |
| .socket            | 内部程序数据交换的插槽服务 socket unit：主要是 IPC（Inter-process communication）的传输信息插槽文件（socket file）功能。 该类型的服务一般是比较不会被用到的服务，因此在开机时通常会延迟启动的时间。一般用于本地服务比较多 |
| .target            | 执行环境类型 target unit：一群 unit 集合，例如上面 multi-user.target 其实就是一堆服务的集合 |
| .mount、.automount | 文件系统挂载相关的服务：例如来自网络的自动挂载、NFS 文件系统挂载等于文件系统相关性较高的程序管理 |
| .path              | 侦测特定文件或目录类型：某些服务需要侦测某些特定的目录来提供队列服务，例如最长久的打印服务，就是通过侦测打印队列目录来启动打印功能， |
| .timer             | 循环执行的服务：类似 anacrontab，不过是由 systemd 主动提供的，比 anacrontab 更加有弹性 |

## 通过 systemctl 管理服务

基本那个，systemd 启动服务的机制，主要是通过 systemctl 指令来处理。

而以前的 systemV 需要 service、chkconfig、setup、init 等指令来完成。

## 管理单一服务 service unit 的启动、开机启动与观察状态

```bash
systemctl [command] [unit]

commond 主要有：
	start： 立刻启动后面的 unit
	stop：立刻关闭后面的 unit
	restart：立刻关闭后启动后面的 unit
	reload：不关闭后面的 unit 的情况下，重载配置文件，让设置生效
	enable：设置开机启动
	disable：取消开机启动
	status：列出 unit 有没有正在执行、开机预设执行、登录等信息
	is-active：目前是否在运行
	is-enable：是否开机启动
```

```bash
# 范例 1：看看目前 atd 这个服务的状态
[root@study ~]# systemctl status atd.service 
* atd.service - Job spooling tools
   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled; vendor preset: enabled)
   Active: active (running) since Tue 2020-03-17 10:49:55 CST; 1 day 5h ago
 Main PID: 1398 (atd)
    Tasks: 1
   CGroup: /system.slice/atd.service
           `-1398 /usr/sbin/atd -f

Mar 17 10:49:55 study.centos.mrcode systemd[1]: Started Job spooling tools.
# 重点在第 2、3 行数据
# Loaded：开机是否启动
# Active：是否正在运行中
# 最后一行：该服务的启动信息
# 登录文件格式为：时间、信息发送主机、哪一个服务的信息、实际信息内容
```

```bash
# 范例 2：正常关闭 atd 服务，非 kill -9
[root@study ~]# systemctl stop atd.service 
[root@study ~]# systemctl status atd.service 
* atd.service - Job spooling tools
   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled; vendor preset: enabled)
   Active: inactive (dead) since Wed 2020-03-18 16:40:06 CST; 13s ago
  Process: 1398 ExecStart=/usr/sbin/atd -f $OPTS (code=exited, status=0/SUCCESS)
 Main PID: 1398 (code=exited, status=0/SUCCESS)

Mar 17 10:49:55 study.centos.mrcode systemd[1]: Started Job spooling tools.
Mar 18 16:40:06 study.centos.mrcode systemd[1]: Stopping Job spooling tools...
Mar 18 16:40:06 study.centos.mrcode systemd[1]: Stopped Job spooling tools.
# 这下就明白了。后面两行信息是执行 stop 后发生的事件日志信息
```

不要使用 kill 的方式来关掉一个正常的服务，否则 systemctl 无法监控该服务。上面信息的 Active 状态有如下几个常见的状态：

- active（running）：有一个或多个程序正在运行

- active（exited）：仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。

  比如：开机或是挂载时才会进行一次的 quotaon 功能，就是这种模式，quotaon 不需要一直执行，只需要执行一次之后，就交给文件系统自行处理了。通常用 bash shell 写的小型服务，大多属于此种类型（无需常驻内存）

- active（waiting）：正在执行中中，不过在在等待其他的事件才能继续处理

- inactive：这个服务目前没有运行

开机预设状态有以下：

- enabled：开机执行
- disabled：开机不执行
- static：不可以自己启动。不过可能会被其他的 enabled 的服务来唤醒（依赖服务）
- mask：无法被启动，因为已经被强制注销（非删除）。可通过 systemctl unmask 方式改回原本的状态

### 服务启动、关闭与观察联系

习题 1：找到系统中名为 chronyd 的服务，观察此服务状态，并将服务设置为：

1. 开机不会启动
2. 现在状态是关闭的情况

```bash
[root@study ~]# systemctl status chronyd.service 
* chronyd.service - NTP client/server
	# 开机启动
   Loaded: loaded (/usr/lib/systemd/system/chronyd.service; enabled; vendor preset: enabled)
   # 正在运行中
   Active: active (running) since Tue 2020-03-17 10:49:42 CST; 1 day 6h ago
     Docs: man:chronyd(8)
           man:chrony.conf(5)
    Tasks: 1
   CGroup: /system.slice/chronyd.service
           `-933 /usr/sbin/chronyd

Mar 17 10:49:39 study.centos.mrcode systemd[1]: Starting NTP client/server...
Mar 17 10:49:39 study.centos.mrcode chronyd[933]: chronyd version 3.4 starting (+CMDMON +NTP +REFCLOCK +RTC +PRIVDROP +SCFILTER +SIGND +ASYNCDNS +SECHASH +IPV6 +DEBUG)
Mar 17 10:49:39 study.centos.mrcode chronyd[933]: Frequency 0.000 +/- 1000000.000 ppm read from /var/lib/chrony/drift
Mar 17 10:49:42 study.centos.mrcode systemd[1]: Permission denied while opening PID file or unsafe symlink chain: /var/run/chrony/chronyd.pid
Mar 17 10:49:42 study.centos.mrcode systemd[1]: Started NTP client/server.

# 取消开机启动
[root@study ~]# systemctl disable chronyd.service 
Removed symlink /etc/systemd/system/multi-user.target.wants/chronyd.service.
# 取消开机启动，这里其实就是移除了 /etc/systemd/system 该目录下的一个链接文件

# 停止该服务
[root@study ~]# systemctl stop chronyd.service 
[root@study ~]# systemctl status chronyd.service 
* chronyd.service - NTP client/server
   Loaded: loaded (/usr/lib/systemd/system/chronyd.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:chronyd(8)
           man:chrony.conf(5)

Mar 17 10:49:39 study.centos.mrcode systemd[1]: Starting NTP client/server...
Mar 17 10:49:39 study.centos.mrcode chronyd[933]: chronyd version 3.4 starting (+CMDMON +NTP +REFCLOCK +RTC +PRIVDROP +SCFILTER +SIGND +ASYNCDNS +SECHASH +IPV6 +DEBUG)
Mar 17 10:49:39 study.centos.mrcode chronyd[933]: Frequency 0.000 +/- 1000000.000 ppm read from /var/lib/chrony/drift
Mar 17 10:49:42 study.centos.mrcode systemd[1]: Permission denied while opening PID file or unsafe symlink chain: /var/run/chrony/chronyd.pid
Mar 17 10:49:42 study.centos.mrcode systemd[1]: Started NTP client/server.
Mar 18 16:53:11 study.centos.mrcode systemd[1]: Stopping NTP client/server...
Mar 18 16:53:11 study.centos.mrcode systemd[1]: Stopped NTP client/server.
```

习题 2：将 cups 服务整个关闭（因为没有打印机安装在服务器上，也没有网络打印机）

```bash
[root@study ~]# systemctl status cups.service 
* cups.service - CUPS Printing Service
   Loaded: loaded (/usr/lib/systemd/system/cups.service; enabled; vendor preset: enabled)
   # 书上这里状态是 inactive(dead) 没有运行状态，笔者这里确实在运行状态
   Active: active (running) since Tue 2020-03-17 10:49:55 CST; 1 day 6h ago
 Main PID: 1374 (cupsd)
   CGroup: /system.slice/cups.service
           `-1374 /usr/sbin/cupsd -f

Mar 17 10:49:55 study.centos.mrcode systemd[1]: Started CUPS Printing Service.

# 停止服务
[root@study ~]# systemctl stop cups.service 
Warning: Stopping cups.service, but it can still be activated by:
  cups.path
  cups.socket
# 取消开机启动
[root@study ~]# systemctl disable cups.service 
Removed symlink /etc/systemd/system/multi-user.target.wants/cups.path.
Removed symlink /etc/systemd/system/multi-user.target.wants/cups.service.
Removed symlink /etc/systemd/system/sockets.target.wants/cups.socket.
Removed symlink /etc/systemd/system/printer.target.wants/cups.service.
# 这里一共移除了 4 个连结文件，说明这几个文件可能是相依赖性
[root@study ~]# netstat -tlunp | grep cups
# cups 服务没有被启动，所以没有端口产生

# 尝试启动 cups.socket 监听客户端的需求
[root@study ~]# systemctl start cups.socket
[root@study ~]# systemctl status cups.service cups.socket cups.path 
* cups.service - CUPS Printing Service
   Loaded: loaded (/usr/lib/systemd/system/cups.service; disabled; vendor preset: enabled)
   Active: inactive (dead) since Wed 2020-03-18 16:57:19 CST; 4min 8s ago
 Main PID: 1374 (code=exited, status=0/SUCCESS)

Mar 17 10:49:55 study.centos.mrcode systemd[1]: Started CUPS Printing Service.
Mar 18 16:57:19 study.centos.mrcode systemd[1]: Stopping CUPS Printing Service...
Mar 18 16:57:19 study.centos.mrcode systemd[1]: Stopped CUPS Printing Service.

* cups.socket - CUPS Printing Service Sockets
   Loaded: loaded (/usr/lib/systemd/system/cups.socket; disabled; vendor preset: enabled)
   Active: active (listening) since Tue 2020-03-17 10:49:38 CST; 1 day 6h ago
   Listen: /var/run/cups/cups.sock (Stream)

Mar 17 10:49:38 study.centos.mrcode systemd[1]: Listening on CUPS Printing Service Sockets.

* cups.path - CUPS Printer Service Spool
   Loaded: loaded (/usr/lib/systemd/system/cups.path; disabled; vendor preset: enabled)
   Active: active (waiting) since Tue 2020-03-17 10:49:38 CST; 1 day 6h ago

Mar 17 10:49:38 study.centos.mrcode systemd[1]: Started CUPS Printer Service Spool.
# 笔者这里和书上又不一样，书上 cups.path 是 inactive(dead) 状态，我这里则是等待状态


# 尝试使用 lp 指令打印
[root@study ~]# echo "testing" | lp
lp: Error - no default destination available.
# 实际上没有打印机，出现错误也正常
[root@study ~]# systemctl status cups.service                       
* cups.service - CUPS Printing Service
   Loaded: loaded (/usr/lib/systemd/system/cups.service; disabled; vendor preset: enabled)
   # 被启动了
   Active: active (running) since Wed 2020-03-18 17:03:17 CST; 41s ago
 Main PID: 23325 (cupsd)
    Tasks: 1
   CGroup: /system.slice/cups.service
           `-23325 /usr/sbin/cupsd -f

Mar 18 17:03:17 study.centos.mrcode systemd[1]: Started CUPS Printing Service.
[root@study ~]# netstat -tlunp | grep cups
tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      23325/cupsd         
tcp6       0      0 ::1:631                 :::*                    LISTEN      23325/cupsd 

# 这里竟然被自动启动了，我们刚刚操作命名是 stop 了这个服务
```

上面例子充分演示了很多服务之间是有相依性的，cups 是一种打印服务，会启用 631 port 来提供网络打印机的打印功能。但是我们无需一直启动 631 的端口，因此，多了一个 cups.socket 的服务，这个服务可以在「用户有需要打印时，才会主动唤醒 cups.service」，由于有了这个特性，所以就算事先吧 3 个 cups 的服务都 stop 掉，当用户向其他两个 cups.path、cups.socket 提出要求时， cups.service 就会被唤醒

### 强迫服务注销 mask 的练习

比较正常的做法是：要关闭 cups.service 时，连同其他两个会唤醒 service 的 cups.socket 与 cups.path 都关闭，那就没有事情了。

不正常的做法是：强迫 cups.service 注销，通过 mask 方式

```bash
[root@study ~]# systemctl stop cups.service 
Warning: Stopping cups.service, but it can still be activated by:
  cups.socket
  cups.path
[root@study ~]# systemctl mask cups.service 
Created symlink from /etc/systemd/system/cups.service to /dev/null.
[root@study ~]# systemctl status cups.service 
* cups.service
   Loaded: masked (/dev/null; bad)
   Active: inactive (dead) since Wed 2020-03-18 17:11:29 CST; 32s ago
 Main PID: 23325 (code=exited, status=0/SUCCESS)

Mar 18 17:03:17 study.centos.mrcode systemd[1]: Started CUPS Printing Service.
Mar 18 17:11:29 study.centos.mrcode systemd[1]: Stopping CUPS Printing Service...
Mar 18 17:11:29 study.centos.mrcode systemd[1]: Stopped CUPS Printing Service.
[root@study ~]# systemctl start cups.service 
Failed to start cups.service: Unit is masked.
```

通过 mask 之后，他的连结文件被连结到了 `/dev/null`，所以就无法启动了

```bash
# 取消注销
[root@study ~]# systemctl unmask cups.service 
Removed symlink /etc/systemd/system/cups.service.
[root@study ~]# systemctl status cups.service 
* cups.service - CUPS Printing Service
   Loaded: loaded (/usr/lib/systemd/system/cups.service; disabled; vendor preset: enabled)
   Active: inactive (dead) since Wed 2020-03-18 17:11:29 CST; 2min 30s ago
 Main PID: 23325 (code=exited, status=0/SUCCESS)

Mar 18 17:03:17 study.centos.mrcode systemd[1]: Started CUPS Printing Service.
Mar 18 17:11:29 study.centos.mrcode systemd[1]: Stopping CUPS Printing Service...
Mar 18 17:11:29 study.centos.mrcode systemd[1]: Stopped CUPS Printing Service.
# 恢复正常了
```

## 观察系统上所有的服务

```bash
systemctl [command][--type=TYPE][--all]

command：
	list-units：按 unit 列出目前有启动的 unit。若加上 --all 才会列出没有启动的
	list-unit-files：按 `/usr/lib/systemd/system` 内的文件，将所有文件列表说明
--type：之前提到过的 unit type，主要有 service、socket、target 等
```

```bash
范例 1：列出系统上有启动的 unit
[root@study ~]# systemctl
UNIT                                                                                     LOAD   ACTIVE SUB       DESCRIPTION
proc-sys-fs-binfmt_misc.automount                                                        loaded active waiting   Arbitrary Executable File Formats File System Automount Point
sys-devices-pci0000:00-0000:00:03.0-net-enp0s3.device                                    loaded active plugged   82540EM Gigabit Ethernet Controller (PRO/1000 MT Desktop Adapter)
sys-devices-pci0000:00-0000:00:05.0-sound-card0.device                                   loaded active plugged   82801AA AC'97 Audio Controller
sys-devices-pci0000:00-0000:00:0d.0-ata3-host2-target2:0:0-2:0:0:0-block-sda-sda1.device loaded active plugged   VBOX_HARDDISK 1
...
vsftpd.service  loaded active running   Vsftpd ftp daemon

LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

152 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.
lines 106-160/160 (END)
# 服务太多了，个别字段含义如下
# UNIT：项目名称，包括各个 unit 的类型（看扩展名）
# LOAD：开机时是否会被加载，默认 systemctl 显示的是有加载的项目
# ACTIVE：目前的状态，续与后续的 SUB 搭配，就是用 systemctl status 观察时，active 项目
# DESCRIPTION：详细描述
# 另外，systemctl 不加参数，预设是 list-units 
```

```bash
# 范例 2：列出所有已经安装的 unit 有哪些
[root@study ~]# systemctl list-unit-files 
UNIT FILE                                     STATE   
proc-sys-fs-binfmt_misc.automount             static  
dev-hugepages.mount                           static  
dev-mqueue.mount                              static  
proc-fs-nfsd.mount                            static  
proc-sys-fs-binfmt_misc.mount                 static  
sys-fs-fuse-connections.mount                 static  
sys-kernel-config.mount                       static  
sys-kernel-debug.mount                        static  
tmp.mount                                     disabled
var-lib-nfs-rpc_pipefs.mount                  static  
brandbot.path                                 disabled
cups.path                                     disabled
systemd-ask-password-console.path             static  
systemd-ask-password-plymouth.path            static  
systemd-ask-password-wall.path                static  
session-2.scope                               static  
session-92.scope                              static  
session-c1.scope                              static  
abrt-ccpp.service                             enabled 
abrt-oops.service                             enabled 
# 会将系统上所有的服务都列出来，STATE 则是前面讲到过的
```

```bash
# 范例 3：只列出某种类型的 unit
# 这样就只会显示 .service 类型的服务了
[root@study ~]# systemctl list-units --type=service --all
  UNIT                                                  LOAD      ACTIVE   SUB     DESCRIPTION
  abrt-ccpp.service                                     loaded    active   exited  Install ABRT coredump hook
  abrt-oops.service                                     loaded    active   running ABRT kernel log watcher
  abrt-vmcore.service                                   loaded    inactive dead    Harvest vmcores for ABRT
  abrt-xorg.service                                     loaded    active   running ABRT Xorg log watcher
  abrtd.service                                         loaded    active   running ABRT Automated Bug Reporting Tool
  accounts-daemon.service                               loaded    active   running Accounts Service
  alsa-restore.service                                  loaded    inactive dead    Save/Restore Sound Card State
  alsa-state.service                                    loaded    active   running Manage Sound Card State (restore and store)
* apparmor.service                                      not-found inactive dead    apparmor.service

# 查找是否有 cpu 为名的服务
[root@study ~]# systemctl list-units --type=service --all | grep cpu
  cpupower.service                                      loaded    inactive dead    Configure CPU power related settings
# CPU 电源管理机制的服务 
```

## 管理不同的操作环境（target unit）

```bash
[root@study ~]# systemctl list-units --type=target --all            
  UNIT                   LOAD      ACTIVE   SUB    DESCRIPTION
  basic.target           loaded    active   active Basic System
  cryptsetup.target      loaded    active   active Local Encrypted Volumes
* dbus.target            not-found inactive dead   dbus.target
  emergency.target       loaded    inactive dead   Emergency Mode
  final.target           loaded    inactive dead   Final Step
  getty-pre.target       loaded    active   active Login Prompts (Pre)
  getty.target           loaded    active   active Login Prompts
  graphical.target       loaded    active   active Graphical Interface
  local-fs-pre.target    loaded    active   active Local File Systems (Pre)
  local-fs.target        loaded    active   active Local File Systems
  multi-user.target      loaded    active   active Multi-User System
  network-online.target  loaded    active   active Network is Online
  network-pre.target     loaded    active   active Network (Pre)
  network.target         loaded    active   active Network
  nfs-client.target      loaded    active   active NFS client services
  nss-lookup.target      loaded    inactive dead   Host and Network Name Lookups
  nss-user-lookup.target loaded    active   active User and Group Name Lookups
  paths.target           loaded    active   active Paths
  remote-fs-pre.target   loaded    active   active Remote File Systems (Pre)
  remote-fs.target       loaded    active   active Remote File Systems
  rescue.target          loaded    inactive dead   Rescue Mode
  rpc_pipefs.target      loaded    active   active rpc_pipefs.target
  rpcbind.target         loaded    active   active RPC Port Mapper
  shutdown.target        loaded    inactive dead   Shutdown
  slices.target          loaded    active   active Slices
  sockets.target         loaded    active   active Sockets
  sound.target           loaded    active   active Sound Card
  swap.target            loaded    active   active Swap
  sysinit.target         loaded    active   active System Initialization
* syslog.target          not-found inactive dead   syslog.target
  time-sync.target       loaded    inactive dead   System Time Synchronized
  timers.target          loaded    active   active Timers
  umount.target          loaded    inactive dead   Unmount All Filesystems

LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

33 loaded units listed.
To show all installed unit files use 'systemctl list-unit-files'.
```

笔者这里与书上也不太一样（可能还是因为系统版本的原因，我的比较新一点），有 33 个 target unit，与操作界面相关性较高的 target 主要有下面几个

- graphical.target：文字 + 图形界面，该项目已包含了下面的 multi-user.target 项目
- multi-user.target：纯文本模式
- rescue.target：在无法使用 root 登录的情况下，systemd 在开机时会多加一个额外的暂时系统，与你原本的系统无关。这时就可以取得 root 的权限来维护你的系统。由于是额外的系统，可能需要使用 chroot 方式来取得原有的系统（后续会讲解）
- emergency.target：紧急处理系统的错误，需要使用 root 登录的情况，在无法使用 rescue.target 时，可以尝试使用该模式
- shutdown.target：关机流程
- getty.target：可以设置你需要几个 tty 之类的，如果想要降低 tty 的项目，可以修改该配置文件

按功能分类如下：

- 正常模式：graphical.target、multi-user.target
- 救援模式：rescue.target、emergency.target

如何获取当前的模式与修改

```bash
systemctl [command] [unit.target]

command：
	get-default：取得目前的 target
	set-default：将 target 设置为默认的操作模式
	isolate：切换到后面指定的操作模式
```

```bash
# 范例 1：我们的测试机器默认是图形界面，先观察是否是图形模式，再将默认模式设置为文字模式
[root@study ~]# systemctl get-default 
graphical.target			# 果真是
[root@study ~]# systemctl set-default multi-user.target 
Removed symlink /etc/systemd/system/default.target.
Created symlink from /etc/systemd/system/default.target to /usr/lib/systemd/system/multi-user.target.
[root@study ~]# systemctl get-default 
multi-user.target
# 已切换到文字模式为默认模式了

# 范例 2：在不重新启动的情况下，将目前的操作环境改为纯文本模式，关掉图形界面
systemctl isolate multi-user.target

# 范例 3：切换到图形界面
systemctl isolate graphical.target
```

注意：在 service 部分用 start、stop、restart ，在 target 中使用 上述提到的指令，isolate 切换；还提供了几个简单直观的指令使用

```bash
systemctl poweroff		# 系统关机
systemctl reboot		# 重新启动
systemctl suspend		# 进入暂停模式
systemctl hibernate		# 进入休眠模式
systemctl rescue		# 强制进入救援模式
systemctl emergency		# 强制进入紧急救援模式
```

- suspend：暂停模式

  该模式会将系统的状态数据保存在内存中，然后关闭掉大部分的系统硬件，当用户按下唤醒机器的按钮，系统数据会从内存中恢复，然后重新驱动被大部分关闭的硬件，唤醒速度很快；

- hibernate：休眠模式

  将系统状态保存到硬盘中，保存完成后，计算机关闭。当用户尝试唤醒系统时，会开始正常工作，然后将保存在硬盘中的系统状态恢复回来。由于数据从硬盘读取，所以唤醒效率与硬盘速度有关

## 分析个服务之间的相依性

本章开始讲到过 systemd 相依性的问题客服，那么，如何追踪某一个 unit 的相依性呢？比如怎么知道 `graphical.target` 会用到 `multi-user.target` ？

```bash
systemctl list-dependencies [unit] [--reverse]

-- reverse：反向追踪谁使用这个 unit
```

```bash
# 范例 1：列出目前的 target 环境下，用到什么特别的 unit
[root@study ~]# systemctl get-default 
multi-user.target
[root@study ~]# systemctl list-dependencies 
default.target
* |-abrt-ccpp.service
* |-abrt-oops.service
* |-abrt-vmcore.service
* |-abrt-xorg.service
* |-abrtd.service
* |-atd.service
* |-getty.target
* | `-getty@tty1.service
* |-nfs-client.target
* | |-auth-rpcgss-module.service
* | |-rpc-statd-notify.service
* | `-remote-fs-pre.target
* `-remote-fs.target
*   `-nfs-client.target
*     |-auth-rpcgss-module.service
*     |-rpc-statd-notify.service
*     `-remote-fs-pre.target

```

这里不加 unit 则是使用默认的 target，可以看到一颗依赖树，非常直观

```bash
# 反向追踪
[root@study ~]# systemctl list-dependencies --reverse 
default.target
* `-graphical.target

# 查看 graphical.target 使用了多少服务
[root@study ~]# systemctl list-dependencies graphical.target
graphical.target
* |-accounts-daemon.service
* |-gdm.service
* |-initial-setup-reconfiguration.service
* |-network.service
* |-rtkit-daemon.service
* |-systemd-update-utmp-runlevel.service
* |-udisks2.service
* `-multi-user.target
*   |-abrt-ccpp.service
*   |-abrt-oops.service
*   |-abrt-vmcore.service
```

## 与 systemd 的 deaemon 运行过程相关目录简介

比较重要的 systemd 启动脚本配置文件在 `/usr/lib/systemd/system/`、`/etc/systemd/system/` 目录下，还有以下目录与系统的 daemon 运行有关：

- `/usr/lib/systemd/system/`：

  使用 CentOS 官方提供的软件安装后，默认的启动脚本配置文件都放在这里，这里的数据尽量不要修改，要修改时，可以到 `/etc/systemd/system/` 下修改

- `/run/systemd/system/`：

  系统执行过程中所产生的服务脚本，这些脚本的优先顺序比 `/usr/lib/systemd/system/` 高

- `/etc/systemd/system/`：

  管理员根据需求建立的执行脚本，执行优先顺序比 `/run/systemd/system/` 高

- `/etc/sysconfig/*`：

  几乎所有的服务都会将初始化的一些选项设置写入到这个目录下。

  比如 mandb 要更新的 man page 索引中，需要加入的参数就写入到此目录下的 man-db 中。而网络的设置写在 `/etc/sysconfig/network-scripts/` ；所以该目录也很重要

- `/var/lib/`：

  一些会产生数据的服务都会讲它的数据写入到该目录中。

  比如：数据库管理系统 Mariadb 的数据库默认写入到 `/var/lib/mysql/` 目录下的

- `/run/`：存放了很多 daemon 的暂存文件，包括 lock file 以及 PID file 等

我们知道 systemd 有很多本机会用到的 socket 服务，会产生很多的 socket file，可以通过以下方式知道这些 socket file 的存放位置

```bash
[root@study ~]# systemctl list-sockets 
LISTEN                          UNIT                         ACTIVATES
/dev/log                        systemd-journald.socket      systemd-journald.service
/run/dbus/system_bus_socket     dbus.socket                  dbus.service
/run/dmeventd-client            dm-event.socket              dm-event.service
/run/dmeventd-server            dm-event.socket              dm-event.service
/run/lvm/lvmetad.socket         lvm2-lvmetad.socket          lvm2-lvmetad.service
/run/lvm/lvmpolld.socket        lvm2-lvmpolld.socket         lvm2-lvmpolld.service
/run/systemd/initctl/fifo       systemd-initctl.socket       systemd-initctl.service
/run/systemd/journal/socket     systemd-journald.socket      systemd-journald.service
/run/systemd/journal/stdout     systemd-journald.socket      systemd-journald.service
/run/systemd/shutdownd          systemd-shutdownd.socket     systemd-shutdownd.service
/run/udev/control               systemd-udevd-control.socket systemd-udevd.service
/var/run/avahi-daemon/socket    avahi-daemon.socket          avahi-daemon.service
/var/run/cups/cups.sock         cups.socket                  cups.service
/var/run/libvirt/virtlockd-sock virtlockd.socket             virtlockd.service
/var/run/libvirt/virtlogd-sock  virtlogd.socket              virtlogd.service
/var/run/rpcbind.sock           rpcbind.socket               rpcbind.service
0.0.0.0:111                     rpcbind.socket               rpcbind.service
0.0.0.0:111                     rpcbind.socket               rpcbind.service
@ISCSIADM_ABSTRACT_NAMESPACE    iscsid.socket                iscsid.service
@ISCSID_UIP_ABSTRACT_NAMESPACE  iscsiuio.socket              iscsiuio.service
[::]:111                        rpcbind.socket               rpcbind.service
[::]:111                        rpcbind.socket               rpcbind.service
kobject-uevent 1                systemd-udevd-kernel.socket  systemd-udevd.service

23 sockets listed.
Pass --all to see loaded but inactive sockets, too.

```

上面列出了正在监听本地服务需求的 socket file 所在的文件名位置

## 网络服务于端口对应简介

IP 与 PORT 是英特网联机的最重要机制之一，还有各种的通信协议，如 http、ftp；在 `/etc/services` 里面对应了协议与端口号的映射关系

```bash
[root@study ~]# cat /etc/services
# daemon name	port/封包协议	服务说明
ftp             21/tcp
ftp             21/udp          fsp fspd
ssh             22/tcp                          # The Secure Shell (SSH) Protocol
ssh             22/udp                          # The Secure Shell (SSH) Protocol
http            80/tcp          www www-http    # WorldWideWeb HTTP
http            80/udp          www www-http    # HyperText Transfer Protocol
http            80/sctp                         # HyperText Transfer Protocol
https           443/tcp                         # http protocol over TLS/SSL
https           443/udp                         # http protocol over TLS/SSL
https           443/sctp                        # http protocol over TLS/SSL
# 该文件下有大量的数据
```

不建议修改这些端口，除非你想吧这些隐藏起来，不让外部访问到

## 关闭网络服务

当你第一次使用 systemctl 观察本地服务器启动的服务时，会发现有很多 daemon，这是因为 systemd 将许多原本不被列为 daemon 的程序也纳入管理检测范围内，但是那些大部分都属于 Linux 系统基础运行所需的环境，你不清楚的情况下，最好不要去修改他们

除了本地服务之外，要观察网络服务，虽然网络服务默认有 SELinux 管理，不过，还是建议非必要的网络服务就关闭它。基本上会产生一个网络监听端口的程序，就可以称它为网络服务了，可通过如下方式观察网络端口

```bash
[root@study ~]# netstat -tlunp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1578/master         
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      2350/sshd: mrcode@p 
tcp        0      0 127.0.0.1:6011          0.0.0.0:*               LISTEN      10579/sshd: root@pt 
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           
tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      1975/dnsmasq        
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1378/sshd           
tcp6       0      0 ::1:25                  :::*                    LISTEN      1578/master         
tcp6       0      0 ::1:6010                :::*                    LISTEN      2350/sshd: mrcode@p 
tcp6       0      0 ::1:6011                :::*                    LISTEN      10579/sshd: root@pt 
tcp6       0      0 :::555                  :::*                    LISTEN      11573/vsftpd        
tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           
tcp6       0      0 :::22                   :::*                    LISTEN      1378/sshd           
udp        0      0 192.168.122.1:53        0.0.0.0:*                           1975/dnsmasq        
udp        0      0 0.0.0.0:67              0.0.0.0:*                           1975/dnsmasq        
udp        0      0 0.0.0.0:111             0.0.0.0:*                           1/systemd           
udp        0      0 0.0.0.0:33017           0.0.0.0:*                           920/avahi-daemon: r 
udp        0      0 0.0.0.0:669             0.0.0.0:*                           925/rpcbind         
udp        0      0 0.0.0.0:5353            0.0.0.0:*                           920/avahi-daemon: r 
udp6       0      0 :::111                  :::*                                1/systemd           
udp6       0      0 :::669                  :::*                                925/rpcbind 
```

比如上面显示 `avahi-daemon` 服务监听了 5353 和 33017 端口，可以通过 systemctl 查找是否真的有 avahi-daemon 服务

```bash
[root@study ~]# systemctl list-units --all | grep avahi-daemon
  avahi-daemon.service                                                                                           loaded    active   running   Avahi mDNS/DNS-SD Stack
  avahi-daemon.socket                                                                                            loaded    active   running   Avahi mDNS/DNS-SD Stack Activation Socket
```

avahi-daemon 的目的是在局域网进行类似网芳的搜索，因此这个服务可以协助你在区网内随时了解即插即用的设备。包括笔记本电脑等，只要你连上区网，你就能知道谁进来了。问题是，你可能不需要这个协议，关闭它

```bash
# 关闭两个服务，并且取消开机启动
[root@study ~]# systemctl stop avahi-daemon.service 
Warning: Stopping avahi-daemon.service, but it can still be activated by:
  avahi-daemon.socket
[root@study ~]# systemctl stop avahi-daemon.socket  
[root@study ~]# systemctl disable avahi-daemon.service avahi-daemon.socket 
Removed symlink /etc/systemd/system/multi-user.target.wants/avahi-daemon.service.
Removed symlink /etc/systemd/system/sockets.target.wants/avahi-daemon.socket.
Removed symlink /etc/systemd/system/dbus-org.freedesktop.Avahi.service.
[root@study ~]# netstat -tlunp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1578/master         
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      2350/sshd: mrcode@p 
tcp        0      0 127.0.0.1:6011          0.0.0.0:*               LISTEN      10579/sshd: root@pt 
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           
tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      1975/dnsmasq        
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1378/sshd           
tcp6       0      0 ::1:25                  :::*                    LISTEN      1578/master         
tcp6       0      0 ::1:6010                :::*                    LISTEN      2350/sshd: mrcode@p 
tcp6       0      0 ::1:6011                :::*                    LISTEN      10579/sshd: root@pt 
tcp6       0      0 :::555                  :::*                    LISTEN      11573/vsftpd        
tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           
tcp6       0      0 :::22                   :::*                    LISTEN      1378/sshd           
udp        0      0 192.168.122.1:53        0.0.0.0:*                           1975/dnsmasq        
udp        0      0 0.0.0.0:67              0.0.0.0:*                           1975/dnsmasq        
udp        0      0 0.0.0.0:111             0.0.0.0:*                           1/systemd           
udp        0      0 0.0.0.0:669             0.0.0.0:*                           925/rpcbind         
udp6       0      0 :::111                  :::*                                1/systemd           
udp6       0      0 :::669                  :::*                                925/rpcbind  
```

一般来说，你本地服务器至少需要 25 端口，而 22 端口最好加上防火墙来管理远程联机登录比较妥当。555 端口是我们前面练习测试修改的。这样的系统能够被黑的机会已经少很多了。

## systemctl 针对 service 类型的配置

以前需要建立系统服务，需要在 `/etc/init.d/` 创建对应的 bash shell script 来处理，如今在 systemd 环境下，该怎么设置相关的服务启动环境？

## 配置文件相关目录简介

systemd 的配置文件大部分在 `/usr/lib/systemd/system/` 目录内，Red Hat 官方文件指出，该目录的文件主要是原本软件所提供的设置，建议不要修改。修改的位置在 `/etc/systemd/system/` 目录内

比如：想要额外修改  vsftpd.service ，建议放到的位置如下：

- `/usr/lib/systemd/vsftpd.service` ：官方的预设配置文件

- `/etc/systemd/system/vsftp.service.d/custom.conf`：

  建立同名并已 `.d` 后缀结尾的目录，该目录下的文件会「累加其他设置」进入 `/usr/lib/systemd/vsftpd.service`

  意思应该是：这里是配置会覆盖掉 `/usr/lib/systemd/vsftpd.service` 中的同名配置

- `/etc/systemd/system/vsftpd.service.wants/*`

  此目录内的文件为链接文件，设置相依服务的链接。作用是启动了 vsftpd.service 后，最好再加上该目录下的建议服务

- `/etc/systemd/system/vsftpd.service.requires/*`

  此目录内的文件为链接文件，设置相依服务的链接。作用是，在启动 vsftpd.service 之前，需要事先启动哪些服务

基本上在配置文件中，你可以自由设置相依服务的检查，并且设置加入到哪些 target 里。就是建议不要修改原始的配置文件，在上述建议目录下去操作修改

## 配置文件的设置项目简介

这次通过 sshd.service 的配置文件来讲解配置文件的内容

```bash
[root@study ~]# cat /usr/lib/systemd/system/sshd.service
[Unit]
Description=OpenSSH server daemon
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target sshd-keygen.service
Wants=sshd-keygen.service

[Service]		# 该项目于实际执行的指令参数有关
Type=notify
EnvironmentFile=/etc/sysconfig/sshd
ExecStart=/usr/sbin/sshd -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]		# 此 unit 要挂载到哪个 target 下
WantedBy=multi-user.target
```

分析上述文件，大概分为三个部分：

- `[Unit]`

  unit 本身的说明，以及其他相依 daemon 的设置，包括在什么服务之后才启动此 unit 之类的设置

- `[Service]、[Socket][Timer][Mount][Path]...`

  不同的 unit type 需要使用对应的设置项目。对于 service 来说，主要在规范服务启动脚本、环境配置文件名、重新启动的方式等

- `[Install]`：将此 unit 安装到哪个 target 里面

配置文件内有些设置规则如下：

- 设置项目通常是可以重复的

  例如可以设置两个 After 在配置文件中，不过，后面的设置会取代前面的，可以使用 `After=`  的方式，将该项清空归零

- 如果设置参数需要有「是/否 boolean 类型值」的项目，可以使用 1、yes、true、on 代表启动，0、no、false、off 代表关闭

- 空白行、开头为 `#` 或 `;` 都表示批注信息

每个部分的说明如下：

### `[unit]` 部分

- Description

  使用 systemctl list-units 时，展示出来的简易说明。systemctl status 中输出的服务说明也是该值

- Documentation

  提供管理员能够进一步的文件查询功能，提供的文件可以是如下的资料

  - `=http://www..`
  - `=man:sshd(8)`
  - `=file:/etc/ssh/sshd_config`

- After：说明此 unit 是在哪个 daemon 启动之后才能启动。

  基本上仅是说明启动顺序，并无强制要求里面的服务一定要启动后此 unit 才能启动。它与 Requires 的设置含义是有差异的。

- Before：在什么服务启动前，启动本服务

  同样，并非强制性的

- Rrquires：相依性配置

  明确定义此 unit 需要在哪个 daemon 启动后才能启动。如果依赖的服务没有启动，则该服务不会被启动

- Wants：

  此 unit 启动之后，还需要启动哪些服务。不是强制性的，只是希望建立让使用者比较好的操作环境

- Conflicts：冲突服务

  如果这里申明的服务已经启动，那么本 unit 就不能启动。如果我们的 unit 有启动，那么这里定义的服务不能启动。

### `[service]` 部分

- Type：启动方式，会影响到 ExecStart。一般有如下几种

  - simple：默认值，主要由 ExecStart 定义的指令串来启动，启动后常驻于内存中

  - forking：

    由 ExecStart 启动的程序通过 spawns 延伸出其他子程序来作为此 daemon 的主要服务。原生的父程序在启动结束后就会终止运行。传统的 unit 服务大多属于这种项目。

    例如：httpd 这个 www 服务，当 httpd 的程序因为运行过久因此即将终结了，则 systemd 会再重新生出另一个子程序持续运行后，再将父程序删除。据说这样的效率比较好

  - oneshot：与 simple 类似，不过该程序工作完毕后就结束了，不会常驻内存中

  - dbus：与 simple 类似，但是这个 daemon 必须要在取得一个 D-Bus 的名称后，才会继续运行，因此设置该项目时，通常也要设置 BusName 才行

  - idle：与 simple 类似，要执行这个 daemon 必须要所有的工作都顺利执行完成后，才会执行，这里的 daemon 通常是开机到最后才执行的服务

  比较重要的 simple、forking 与 oneshot，很多服务需要子程序 forking，还有很多服务只需要在开机的时候执行一次 oneshot

- EnvironmentFile：指定启动脚本的环境配置文件

  例如：sshd.service 的配置文件写入到 `/etc/sysconfig/sshd` 中，也可以直接在该项后面用多个不同的 Shell 变量来设置

- ExecStart：实际执行此 daemon 的指令或脚本程序

  也可以使用 ExecStartPre（之前） 以及 ExecStartPost（之后）在实际启动服务前后进行额外的指令行为。但是仅支持「指令 参数 参数...」格式，不能接受 `< >  >> | & ` 等特殊字符，很多 bash 语法也不支持，如果需要这些特殊字符的时候，最好直接写到指令脚本里面。还有一种方式可以支持完整的语法；将 Type=oneshot 就可以了

- ExecStop：与 systemctl stop 的执行有关，关闭此服务时所执行的指令

- ExecReload：与 systemctl reload 有关的指令行为

- Restart：

  当设置 Restart=1 时，当此 daemon 服务终止后，会再次启动该服务

  除非使用 systemctl 强制将此服务关闭，否则该功能会一直生效

- RemainAfterExit

  当值设置为 1 时， 当该 daemon 所属的所有程序都终止后，此服务会再尝试启动。这对于 Type=oneshot 的服务有帮助

- TimeoutSec：若这个服务在启动或是关闭时，因为某些缘故导致无法顺利「正常启动或正常结束」的情况下，则需要等待多久才进入「强制结束」的状态

- KillMode

  可以是 process、control-group、none 其中的一种：

  - process：终止时，只会终止主要的程序（ExecStart 后面指令串启动的）
  - control-group：则由此 daemon 所产生的其他 control-group 的程序，也会被关闭
  - one：没有程序会被关闭

- RestartSec：

    与 Restart 有相关性，如果该服务被关闭，需要重新启动时，大概要 sleep 多少时间再重新启动。预设是 100ms

### `[Install]` 部分

- WantedBy：该 unit 本身是附挂在哪一个 target unit 下

  该项设置大部分都是 `*.target unit` 。大多数服务性质的 unit 都是附挂在 multi-user.target 下

- Also：相依性 enable

  当前 unit 本身被 enable 时，Also 声明的 unit 也 enable

- Alias：别名

  当 systemctl enable 相关的服务时，此服务会进行连接文件的建立，以 `multi-user.target` 为例，它是用来预设操作环境 default.target 的规划，因此当设置用 default.target 时， `/etc/systed/system/default.target` 就会连结到 `/usr/lib/systemd/system/multi-user.target`

配置讲解之后，下面用这些知识点来练习

## 两个 vsftpd 运行的实例

在上一章将 vsftpd 的 port 修改成了 555。这里再运行一个端口为 21 的 vsftpd 程序，需要两个配置文件以及两个启动脚本来设置了：

- port 21:
  - `/etc/vsftpd/vsftpd.conf` 配置文件
  - `/usr/lib/systemd/system/vsftpd.service` 启动脚本
- port 555:
  - `/etc/vsftpd/vsftpd2.conf` 配置文件
  - `/usr/lib/systemd/system/vsftpd2.service` 启动脚本

```bash
# 1. 建立好需要的配置文件
[root@study ~]# cd /etc/vsftpd/
[root@study vsftpd]# ll
total 20
-rw-------. 1 root root  125 Oct 31  2018 ftpusers
-rw-------. 1 root root  361 Mar 17 21:59 user_list
-rw-------. 1 root root 5199 Mar 17 23:02 vsftpd.conf
-rwxr--r--. 1 root root  338 Oct 31  2018 vsftpd_conf_migrate.sh
[root@study vsftpd]# cp vsftpd.conf vsftpd2.conf
[root@study vsftpd]# vim vsftpd.conf
# listen_port=555
# 把端口注释掉，他默认的端口是 21.
[root@study vsftpd]# diff vsftpd.conf vsftpd2.conf
131c131
< # listen_port=555
---
> listen_port=555
# 通过对比，两个文件只有端口号不同

# 2. 开始处理启动脚本设置
[root@study vsftpd]# cd /etc/systemd/system/
[root@study system]# ll | grep vsftp
# 由于我们没有额外修改过启动脚本，所以该目录下是没有 vsftp 相关的脚本的
# 从原始的启动脚本目录复制一份过来
[root@study system]# cp /usr/lib/systemd/system/vsftpd.service vsftpd2.service
[root@study system]# vim vsftpd2.service
[Unit]
Description=Vsftpd2 ftp daemon
After=network.target

[Service]
Type=forking
ExecStart=/usr/sbin/vsftpd /etc/vsftpd/vsftpd2.conf

[Install]
WantedBy=multi-user.target
# 重点只是修改 ExecStart 后面的配置文件

# 3. 重新加载 systemd 的脚本配置文件内容
# systemctl daemon-reload
[root@study system]# systemctl list-unit-files --all | grep vsftpd
vsftpd.service                                enabled
vsftpd2.service                               disabled		# 已经能找到了
vsftpd@.service                               disabled
vsftpd.target                                 disabled
[root@study system]# systemctl status vsftpd2.service
* vsftpd2.service - Vsftpd2 ftp daemon
   Loaded: loaded (/etc/systemd/system/vsftpd2.service; disabled; vendor preset: disabled)
   Active: inactive (dead)

# 由于之前直接修改的 vsftp 的配置文件，所以 vsftp 也需要重新启动
[root@study system]# systemctl restart vsftpd.service vsftpd2.service
[root@study system]# systemctl enable vsftpd.service vsftpd2.service
Created symlink from /etc/systemd/system/multi-user.target.wants/vsftpd2.service to /etc/systemd/system/vsftpd2.service.
[root@study system]# systemctl status vsftpd.service vsftpd2.service
* vsftpd.service - Vsftpd ftp daemon
   Loaded: loaded (/usr/lib/systemd/system/vsftpd.service; enabled; vendor preset: disabled)
   Active: active (running) since Thu 2020-03-19 16:50:22 CST; 27s ago
 Main PID: 5986 (vsftpd)
   CGroup: /system.slice/vsftpd.service
           `-5986 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf

Mar 19 16:50:22 study.centos.mrcode systemd[1]: Stopped Vsftpd ftp daemon.
Mar 19 16:50:22 study.centos.mrcode systemd[1]: Starting Vsftpd ftp daemon...
Mar 19 16:50:22 study.centos.mrcode systemd[1]: Started Vsftpd ftp daemon.

* vsftpd2.service - Vsftpd2 ftp daemon
   Loaded: loaded (/etc/systemd/system/vsftpd2.service; enabled; vendor preset: disabled)
   Active: active (running) since Thu 2020-03-19 16:50:22 CST; 27s ago
 Main PID: 5987 (vsftpd)
   CGroup: /system.slice/vsftpd2.service
           `-5987 /usr/sbin/vsftpd /etc/vsftpd/vsftpd2.conf

Mar 19 16:50:22 study.centos.mrcode systemd[1]: Stopped Vsftpd2 ftp daemon.
Mar 19 16:50:22 study.centos.mrcode systemd[1]: Starting Vsftpd2 ftp daemon...
Mar 19 16:50:22 study.centos.mrcode systemd[1]: Started Vsftpd2 ftp daemon.

[root@study system]# netstat -tlnp | grep vsftp
tcp6       0      0 :::555                  :::*                    LISTEN      5987/vsftpd         
tcp6       0      0 :::21                   :::*                    LISTEN      5986/vsftpd
```

这样一个启动脚本的完成了

## 多重的重复设置方式：以 getty 为例

CentOS 7 开机后，有 6 个终端机可以使用（tty1 ~ tty6），是由 agetty 指令搞定的。终端机的功能涉及很多层面，主要管理的是 getty.target 这个 target unit，实际产生 tty1~tty6 的则是由 getty@.service 所提供的。

通过这个 getty@.service  的启动脚本来获取 @ 是啥含义

```bash
[root@study system]# cat /usr/lib/systemd/system/getty@.service
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Getty on %I
Documentation=man:agetty(8) man:systemd-getty-generator(8)
Documentation=http://0pointer.de/blog/projects/serial-console.html
After=systemd-user-sessions.service plymouth-quit-wait.service getty-pre.target
After=rc-local.service

# If additional gettys are spawned during boot then we should make
# sure that this is synchronized before getty.target, even though
# getty.target didn't actually pull it in.
Before=getty.target
IgnoreOnIsolate=yes

# On systems without virtual consoles, don't start any getty. Note
# that serial gettys are covered by serial-getty@.service, not this
# unit.
ConditionPathExists=/dev/tty0

[Service]
# the VT is cleared by TTYVTDisallocate
ExecStart=-/sbin/agetty --noclear %I $TERM
Type=idle
Restart=always
RestartSec=0
UtmpIdentifier=%I
TTYPath=/dev/%I
TTYReset=yes
TTYVHangup=yes
TTYVTDisallocate=yes
KillMode=process
IgnoreSIGPIPE=no
SendSIGHUP=yes

# Unset locale for the console getty since the console has problems
# displaying some internationalized messages.
Environment=LANG= LANGUAGE= LC_CTYPE= LC_NUMERIC= LC_TIME= LC_COLLATE= LC_MONETARY= LC_MESSAGES= LC_PAPER= LC_NAME= LC_ADDRESS= LC_TELEPHONE= LC_MEASUREMENT= LC_IDENTIFICATION=

[Install]
WantedBy=getty.target
DefaultInstance=tty1

```

重要项： ExecStart，通过  man agetty 时发现它的语法应该是 `agetty --noclear tty1` （笔者没有看懂里面哪里写的有这个，内容有点多），那么启动 6 个的话，就需要有 6 个 启动配置来分别配置启动指令 tty1~tty6，是在很繁琐，这就出现了 `getty@.service` 中的  @ 。先来看看他的上游 `Before=getty.target`

```bash
[root@study system]# systemctl show getty.target
Id=getty.target
Names=getty.target
Wants=getty@tty1.service
WantedBy=multi-user.target
Conflicts=shutdown.target
Before=multi-user.target
After=getty@tty1.service
# 这里，笔者的环境上与书上不一致了，书上是 getty@tty1.service getty@tty2.service 等 6 个
# 注意，这里笔者发现了为什么不一样
# cat /usr/lib/systemd/system/getty.target 里面内容很少，没有上面这些定义
# 但是用 show 可以显示出来，这个书上目前没有讲解
# 但是，通过切换到 tty2 tty3 上去的时候，使用  systemctl show getty.target 查看状态时，After 后面就会出现已经切换过之后的 tty。和书上展示是一样的效果
```

书上说，上面的 After 的配置，当 执行完 getty.target 之后，会持续要求 getty@tty1.service  等 6 个服务继续启动。那么 systemd 就会如下做：

- 先查找 `/usr/lib/systemd/system/`、`/etc/systemd/system/` 有无 `getty@tty1.service` 的设置，若有就启动，没有则执行下一步
- 找到 `getty@.service` 的设置，则将 @ 后面的数据代入成 `%I` 的变量，进入 gett@.service 执行

也就是说 `getty@tty1.service` 实际上是不存在的，主要是通过 `getty@.service` 来执行，来简化多个执行的启动设置，他的命名方式如下：

- 源文件：执行服务名称@.service
- 执行文件：执行服务名称@范例名称.service

`getty@.service` 中的启动指令`ExecStart=-/sbin/agetty --noclear %I $TERM`，根据 getty.target 的信息输出来看，`getty@tty1.service` 的 `%I` 的值是 tty1，因此执行脚本会变成 `/sbin/agetty --noclear tty1`

### 将 tty 的数量由 6 个降低到 4 个

这个配置是在 `/etc/systemd/logind.conf` 里面配置的。

```bash
# 1. 打开注释信息，并修改成 4 个
[root@study system]# vim /etc/systemd/logind.conf
[Login]
NAutoVTs=4
ReserveVT=0
# 2. 如果你切换到 tty5 和 tty6 的话，请将他们关闭后重启 getty.target
[root@study ~]# systemctl stop getty@tty5.service
[root@study ~]# systemctl stop getty@tty6.service
[root@study ~]# systemctl restart systemd-logind.service
```

当你回到桌面环境下，再切换到 tty5 和 tty6 时就切换不过去了。

到这里笔者貌似迷糊了，getty.target 只是一个定义，类似组，里面并没有定义什么，被其他的 unit 附加。有点不太明白和这里启动 1~6 个有什么关系？这里启动的是  systemd-logind.service ，而且切换只能在桌面环境下，也就是说 tty1~tty6 的切换是这个指令的功能，只是实际启动时用 getty@.service 启动的。但是具体怎么关联上的，是在是迷糊，看不懂

那么其实可以通过指令方式直接启动一个 tty。而无需其他的配置文件

```bash
systemctl start getty@tty8.service
```

如果只单独看这里的演示的话，笔者能明白的就是 getty@.service 是一个功能，可以通过 @ 传递参数给服务

### 暂时新增 vsftpd 到 2121 端口

vsftpd 也提供了 @ 的服务方式

```bash
[root@study ~]# ll /usr/lib/systemd/system | grep vsftpd
-rw-r--r--. 1 root root  171 Oct 31  2018 vsftpd.service
-rw-r--r--. 1 root root   89 Oct 31  2018 vsftpd.target
-rw-r--r--. 1 root root  184 Oct 31  2018 vsftpd@.service		# 这里
```

```bash
[root@study ~]# cat /usr/lib/systemd/system/vsftpd@.service
[Unit]
Description=Vsftpd ftp daemon
After=network.target
PartOf=vsftpd.target

[Service]
Type=forking
ExecStart=/usr/sbin/vsftpd /etc/vsftpd/%i.conf

[Install]
WantedBy=vsftpd.target
```

这里使用了 `%i`，也就是说大小写的的变量都可以，这里启动指令拼接了一个配置文件路径 `/etc/vsftpd/%i.conf`

那么先创建这个配置文件，然后通过 @ 方式启动

```bash
# 1. 制作一个 vsftpd3.conf ，并吧端口修改为 2121
[root@study ~]# cd /etc/vsftpd/    
[root@study vsftpd]# ll
total 28
-rw-------. 1 root root  125 Oct 31  2018 ftpusers
-rw-------. 1 root root  361 Mar 17 21:59 user_list
-rw-------. 1 root root 5201 Mar 19 16:35 vsftpd.conf
-rw-------. 1 root root 5199 Mar 19 16:35 vsftpd2.conf
-rwxr--r--. 1 root root  338 Oct 31  2018 vsftpd_conf_migrate.sh
[root@study vsftpd]# cp vsftpd.conf vsftpd3.conf
[root@study vsftpd]# vim vsftpd3.conf
listen_port=2121

# 2. 暂时启动，不要开机启动
[root@study vsftpd]# systemctl start vsftpd@vsftpd3.service
[root@study vsftpd]# systemctl status vsftpd@vsftpd3.service
* vsftpd@vsftpd3.service - Vsftpd ftp daemon
   Loaded: loaded (/usr/lib/systemd/system/vsftpd@.service; disabled; vendor preset: disabled)
   Active: active (running) since Thu 2020-03-19 17:48:57 CST; 5s ago
  Process: 7536 ExecStart=/usr/sbin/vsftpd /etc/vsftpd/%i.conf (code=exited, status=0/SUCCESS)
 Main PID: 7538 (vsftpd)
   CGroup: /system.slice/system-vsftpd.slice/vsftpd@vsftpd3.service
           `-7538 /usr/sbin/vsftpd /etc/vsftpd/vsftpd3.conf

Mar 19 17:48:57 study.centos.mrcode systemd[1]: Starting Vsftpd ftp daemon...
Mar 19 17:48:57 study.centos.mrcode systemd[1]: Started Vsftpd ftp daemon.

[root@study vsftpd]# netstat -tlnp | grep vsftpd
tcp6       0      0 :::2121                 :::*                    LISTEN      7538/vsftpd         
tcp6       0      0 :::555                  :::*                    LISTEN      5987/vsftpd         
tcp6       0      0 :::21                   :::*                    LISTEN      5986/vsftpd
```

可以看到通过这种 @ 的方式，能让我们制作启动脚本的时候更为灵活一点

::: tip
 有一件事情，这次使用了 2121 端口，却不用修改 SELinux？因为默认启动小于 1024 以下的端口时，需要使用到 root 的权限，大于 2014 的相对来说对系统的影响可能小一些，就忽略了 SELinux 的限制了

笔者看这句话，貌似记不起有关 SELinux 端口限制的知识了？懵逼状态
:::



## 自己的服务自己做

下面模拟自己做一个服务：制作一个可以备份自己系统的服务，这脚本放在 `/backups` 下，内容如下

```bash
[root@study ~]# mkdir /backups		# 下面脚本，上层目录不存在，都无法保存的
[root@study ~]# vim /backups/backup.sh
#!/bin/bash

source="/etc /home /root /var/lib /var/spool/{cron,at,mail}"
target="/backups/backup-system-$(date +%Y-%m-%d).tar.gz"

[ ! -d /backups ] && mkdir /backups

tar -zcvf ${target} ${source} $> /backups/backup.log

[root@study ~]# chmod a+x /backups/backup.sh
[root@study ~]# ll /backups/backup.sh
-rwxr-xr-x. 1 root root 222 Mar 20 09:24 /backups/backup.sh
```

准备 backup.service 的启动脚本

```bash
[root@study ~]# vim /etc/systemd/system/backup.service
[unit]
Description=backup my server
Requires=atd.service

[Service]
Type=simple
ExecStart=/bin/bash -c " echo /backups/backup.sh | at now"

[Install]
WantedBy=multi-user.target

# 因为 ExecStart 里面用到了 at 指令，因此 atd.service 是一定需要的服务

[root@study ~]# systemctl daemon-reload
[root@study ~]# systemctl start backup.service
[root@study ~]# systemctl status backup.service
* backup.service - backup my server
   Loaded: loaded (/etc/systemd/system/backup.service; disabled; vendor preset: disabled)
   Active: inactive (dead)

Mar 20 09:30:56 study.centos.mrcode systemd[1]: Started backup my server.
Mar 20 09:30:56 study.centos.mrcode bash[17748]: job 8 at Fri Mar 20 09:30:00 2020

# 可以看到服务在执行了，状态是 inactive ，这不是一个驻留内存的服务，执行完成就退出了
# 这里笔者看不懂为啥用 echo /backups/backup.sh | at now； 而不是直接直接给定脚本路径，而且貌似脚本里面的内容执行也有问题
```

## systemctl 针对 timer 的配置文件

某些时候需要定期执行某项工作，或则是开机后执行，或则是某服务启动多久后执行等等的需求。在以前可以使用 crond 来定期处理，如今有 systemd 这个长期驻留在内存中好用的服务，另外还提供了一个协力服务 timers.target ，它可以协助定期处理各种任务

## systemd.timer 的优势

在 archlinux 的官网 wiki 上有提到，为啥要用 systemd.timer ?

- 由于所有的 systemd 的服务产生的信息都会被记录（log），因此比 crond 在 debug 上要更清楚方便
- 各项 timer 的工作可以跟 systemd 的服务相结合
- 各项 timer 的工作可以跟 control group（cgroup 用来取代 /etc/secure/limit.conf 的功能）结合，来限制该工作的资源利用
- 时间安排可以精确到毫秒的单位

弱点就是：没有 email 通知功能（除非自己实现 email 通知），也没有类似 anacron 一段时间内的随机取样功能（random_delay）

## 任务需求

想要用 systemd 的 timer 功能，必须有如下条件：

- 系统的 timer.target 必须启动
- 要有 sname.service 的服务存在：sname 是我们自定义的名称
- 要有 sname.timer 的时间启动服务存在

使用前一小节写好的  backup.service 来测试

## sname.timer 的设置

`[Timer]` 部分

- OnActiveSec：当 timers.target 启动多久后才执行该 unit

- OnBootSec：当开机后多久之后才执行

- OnStartupSec：当 systemd 第一次启动后多久才执行

- OnUnitActiveSec：这个 timer 配置文件所管理的那个 unit 服务在最后一次启动后，相隔多久后再执行一次

- OnUnitInactiveSec：这个 timer 配置文件所管理的那个 unit 服务在最后一次停止后，隔多久再执行一次

- OnCalendar：使用实际时间（非循环时间）的方式来启动服务。时间格式后续讲解

- Unit：

  一般来说不太需要设置，当你的 sname.service 与 sname.timer 中的 sname 不一致时，这里指向的 service unit

- Persistent

  当使用 OnCalendar 的设置时，指定该功能要不要持续进行。通常设置为 yes，比较能满足类似 anacron 的功能

## 使用 OnCalendar 的时间

想要从 crontab 转成 timer 的功能，对于时间格式需要了解，基本上的格式如下

```bash
语法：英文周名 YYYY-MM-DD HH:MM:SS
范例：Thu	  2020-03-20 10:00:00
```

也可以使用时间间隔时间来处理，常用的时间间隔单位有：

- us 或 usec：微秒
- ms 或 msec：毫秒
- s、sec、second、seconds
- m、min、minute、minutes
- h、hr、hour、hours
- d、day、days
- w、week、weeks
- month、months
- y、year、years

常见的范例有

```bash
隔 3 小时：				3h 或 3hr 或 3hours
隔 300 分钟过 10 秒：	   10s 300m	
隔 5 天又 100 分钟：	   100m 5day
# 通常英文的写法：小单位写在前面，大单位写后面、先秒、分、小时、天等
```

此外，还可以使用英文常用的口语化日期代表，例如 today、tomorrow 等，假设今天是 2015-08-13 13:50:00 那么

- now：Thu 2015-08-13 13:50:00
- today：Thu 2015-08-13 00:00:00
- tomorrow：Thu 2015-08-14 00:00:00
- hourly：`*-*-* *:00:00`
- daily：`*-*-* 00:00:00`
- weekly：`Mon *-*-* 00:00:00`
- monthly：`*-*-01 00:00:00`
- +3h10m：Thu 2015-08-13 17:00:00
- 2015-08-16：Sun 2015-08-16 00:00:00

## 一个循环时间运行的案例

需求如下：

- 开机后 2 小时开始执行一次  backup.service
- 自从第一次执行后，未来每两天执行一次 backup.service

```bash
[root@study ~]# vim /etc/systemd/system/backup.timer
[Unit]
Description=backup my server timer

[Timer]
OnBootSec=2hrs
OnUnitActiveSec=2days

[Install]
WantedBy=multi-user.target

[root@study ~]# systemctl daemon-reload 
[root@study ~]# systemctl enable backup.timer
Created symlink from /etc/systemd/system/multi-user.target.wants/backup.timer to /etc/systemd/system/backup.timer.
[root@study ~]# systemctl restart backup.timer    
[root@study ~]# systemctl list-unit-files | grep backup
backup.service                                disabled		# 只需要 timer 启动就 ok
backup.timer                                  enabled

[root@study ~]# systemctl show timers.target 
ConditionTimestamp=Tue 2020-03-17 10:49:38 CST		# timer 这个 unit 启动的时间

[root@study ~]# systemctl show backup.service | grep ExecMainStartTimestamp
ExecMainStartTimestamp=Fri 2020-03-20 09:38:19 CST	# backup.service 上一次执行的时间

[root@study ~]# systemctl show backup.timer | grep NextElapseUSecMonotonic 
NextElapseUSecMonotonic=4d 22h 48min 56.756775s		# 下一次执行距离 timers.target 的时间
```

关于这个 NextElapseUSecMonotonic 值得说明，上次执行 backup.service 的时间在 2020-03-20 09:38:19，由于 2 天执行一次，下一次执行时间应该是 2020-03-22 09:38:19 才对，但是由于 timer 是由 timers.target 这个 unit 所管理的，而这个 timers.target 启动时间是在 2020-03-17 10:49:38，注意的是，这个 NextElapseUSecMonotonic  记录的下次运行的时间，其实是与 timers.target 所记录的时间差，因此是 `2020-03-22 09:38:19 -`  2020-03-17 10:49:38` 结果就是相差 4d 22h 48min;

计算公式：NextElapseUSecMonotonic  = 实际下一次运行的时间 - timers.target 的启动时间



## 一个固定日期运行的案例

```bash
[root@study ~]# vim /etc/systemd/system/backup2.timer
[Unit]
Description=backup my server timer2

[Timer]
OnCalendar=Sun *-*-* 02:00:00
Persistent=true
Unit=backup.service		# 这里的 timer 名称与原来的 service 不一致，这里指定下

[Install]
WantedBy=multi-user.target

[root@study ~]# systemctl daemon-reload
[root@study ~]# systemctl enable backup2.timer
Created symlink from /etc/systemd/system/multi-user.target.wants/backup2.timer to /etc/systemd/system/backup2.timer.
[root@study ~]# systemctl restart backup2.timer 
[root@study ~]# systemctl list-unit-files | grep backup
backup.service                                disabled
backup.timer                                  enabled 
backup2.timer                                 enabled 
[root@study ~]# systemctl show timers.target | grep ConditionTimestamp
ConditionTimestamp=Tue 2020-03-17 10:49:38 CST
ConditionTimestampMonotonic=15862087
[root@study ~]#  systemctl show backup.service | grep ExecMainStartTimestamp
ExecMainStartTimestamp=Fri 2020-03-20 09:38:19 CST
ExecMainStartTimestampMonotonic=254936756737
[root@study ~]# systemctl show backup2.timer | grep NextElapseUSecRealtime
NextElapseUSecRealtime=50y 2month 2w 5d 9h
# 由于只有一次运行，所以没有 NextElapseUSecMonotonic 值了。
# 这里的时间是 Unix 标准时间，也就是是 1970-01-01 00:00:00 去比较的
# 这里是 50 年 2个月 2周 5天 9小时才会执行，这个是对比的日历时间（1970-01-01 00:00:00）
# 时间的基准值不一样。一定要注意
```

## CentOS 7.x 预设启动的服务简易说明

软件很多，无法介绍完所有的，这里仅介绍几个很常见的 daemons。其他的可以使用 `systemctl list-unit-files --type=service` 去查询

下面的建议是针对 Linux 单机服务器的角色来说的，不是桌上型的环境

- abrtd：

  （系统）abrtd 服务可以提供使用者一些方式，让使用者可以针对不同的应用软件去设计错误登录的机制，当软件产生问题时，用户可以根据 abrtd 的登录档来进行错误克服的行为。还有其他的 abrt-xxx.service 均是使用该服务来加强应用程序的 debug 任务的

- accounts-daemon：可关闭

  （系统）使用 accountsservice 计划所提供的一系列 D-Bus 界面来进行使用者账户信息的查询。基本上是与 useradd、usermod、userdel 等软件有关

- alsa-x：可关闭

  （系统）开头为 alsa 的服务有不少，这些服务大部分都与音效有关。一般来说，服务器不开图形界面的话，都可以关闭

- atd：

  （系统）单一的例行性工作排程，请参考第 15 章，抵挡机制的配置文件在 `/etc/at.{allow,deny}`

- auditd：

  （系统）可以让 SELinux 的稽核信息写入 `/var/log/audit/audit.log` 中

- avahi-daemon：可关闭

  （系统）客户端无法，可以通过 Zeroconf 自动的分析与管理网络。Zeroconf 常用在笔记本电脑与行动装置上

- `brandbot-rhel-*`：

  （系统）大多用于开机过程中所需要的各种侦测环境的脚本，同时也提供网络界面的启动与关闭

- `chronyd ntpd ntpdate`：

  （系统）网络校正时间服务，一般来说，你可能需要的只有 chronyd

- cpupower：

  （系统）提供 CPU 的运行规范。可参考 `/etc/sysconfig/cpupower` 的信息

- cups：可关闭

  （系统/网络）用来管理打印机的服务，可以提供网络联机的功能，类似打印服务器的功能，可以在 Linux 本机上面浏览 http://localhost:631 来管理打印机

- dbus：

  （系统）使用 D-Bus 的方式在不同的应用程序之间传送信息，使用的方向列入应用程序间的信息传递、每个用户登录时提供的信息数据等

- dm- event  multipathd：

  （系统）监控设置对应表（device mapper）的主要服务，如果关掉，就无法让 Linux 使用外围设备和存储设备了

- dmraid-activation mdmonitor：

  （系统）用来启动 Softwar RAID 的重要服务

- dracut-shutdown：

  （系统）用来处理 initramfs 的相关行为，与开机流程相关性较高

- ebtables

  （系统/网络）通过类似 iptables 这种防火墙规则的设置方式，设计网络卡作为桥接时的封包分析政策。其实就是防火墙，不过与下面说到的防火墙不太一样，如果没有使用虚拟化，或则启用了 firewalld，这个服务可以不启动

- emergency rescue：

  （系统）进入紧急模式或则是救援模式的服务

- firewalld：

  （系统/网络）防火墙，以前有 iptables 与 ip6tables 等防火墙机制，新的 firewalld 搭配 firewall-cmd 指令，可以快速建立好防火墙系统，因此 CentOS 7.1 之后，iptables 服务的启动脚本已经被忽略了，请使用 firewalld 来取代 iptables

- gdm：

  （系统）GNOME 的登录管理员，就是图形界面上一个很重要的登录管理服务

- getty@：

  （系统）在本机能产生几个文字界面 tty 登录的服务

- `hyper* ksm* libvirrt* vmtoolsd`:

  （系统）建立虚拟机有关的许多服务，如果不玩虚拟机就可以关闭。这些服务时让实体机器来建立虚拟机的

- irqbalance：

  （系统）如果系统是多核心的硬件，那么该服务需要启动，可以自动的分配系统中断（IRQ）之类的硬件资源

- `iscsi*`

  （系统）可以关注来自网络驱动器机的服务。可以在系统内仿真好贵的 SAN 网络驱动器。如果确定没有挂载这种网络驱动器，也可以关闭

- kdump：可关闭

  （系统）在安装 CentOS 章节讲过，主要是 Linux 核心如果出错时，用来记录内存的东西。可以不启用，除非你是核心黑客

- `lvm2-*`:

  （系统）与 LVM 相关性较高的许多服务，不能关闭

- microcode：

  （系统）Intel 的 CPU 会提供一个外挂的微指令集提供系统运行，如果没有下载 Intel 相关的指令文件，就不需要启动

- ModemManager network NetworkManager*：

  （系统/网络）主要是调制调节器、网络设置等服务、进入 CentOS 7 之后，系统似乎不太希望我们使用 network 服务了，比较建议的使用 networkManager 搭配 nmcli 指令来处理网络设置。NetworkManager 要开，而 network 不用开

- quotaon：

  （系统）启动 Quota 要用到的服务

- rc-local：

  （系统）兼容与 `/etc/rc.d/rc.local` 的调用方式，只是要让 `/etc/rc.d/rc.local` 具有 x 的权限后，该服务才能真的运行，否则写目录的脚本还是不会运行

- rsyslog：

  （系统）可以记录系统所产生的各项信息，包括 `/var/log/messages` 内几个重要的日志

- smartd：

  （系统）可以自动的侦测硬盘的状态，如果硬盘发生问题，还可以自动的回报给系统管理员，很重要，不要关闭

- sysstat

  （系统）我们的系统有个名为 sar 的指令会记载某些时间点下，系统的资源使用情况，包括 CPU、流量、输入输出量等，当 systat 服务启动后，这些记录的数据才能写入到记录文件 log 中去

- `systemd-*`

  （系统）大概都是属于系统运行过程中所需要的服务，没有必要不要去动他们

- `plymount* upower`

  （系统）与图形界面的使用相关性较高，没启动图形界面时，可以暂时不管他们

如上是 CentOS 7.x 预设启动的，很多是针对桌面计算机所设计的，所以在优化时要注意他们的功能

下面一些无法可能在你的系统中的服务，但是预设没有启动。只是简介，具体的需要自行查询相关文件

- dovecot:

  （网络）可以设置 POP3/IMAP 等收信服务，如果你的主机是 email server 才需要这个服务

- httpd：

  （网络）可以让你的 LInux 服务成为 www server

- named

  （网络）领域域名服务器（Domain Name System）的服务，非常重要，但是设置非常困难

- nfs nfs-server

  （网络）Network Filesystem，是 Unix-Like 之间互相作为网络驱动器的一个功能

- smb nmb

  （网络）可以让 Linux 仿真为 windows 上面的网络邻居。如果 Linux 主机想要作为 windows 客户端的网络驱动器服务器，就可以玩玩这个

- vsftpd

  （网络）作为文件传输服务器 FTP 的服务

- sshd

  （网络）远程联机服务器的软件功能，该通信协议比 telnet 好的地方在于 sshd 在传送资源时可以进行加密

- rpcbind

  （网络）达成 RPC 协议的重要服务，包括 NFS、NIS 等等都需要它

- postfix

  （网络）寄件的邮件主机，因为系统会产生很多的 email 信息，例如  crond、atd 就会发送 email 给本机用户，即使你不是 mail server 也是要启动该服务的


## 重点回顾

- 早期的服务管理使用 systemV 机制，通过  `/etc/init.d/*`、service、chkconfig、setup 等指令来管理服务的启动、关于、开机启动
- 从 CentOS 7.x 开始，采用 systemd 的机制，此机制最大功能为并行处理，并使用单一指令 systemctl 管理，开机速度加快
- systemd 将各服务定义为 unit，细分为 service、socket、target、path、timer 等不同的类型，方便管理与维护
- 启动、关闭、重新启动的方式为：`systemctl [start|top|restart] unit.service`
- 设置开启启动/取消开机启动的方式为：`systemctl [enable|disable] unit.service`
- 查询系统所有启动的服务用 `systemctl list-units --type=service` 查询所有服务（包含不启动）使用 `systemctl list-units-files --type=service`
- systemd 取消了以前的 runlevel 概念（虽然还有有兼容的 target），转而使用不同的 target 操作环境。常见操作环境为 `multi-user.target` 与 `graphical.target`。 
  - 不重新启动切换操作环境使用 `systemctl isolate unit.target` 。
  - 设置默认操作环境使用 `systemctl set-default unit.target`
- systemctl 系统默认的配置文件主要在 `/usr/lib/systemd/system` ，需要修改或添加自行设计时，则建议放在 `/etc/systemd/system` 目录下
- 管理员应使用 `man systemd.unit、man systemd.service、man systemd.timer` 查询 `/etc/systemd/system/` 下配置文件的语法，并使用 `systemctl daemon-reload` 让配置文件生效
- 除了 atd 与 crond 之外，还可以通过 systemd.timer （timers.target）的功能，来使用 systemd 的时间管理功能
- 一些不需要的服务可以关闭


## 本章习题

## 情景模拟题

通过设置、启动、观察等机制，完整了解一个服务的启动与观察

- 目标：了解 daemon 的管控机制，以 sshd daemon 为例
- 前提：需要对本章已经了解，尤其是 systemd 的管理部分
- 需求：已经有 sshd 这个服务，但是没有修改过端口

启动两个 sshd 服务，另一个一个使用端口 222

```bash
# 1. 查看 sshd 服务是否存在
[root@study ~]# systemctl status sshd.service 
* sshd.service - OpenSSH server daemon
   Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)
   Active: active (running) since Tue 2020-03-17 10:49:56 CST; 3 days ago
     Docs: man:sshd(8)
           man:sshd_config(5)
 Main PID: 1378 (sshd)
    Tasks: 1
   CGroup: /system.slice/sshd.service
           `-1378 /usr/sbin/sshd -D

Mar 17 10:49:55 study.centos.mrcode systemd[1]: Starting OpenSSH server daemon...
Mar 17 10:49:56 study.centos.mrcode sshd[1378]: Server listening on 0.0.0.0 port 22.
Mar 17 10:49:56 study.centos.mrcode sshd[1378]: Server listening on :: port 22.
Mar 17 10:49:56 study.centos.mrcode systemd[1]: Started OpenSSH server daemon.
Mar 17 10:51:42 study.centos.mrcode sshd[2344]: Accepted password for mrcode from 192.168.4.170 port 60750 ssh2
Mar 17 17:35:40 study.centos.mrcode sshd[7250]: Accepted password for ftptest from 192.168.4.170 port 59071 ssh2
Mar 17 22:22:50 study.centos.mrcode sshd[10579]: Accepted password for root from 192.168.4.170 port 59851 ssh2

# 查看他的启动脚本文件
[root@study ~]# cat /usr/lib/systemd/system/sshd.service
[Unit]
Description=OpenSSH server daemon
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target sshd-keygen.service
Wants=sshd-keygen.service

[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/sshd
ExecStart=/usr/sbin/sshd -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target

# 通过 man ssshd 中的 FILES 信息中，找到了他的配置文件地址
/etc/ssh/sshd_config
             Contains configuration data for sshd.  The file format and configuration options are described in sshd_config(5).

# 2. 复制该配置文件，并修改端口号为 222
[root@study ~]# cd /etc/ssh/
[root@study ssh]# cp sshd_config sshd2_config
[root@study ssh]# vim sshd2_config
Port 222

# 3. 修改启动脚本等文件
[root@study ssh]# cd /etc/systemd/system/
[root@study system]# cp /usr/lib/systemd/system/sshd.service sshd2.service
[root@study system]# vim sshd2.service
[Unit]
Description=OpenSSH server daemon 2
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target sshd-keygen.service
Wants=sshd-keygen.service

[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/sshd
# 主要是这里
ExecStart=/usr/sbin/sshd -f /etc/ssh/sshd2_config -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target
# 上述增加了 -f 参数指定了刚刚我们复制出来的配置文件
# 该语法是从这个脚本中的 Documentation=man:sshd(8)，然后使用 man 8 sshd 资料中 SYNOPSIS 中的  [-f config_file] 得知，可以指定一个配置文件
# 所以，其实这一步应该在最开始的时候去查阅，然后才是来达成这个配置文件的操作

# 4. 重新加载配置与这个服务的启动等观察
[root@study system]# systemctl daemon-reload 
[root@study system]# systemctl enable sshd2.service 
Created symlink from /etc/systemd/system/multi-user.target.wants/sshd2.service to /etc/systemd/system/sshd2.service.
[root@study system]# systemctl start sshd2.service  
Job for sshd2.service failed because the control process exited with error code. See "systemctl status sshd2.service" and "journalctl -xe" for details.
[root@study system]# systemctl status sshd2.service 
* sshd2.service - OpenSSH server daemon 2
   Loaded: loaded (/etc/systemd/system/sshd2.service; enabled; vendor preset: disabled)
   Active: activating (auto-restart) (Result: exit-code) since Fri 2020-03-20 14:04:25 CST; 12s ago
     Docs: man:sshd(8)
           man:sshd_config(5)
  Process: 21511 ExecStart=/usr/sbin/sshd -f /etc/ssh/sshd2_config -D $OPTIONS (code=exited, status=255)
 Main PID: 21511 (code=exited, status=255)

Mar 20 14:04:25 study.centos.mrcode systemd[1]: sshd2.service: main process exited, code=exited, status=255/n/a
Mar 20 14:04:25 study.centos.mrcode systemd[1]: Failed to start OpenSSH server daemon 2.
Mar 20 14:04:25 study.centos.mrcode systemd[1]: Unit sshd2.service entered failed state.
Mar 20 14:04:25 study.centos.mrcode systemd[1]: sshd2.service failed.

# 发现没有启动起来，启动失败了，去观察他的日志记录
[root@study system]# tail -n 20 /var/log/messages
Mar 20 14:05:08 study python: SELinux is preventing /usr/sbin/sshd from name_bind access on the tcp_socket port 222.#012#012*****  Plugin bind_ports (99.5 confidence) suggests   ************************#012#012If you want to allow /usr/sbin/sshd to bind to network port 222#012Then you need to modify the port type.#012Do#012# semanage port -a -t PORT_TYPE -p tcp 222#012    where PORT_TYPE is one of the following: ssh_port_t, vnc_port_t, xserver_port_t.#012#012*****  Plugin catchall (1.49 confidence) suggests   **************************#012#012If you believe that sshd should be allowed name_bind access on the port 222 tcp_socket by default.#012Then you should report this as a bug.#012You can generate a local policy module to allow this access.#012Do#012allow this access for now by executing:#012# ausearch -c 'sshd' --raw | audit2allow -M my-sshd#012# semodule -i my-sshd.pp#012

# 会发现触发了 SELInux ，没有通过检查， 99.5 的那个配置方案的解决告知我们需要执行
semanage port -a -t ssh_port_t -p tcp 222
[root@study system]# netstat -tlnp | grep ssh
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      2350/sshd: mrcode@p 
tcp        0      0 127.0.0.1:6011          0.0.0.0:*               LISTEN      10579/sshd: root@pt 
tcp        0      0 0.0.0.0:222             0.0.0.0:*               LISTEN      21918/sshd          
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1378/sshd           
tcp6       0      0 ::1:6010                :::*                    LISTEN      2350/sshd: mrcode@p 
tcp6       0      0 ::1:6011                :::*                    LISTEN      10579/sshd: root@pt 
tcp6       0      0 :::222                  :::*                    LISTEN      21918/sshd          
tcp6       0      0 :::22                   :::*                    LISTEN      1378/sshd

# 就会发现已经启动成功了
```

## 简单部分

- 使用 `netstat -tul` 与 `netstat -tunl` 有什么差别

  使用 n 时，netstat 不会使用主机名与服务名表示，而是以 IP 和 端口来显示。IP 的分析与 `/etc/hosts` 和 `/etc/resolv.conf` 有关，port 则与 `/etc/services` 有关

- 找到 port 3306 的端口号的服务是什么

  可以通过搜索 `/etc/services` 搜索到 3306 对应与 mysql 服务。

  并且通过 `netstat -tlnp | grep 3306` 的方式也能得到他的服务名称（如果运行中的话）

- 可以通过哪些指令查询到目前系统默认开机启动的服务

  `systemctl list-units` 和 `systemctl list-unit-files`

- 获取哪些服务在启动状态?

  通过上面查询出来的服务，应该使用 `systemctl status [unit.service]` 一项一项查询