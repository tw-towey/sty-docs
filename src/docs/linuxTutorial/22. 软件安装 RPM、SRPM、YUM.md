# 软件安装 RPM、SRPM、YUM

虽然使用源码进行软件编译可以具有定制化的设置，但是对于 Linux distribution 的发布商来说，则有软件管理不易的问题，毕竟不是每个人都会进行源码编译

如果能预先在相同的硬件与操作系统上编译好才发布的话，就可以让相同的 distribution 具有完全一致的软件版本了，再加上简易的安装、移除、管理等机制的话，对于软件管理就容易多了。

那么 RPM 与 YUM 就是实现这样的目标

## 软件管理员简介

上一章节讲过以源码方式，在实践过程中也发现了，有一定难度的，在安装、升级等方面都需要自己手动来管理，比较麻烦

## Linux 界的两大主流 RPM 与 DPKG

自由软件的蓬勃发展，各大 distribution 出现了，但是有一个很头疼的问题就是软件的管理，当软件有漏洞时，如何修补？使用 tarball 方式来管理？又常常不晓得我们安装过哪些程序，因此开始思考 Linux 的软件管理方式

Linux 开发商在固定的硬件平台与操作系统平台上面将需要安装或升级的软件编译好，然后将整个软件的所有相关文件打包为一个特殊格式的文件，在这个软件文件内还包含了预先检测系统与相依软件的脚本，并提供记载该软件提供的所有文件信息等。最终将该文件释出。**客户端取得这个文件后，只要通过特定的指令来安装，那么该软件文件就会依照内部的脚本检测相依的前驱软件是否存在，若安装的环境符合需求，那就开始安装**，安装完成后，还会将该软件的信息写入软件管理机制中，以达成未来可以进行升级、移除等动作

目前在 Linux 界软件安装方式最长久的有两种：

- dpkg

  最早由 Debian Linux 社群开发出来的，通过 dpkg 的机制，Debian 提供的软件就能够简单的安装起来。只要是衍生与 Debian 的其他 Linux distribution 大多使用 dpkg 这个机制来管理软件，包括 B2D、Ubuntu 等

- RPM

  最早由 Red Hat 公司开发出来的，后来实在很好用，因此很多 distribution 就使用该机制作为软件安装的管理方式。

不论 dpkg、rpm 这些机制都会涉及到软件相依的问题，每个软件文件都有提供相依属性的检查，如果将相依属性的数据做成列表，等到实际软件安装时，若有发生相依属性的软件状况时，管理机制自动去获取想依赖的软件同时安装

| distribution 代表 | 软件管理机制 |   使用指令    |  在线升级机制  |
| :---------------: | :----------: | :-----------: | :------------: |
|  Red Hat/Fedora   |     RPM      | rpm、rpmbuild |   YUM（yum）   |
|   Debian/Ubuntu   |     DPKG     |     dpkg      | APT（apt-get） |

## 什么是 RPM 与 SRPM

RPM 全名 RedHat Package Manager，是以一种数据库记录的方式将你所需要的软件安装到你的 Linux 系统的一套管理机制

最大的特点：将你要安装的软件先编译过，并且达成 RPM 机制的包装文件，通过包装文件里面的默认的数据库记录，记录这个软件要安装的时候必须具备的相依属性软件，当安装在你的 Linux 主机时，RPM 会先依照软件里的数据查询 Linux 主机的相依属性是否满足，若满足则安装，若不满足，则不安装。那么安装的时候就将该软件的信息整个写入 RPM 的数据库，以便未来的查询、验证与卸载，优点：

1. 不需要再重新编译：由于已经变异完成并且打包完毕，所以软件传输与安装上很方便
2. 由于软件的信息都已经记录在 Linux 主机的数据库上，很方便查询、升级与卸载

优点即缺点，由于软件已经事先编译好的，该软件几乎只能安装在原本默认的硬件与操作系统版本中。

所以，通常不同的 distribution 所释出的 RPM 文件，并不能用在其他的 distribution 上。因此可以发现这些软件管理机制的问题是：

1. 软件文件安装的环境必须与打包时的环境需求一致或相当
2. 需要满足软件的相依属性需求
3. 卸载时需要特别小心，最底层的软件不可以先移除，否则可能造成整个系统的问题

那怎么办？如果就要安装其他 distribution 提供的好用的 RPM 软件文件时，就可以使用 SRPM 。

SRPM：Source RPM，就是这个 RPM 文件里含有原码。特别注意，这个 SRPM 所提供的软件内容并没有经过编译，它提供的是源码

通常 SRPM 的扩展名是 `***.src.rpm` 格式来命名。它提供了参数配置文件（configure 与 makefile），所以安装 SRPM 的软件时，需要：

1. 先将该软件以 RPM 管理的方式编译，此时 SRPM 会被编译为 RPM 文件
2. 然后将编译完成的 RPM 文件安装到 LInux 系统中

他的好处就是，我们可以通过修改 SPRM 内的参数配置文件，然后重新编译产生能适合我们 Linux 环境的 RPM 文件。

| 文件格式 | 文件名格式 | 直接安装与否 | 内涵程序类型 | 可否修改参数并编译 |
| :------: | :--------: | :----------: | :----------: | :----------------: |
|   RPM    |   xx.rpm   |      可      |    已编译    |        不可        |
|   SRPM   | xx.src.rpm |     不可     |  未编译源码  |        可以        |

## 什么是 i386、i586、i686、noarch、x86_64

从上面我们可以知道，RPM 与 SRPM 的格式为

```bash
xx.rpm					# RPM 格式，已经经过编译且包装完成的 rpm 文件
xxx.src.rpm			# SRPM 格式，包含未编译的源码信息
```

可以通过文件名知道这个软件的版本、适用的平台、编译输出的次数，比如 `rp-pppoe-3.11-5.e17.x86_64.rpm`

```bash
rp-pppoe	-	  3.11		-	    5			.e17.x86_64			.rpm
软件名称			软版本信息   释出的次数		适合的硬件平台		扩展名
```

每项含义：

- 软件名称：每一个软件的名称

- 版本信息

  每一次更新版本就需要有一个版本的信息，通常又分为主版本与次版本。

  以上面为例：主板吧为 3，在主板吧的架构下更动部分源码内容，而释出一个新的版本，就是次版本

- 释出版本次数

  通常就是编译的次数，那么为何需要重复编译呢？由于同一版的软件中，可能由于某些 bug 或安全上的顾虑，所以必须进行小幅度的 patch 或重设一些编译参数。设置完成后，重新编译打包成 RPM 文件，因此就有不同的打包数出现

- 操作硬件平台

  由于 RPM 可以适用在不同的操作平台上，但是不同的平台设置的参数还是有所差异的，并且，可以针对比较高阶的 CPU 来进行优化参数的设置。所以就有了 i386、i586、i686、noarch、x86_64 等文件名的出现

  - i386：

    几乎适用于所有的 x86 平台，不论是旧的 pentum 或则是新的 Intel Core 2 与 K8 系列的 CPU 等等，都可以正常的工作，i 指 Intel 兼容的 CPU，386 则是 CPU 等级

  - i586

    针对 586 等级的计算机进行优化编译。CPU 包括 pentum 第一代 MMX CPU、AMD 的 k5、k6 系列 CPU（socket7 插脚）等等的 CPU 都算是这个等级

  - i686

    在 pentun II 以后的 intel 系列 CPU，及 K7 以后等级的 CPU 都属于 686 等级。由于目前市面上几乎仅剩 P-II 以后等级的硬件平台，因此很多 distribution 都直接释出这种等级的 RPM 文件
    
   - x86_64

     针对 64 位 CPU 进行优化编译设置，包括 Intel 的 Core2 以上等级 CPU，以及 AMD 的 Athlon64 以后等级的 CPU，都属于这一类型的硬件平台

  - noarch

    没有任何硬件等级上的限制。一般来说，这种类型的 RPM 文件，里面应该没有 binary program 存在，常出现的就是属于 shell script 方面的软件

由于时代发展，目前大概也只剩下 i686 以及 x86_64 还有不分版本的 noarch 。受惠于目前 x86 系统的支持方面，新的 CPU 都能执行旧 CPU 所支持的软件，也就是说硬件方面都可以向下兼容，因此 **最低等级的 i386 软件可以安装在所有的 x86 硬件平台上**，不论是 32 位还是 64 位。

根据上面的说明，其实我们只要选择 i686 版本来安装在你的 x86 硬件上就肯定没有问题。但是如果强调性能的话，还是选择搭配你硬件的 RPM 文件吧。毕竟该软件针对你的 CPU 硬件平台进行过参数优化的编译

## RPM 的优点

由于 RPM 是通过预先编译并打包成 RPM 文件格式后，再加以安装的一种方式，并且还能够进行数据库的记录 。所以优点如下：

- RPM 内含已经编译过的程序与配置文件等数据，可以让用户免除重新编译的困扰
- RPM 在被安装之前，会先检查系统的硬盘容量、操作系统版本等，可避免文件被错误安装
- RPM 文件本身提供软件版本信息、相依属性软件名称、软件用途说明、软件所含文件等信息，便于了解软件
- RPM 管理的方式使用数据库记录 RPM 文件的相关参数，便于升级、移除、查询与验证

由于有软件的相依属性，当你安装 RPM 形态提供的软件时，RPM 会校验数据库中是否已经存在相关的软件了，如果不存在，那么这个 RPM 文件预设就不能安装，这个就是 RPM 类型的文件最为人所诟病的 **软件的属性相依** 问题

## RPM 属性相依的克服方式：YUM 在线升级

为了重复利用现有软件功能，因此很多软件都会以函数库的方式释出部分功能，以方便其他软件的调用，为了节省用户的数据量，目前的 distribution 在释出软件时，都会将软件的内容分为一般使用者与开发使用者两类。所以才会常常看见有类似 `pam-x.x.rpm 和 pam-devel-x.x.rpm` 之类的文件名，而预设情况下，大部分的 software-devel-x.x.rpm 都不会安装，因为终端用户大部分不会去开发软件

因为由上述的现象，因此 RPM 软件文件就会有所谓的属性相依问题的产生（其实所有的软件管理几乎都有着方面的情况存在）。

由于 RPM 软件文件内部会记录相依属性数据，YUM 在安装软件时，先找到这个相依属性列表，然后与系统内已安装软件进行比较，没有安装到的相依软件同时安装起来，这就解决了属性相依问题

CentOS：

1. 先将释出软件放置到 YUM 服务器内
2. 再分析这些软件的相依属性问题，将软件内的记录信息写下来（header）

然后将这些信息分析后记录成软件相关性的列表，这些列表数据与软件所在的本机或网络位置可以称呼为容器或软件仓库或软件库（repository）。当客户端有软件安装的需求时，客户端主机会主动的向网络上面的 yum 服务器的软件库网址下载清单列表，然后通过列表的数据与本机 RPM 数据库已存在的软件数据比较，就能够一次性安装所有需要的具有相依属性的软件了。整个流程可以简单的如下图所示：

![image-20200406211622631](http://p6ui.toweydoc.tech:20080/images/stydocs/image-20200406211622631.png)

当客户端有升级、安装的需求时，yum 会向软件库要求清单的更新，等到清单更新到本机的`/var/cache/yum` 里面后，等一下更新时就会用这个本机清单与本机的 RPM 数据库进行比较，这就知道该下载上面软件。

接下来 yum 会跑到软件库服务器（yum server）下载所需要的软件（因为由记录软件所在的网址），然后通过 RPM 的机制开始安装软件


## RPM 软件管理程序：rpm

## RPM 默认安装的路径

一般来说，RPM 类型的文件在安装的时候，会先读取文件内记载的设置参数内容，然后将该数据用来对比 Linux 系统的环境，找出未安装的依赖软件。

若环境检查合格了，则开始安装。安装完成后，该软件相关的信息会被写入到 `/var/lib/rpm/` 目录下的数据库文件中。

这个数据库的数据很重要，因为未来如果我们有任何软件的升级需求，版本之间的比较就是来自这个数据库，想查询已安装的软件信息也是来自于该数据库，同时，目前的 RPM 也提供数字签名信息，也是记录在此

那么软件内的文件放置到哪里的？这个与文件系统有关，在第 5 章的目录配置谈过每个目录的含义，这里再次强调：

- `/etc/`：一些配置文件
- `/usr/bin/`：一些可执行文件
- `/usr/lib/`：一些程序使用的动态函数库
- `/usr/share/doc/`：一些基本的软件使用手册与说明文件
- `/usr/share/man/`：一些 man page 文件

## RPM 安装（install）

因为软件安装时 root 的工作，因此需要有 root 身份才可以使用 rpm 指令

```bash
rpm -ivh package_name

-i：install
-v：查看更详细的安装信息画面
-h：以安装信息列显示安装进度
```

```bash
# 范例 1：安装原版光盘上的 rp-pppoe 软件
[root@study ~]# rpm -ivh /mnt/Packages/rp-pppoe-3.11-7.el7.x86_64.rpm 
Preparing...                          ################################# [100%]
Updating / installing...
   1:rp-pppoe-3.11-7.el7              ################################# [100%]
   
# 范例 2：一次性安装两个以上的软件
rpm -ivh a.i386.rpm b.i386.rpm *.rpm
# 后面可以接上许多的软件

# 范例 3：直接有网络上面的某个文件安装
rpm -ivh http://website.name/path/pkgname.rpm
```

另外，如果在安装过程中发现问题，或已经知道会发生问题，还是要强制安装，可以参考以下说明，下面列出 rpm 安装时常用的选项与参数说明：

- `--nodeps`

  - 使用时机：当发生软件属性依赖问题而无法安装时，但你想强制安装时
  - 危险性：如果不考虑依赖问题，可能导致软件无法正常使用

- `--replacefiles`

  - 使用时机：如果在安装过程中出现了「某个文件已经被安装在你的系统上」的信息，又或许出现版本不合的信息（confilcting files）时，可以使用该参数来直接覆盖文件
  - 危险性：覆盖的动作无法还原，所以你必须很清楚的知道你自己在做什么

- `--replacepkgs`

  使用时机：重新安装某个已经安装过的软件，如果你要安装一堆 RPM 软件时，可以使用 `rpm -ivh *.rpm`，但若某些软件已经安装过了，此时系统会出现某软件已经安装过的信息，导致无法继续安装。此时可以使用该选项

- `--force`

  使用时机：该参数其实是 `--replacefiles` 与 `--replacepkgs` 的合体

- `--test`

  使用时机：想要测试下该软件是否可以被安装到使用者的 Linux 环境中，可以找出是否有属性依赖问题

- `--justdb`

  使用时机：由于 RPM 数据库破损或某些缘故产生错误时，可以使用该选项来更新软件在数据库内的相关信息

- `--nosignature`

  使用时机：想要忽略数字签名时的检查时

- `--prefix 新路径`

  使用时机：要将软件安装到其他非正规目录时

- `--noscripts`

  - 使用时机：不想让该软件在安装过程中自行执行某些系统指令
  - 说明：RPM 的优点除了可以将文件放置到指定位置外，还可以自动执行一些前置作业指令，例如数据库初始化。如果不想让 RPM 帮你自动执行这一类的指令，可以加上该参数

  
  

一般来说，rpm 的安装选项与参数大约就是以上的项目。作者建议一般使用 `-ivh` 就好了。如果安装过程中发现问题，一个一个将问题找出来，尽量不要使用暴力安装法（不要使用 `-force` 方式）

范例：当没有网络时，通过原版光盘安装一个名为 pam-devel 软件时，可以如下做

```bash
找出光驱位置：blkid 
挂载光盘：mount /dev/sr0 /mnt
找出文件的实际路径：find /mnt -name 'pam-devel*'
测试此软件是否具有相依性：rpm -ivh pam-devel... --test
直接安装：rpm -ivh pam-devel...
卸载光盘：umount/mnt
```

## RPM 升级与更新（upgrade/freshen）

使用 RPM 来升级也很简单，可以使用如下参数

- `-Uvh`

  后面接的软件即使没有安装过，则系统直接安装；若安装过旧版的软件，则系统自动更新至新版

- `-Fvh`

  后面接的软件并未安装到系统，则该软件不会安装；

从说明来看，`-Fvh` 一般用在大量升级系统旧版本软件时。

早期没有 yum 的环境下，同时网络带宽也很糟糕的情况下，通常有的朋友在进行整个操作系统的旧版本软件修补时，喜欢这么做：

1. 先到个发展商 errdata 网站或者是国内的 FTP 镜像下载最新的 RPM 文件
2. 使用 `-Fvh` 将你系统内曾安装过的软件进行升级

## RPM 查询（query）

RPM 在查询的时候，其实也是使用的是 `/var/lib/rpm` 目录下的数据库文件

另外，还可以查询未安装的 RPM 文件内的信息。

```bash
rpm -qa																	  # 已安装软件
rpm -q[licdR] 已安装的软件名称							# 已安装软件
rpm -qf 存在于系统上面的某个文件名						# 已安装软件
rpm -qp[licdR] 未安装的某个文件名					# 查询 RPM 文件

选项与参数：
查询已安装软件的信息：
	-q：仅查询，后面接的软件名称是否有安装
	-qa：列出所有的，已经安装在本机所有软件名称
	-qi：列出该软件的详细信息（information），包含开发商、版本与说明等
	-ql：列出该软件所有的文件与目录所在完整文件名（list）
	-qc：列出该软件的所有配置文件（找出在 `/etc/` 下的文件名）
	-qd：列出该软件的所有说明文件（找出与 man 有关的文件）
	-qR：列出与该软件有关的相依赖软件所含的文件（Required）
	-qf：由后面接的文件名，找出该文件属于哪一个已安装的软件
	-q --scripts：列出是否含有安装后需要执行的脚本文件，可以用来 debug
查询某个 RPM 文件内含有的信息：
	-qp[icdlR]：这里的参数与上面的一致，只是这里查询的是没有安装的软件
```

在查询部分，所有参数都需要加上 `-q` 表示查询。查询主要分为两部分：

- 查询已安装到系统上的软件信息，数据信息由 `/var/lib/rpm/` 提供
- 查询 rpm 文件内容，等于是由 RPM 文件内找出一些要写入数据库内的信息，需要使用 `-qp(p 是 package 的含义)`

```bash
# 范例 1：找出是否有安装 logrotate 这个软件
[root@study ~]# rpm -q logrotate
logrotate-3.8.6-17.el7.x86_64
# 查询未安装的，则提示没有安装
[root@study ~]# rpm -q logrotating
package logrotating is not installed

# 范例 2：列出上题中，属于该软件所提供的所有目录与文件
[root@study ~]# rpm -ql logrotate
/etc/cron.daily/logrotate
/etc/logrotate.conf
...
# 可以看到有很多的文件和目录，可以用来追踪软件的数据

# 范例 3：列出 logrotate 软件的相关说明
[root@study ~]# rpm -qi logrotate
Name        : logrotate										# 软件名称
Version     : 3.8.6												# 软件版本
Release     : 17.el7											# 释出的版本
Architecture: x86_64											# 编译时所针对的硬件等级
Install Date: Fri Oct  4 18:22:43 2019		# 该软件安装到本系统的时间
Group       : System Environment/Base			# 软件是放在哪一个软件群组中
Size        : 107156											# 软件的大小
License     : GPL+												# 释出的授权方式
Signature   : RSA/SHA256, Mon Nov 12 22:39:25 2018, Key ID 24c6a8a7f4a80eb5
Source RPM  : logrotate-3.8.6-17.el7.src.rpm	# SRPM 的文件名
Build Date  : Wed Oct 31 03:13:00 2018				# 软件编译打包的时间
Build Host  : x86-01.bsys.centos.org					# 在哪一部主机上编译的
Relocations : (not relocatable)
Packager    : CentOS BuildSystem <http://bugs.centos.org>
Vendor      : CentOS
URL         : https://github.com/logrotate/logrotate
Summary     : Rotates, compresses, removes and mails system log files
Description :		# 详细描述
The logrotate utility is designed to simplify the administration of
log files on a system which generates a lot of log files.  Logrotate
allows for the automatic rotation compression, removal and mailing of
log files.  Logrotate can be set to handle a log file daily, weekly,
monthly or when the log file gets to a certain size.  Normally,
logrotate runs as a daily cron job.

Install the logrotate package if you need a utility to deal with the
log files on your system.
# 列出了很多的信息

# 范例 4：分别仅找出 logrotate 的配置文件与说明文件
[root@study ~]# rpm -qc logrotate
/etc/cron.daily/logrotate
/etc/logrotate.conf
/etc/rwtab.d/logrotate
[root@study ~]# rpm -qd logrotate
/usr/share/doc/logrotate-3.8.6/CHANGES
/usr/share/doc/logrotate-3.8.6/COPYING
/usr/share/man/man5/logrotate.conf.5.gz
/usr/share/man/man8/logrotate.8.gz

# 范例 5：若要成功安装 logrotate，还需要什么文件的帮忙
[root@study ~]# rpm -qR logrotate
/bin/sh
/bin/sh
config(logrotate) = 3.8.6-17.el7
coreutils >= 5.92
libacl.so.1()(64bit)
libacl.so.1(ACL_1.0)(64bit)
libc.so.6()(64bit)
libc.so.6(GLIBC_2.14)(64bit)
libc.so.6(GLIBC_2.2.5)(64bit)
libc.so.6(GLIBC_2.3)(64bit)
libc.so.6(GLIBC_2.3.4)(64bit)
libc.so.6(GLIBC_2.4)(64bit)
libc.so.6(GLIBC_2.7)(64bit)
libc.so.6(GLIBC_2.8)(64bit)
libpopt.so.0()(64bit)
libpopt.so.0(LIBPOPT_0)(64bit)
libselinux.so.1()(64bit)
popt
rpmlib(CompressedFileNames) <= 3.0.4-1
rpmlib(FileDigests) <= 4.6.0-1
rpmlib(PayloadFilesHavePrefix) <= 4.0-1
rtld(GNU_HASH)
rpmlib(PayloadIsXz) <= 5.2-1
# 列出了该软件的依赖文件

# 范例 6：在范例 5 基础上，找出 /bin/sh 是哪个软件提供的？
[root@study ~]# rpm -qf /bin/sh
bash-4.2.46-33.el7.x86_64
# 参数后，接的是文件，而不是软件名称
# 该功能查询系统的某个文件属于哪一个软件的


# 范例 7：假设我下载一个 RPM 文件，想要知道该文件的需求文件
 rpm -qpR filename.i386.rpm
```

### 练习题

1. 想要知道系统中，以 C 开头的软件有几个

   ```bash
   [root@study ~]# rpm -qa | grep ^c | wc -l
   65
   ```

2. www 服务器为 Apache，我知道它使用的 RPM 软件文件名为 httpd，要知道这个软件的所有配置文件放置何处

   ```bash
   [root@study ~]# rpm -qc httpd
   ```

3. 承上题，如果查出来的配置文件已经被修改过，但是忘记修改了哪些地方，所以想要直接重新安装一次软件

   ```bash
   假设该软件在网络上的地址为：http://xxx.com/path/httpd-x.x.xx.i386.rpm
   rpm -ivh http://xxx.com/path/httpd-x.x.xx.i386.rpm --replacepkgs
   ```

4. 如果误删了某个重要文件，如 `/etc/crontab` ，但不知道它属于哪一个软件，怎么办？

   ```bash
   [root@study ~]# rpm -qf /etc/crontab 
   crontabs-1.11-6.20121102git.el7.noarch
   ```

## RPM 验证与数字签名（Verify、signature）

   验证功能主要作用是使用 `/var/lib/rpm` 下的数据库内容来比对目前 LInux 系统的环境下的偶有软件文件，是否有被修改过（笔者猜测可能是和原始安装文件中的文件对比？）

```bash
rpm -Va
rpm -V 已安装的软件名称
rpm -Vp 某个 RPM 文件的文件名
rpm -Vf 在系统上的某个文件

选项与参数：
	-V：后面加的是软件名称，若该软件所含的文件被修改过，才会列出来
	-Va：列出目前系统上所有可能被修改过的文件
	-Vp：后面加的是文件名，列出该软件内可能被修改过的文件
	-Vf：列出某个文件是否被修改过
```

```bash
# 范例 1：列出你的 Linux 内的 logrotate 软件是否被修改过
[root@study ~]# rpm -V logrotate
# 没有任何信息，表示没有被修改过

# 范例 2：查询下 /etc/crontab 是否被修改过
[root@study ~]# rpm -Vf /etc/crontab 
S.5....T.  c /etc/crontab
# 因为被更改过，所以列出更改过的信息类型
```

你是否有一个疑问？哪些文件是可以被用来查询是否有修改过的？还记得 rpm 的`-ql：列出该软件所有的文件与目录所在完整文件名（list）`？下面就来实践下

```bash
[root@study ~]# rpm -ql logrotate
/etc/cron.daily/logrotate
/etc/logrotate.conf
/etc/logrotate.d
/etc/rwtab.d/logrotate
/usr/sbin/logrotate
/usr/share/doc/logrotate-3.8.6
/usr/share/doc/logrotate-3.8.6/CHANGES
/usr/share/doc/logrotate-3.8.6/COPYING
/usr/share/man/man5/logrotate.conf.5.gz
/usr/share/man/man8/logrotate.8.gz
/var/lib/logrotate
/var/lib/logrotate/logrotate.status
# 该软件一共有 12 个文件，修改 /etc/logrotate.conf 内的 rotate 变成 6

# 再看看该软件有哪些文件被修改过了
[root@study ~]# rpm -V logrotate
..5....T.  c /etc/logrotate.conf
```

文件名前面有一个 c 表示是 configuration （配置文件），前面一堆的含义如下：

- S：file Size differs，文件的容量大小已经改变
- M：Mode differs，文件的类型或文件的属性（rwx）已经改变
- 5：MD5 sum differs，MD5 指纹码的内容已经改变
- D：Device major/minor number mis-match，设备的主/次代码已经改变
- L：readLink(2) path mis-match，Link 路径已经改变
- U：User ownership differs，文件的所属人已经改变
- G：Group ownership differs，文件的所属群组已被改变
- T：mTime differs，文件的建立时间已被改变
- P：caPabilities differ，功能已经改变

所以当一个配置文件的所有信息都被修改过，则会显示 `SM5DLUGTP c filename`

文件名前面的 c 表示是文件类型，有以下几类：

- c：配置文件 config file
- d：文件数据文件 documentation
- g：鬼文件 ghost file，通常是该文件不被某个软件包含，较少发生
- l：许可证文件 license file
- r：自述文件 read me

通过该功能，如果这些修改是预期中的，就是正常的，比如你的 binary progran 都被修改过了，那么就要小心了（作者通过 rpm -Va 找出来好多 binary program 被修改过，被黑了，当成了跳板机）

### 数字签名（digital signature）

首先，安装软件时，去对比官方释出的 MD5 指纹，能对上则表示是官方释出的，但是 MD5 也可能被串改？用数字签名来校验软件的来源

厂商可以数字签名系统产生一个专属于该软件的签章，并将该签章的公钥（public key）释出，当安装一个 RPM 软件时：

1. 首先比如要先安装原厂释出的公钥文件
2. 实际安装原厂的 RPM 软件时，rpm 指令会去读取 RPM 文件的签章信息，与本机系统内的签章信息比对
3. 若签章相同则安装，若找不到相关的签章信息时，则给予警告并且停止安装

CentOS 使用的数字签名系统为 GNU 计划的 GnuPG（GNU Privacy Guard）。有兴趣可以去详细了解下 GPG 的加密机制，这里简单的说明数字签名在 RPM 文件上的应用。

那么首选比如安装原厂释出的 GPG 数字签名的公钥文件，CentOS 的数字签名位于

```bash
[root@study ~]# ll /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 
-rw-r--r--. 1 root root 1690 9月   5 2019 /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
[root@study ~]# cat /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.4.5 (GNU/Linux)

mQINBFOn/0sBEADLDyZ+DQHkcTHDQSE0a0B2iYAEXwpPvs67cJ4tmhe/iMOyVMh9
...
=OGYX
-----END PGP PUBLIC KEY BLOCK-----
```

那么该文件可以通过如下的方式来安装

```bash
[root@study ~]# rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
```

由于不同版本 GPG 密钥文件放置的位置可能不同，不过大多是以 GPG-KEY 来命名的，可以简单时候 locate 或 find 来寻找

```bash
[root@study ~]# locate GPG-KEY
[root@study ~]# find /etc -name '*GPG-KEY*'
```

安装完成后，这个密钥的内容基本上以 pubkey 的软件名称来呈现

```bash
[root@study ~]# rpm -qa | grep pubkey
gpg-pubkey-f4a80eb5-53a7ff4b
[root@study ~]# rpm -qi gpg-pubkey-f4a80eb5-53a7ff4b
Name        : gpg-pubkey
Version     : f4a80eb5
Release     : 53a7ff4b
Architecture: (none)
Install Date: 2020年04月05日 星期日 16时21分30秒
Group       : Public Keys
Size        : 0
License     : pubkey
Signature   : (none)
Source RPM  : (none)
Build Date  : 2014年06月23日 星期一 18时19分55秒
Build Host  : localhost
Relocations : (not relocatable)
Packager    : CentOS-7 Key (CentOS 7 Official Signing Key) <security@centos.org>
Summary     : gpg(CentOS-7 Key (CentOS 7 Official Signing Key) <security@centos.org>)
Description :
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: rpm-4.11.3 (NSS-3)

mQINBFOn/0sBEADLDyZ+DQHkcTHDQSE0a0B2iYAEXwpPvs67cJ4tmhe/iMOyVMh9
...
=OGYX
-----END PGP PUBLIC KEY BLOCK-----
```

重点是最后面出现的一串数据，如果你忘记加上数字签名，很多原版软件就不能让你安装，除非使用 rpm 时选择忽略数字签名的选项

笔者疑问：这个数值签名是系统自动安装的，是随机的吗？那么多版本的系统和软件，难道都公用同一个？这个笔者有点想不通

## RPM 卸载与重建数据库（erase/rebuilddb）

卸载软件，要注意的是，由最上层往下卸载，啥意思？由于有函数库软件依赖等原因，要正常卸载的话，只能卸载掉一个没有被依赖的软件或则函数库，有依赖的就会导致无法卸载。下面一个案例说明

```bash
# 1. 好处与 pam 有关的软件名称，并尝试移除 pam 软件
[root@study ~]# rpm -qa | grep pam
fprintd-pam-0.8.1-2.el7.x86_64
gnome-keyring-pam-3.28.2-1.el7.x86_64
pam-1.1.8-22.el7.x86_64

[root@study ~]# rpm -e pam 
error: Failed dependencies: # 检测到有很多软件依赖了它，不能删除
	libpam.so.0()(64bit) is needed by (installed) libpwquality-1.2.3-5.el7.x86_64
	libpam.so.0()(64bit) is needed by (installed) libuser-0.60-9.el7.x86_64
	libpam.so.0()(64bit) is needed by (installed) passwd-0.79-5.el7.x86_64
	libpam.so.0()(64bit) is needed by (installed) util-linux-2.23.2-61.el7.x86_64
	
# 2. 若移除 rp-pppoe 软件就可以
# rp-pppoe 软件是本章练习安装的，所以没有任何软件依赖它
[root@study ~]# rpm -e rp-pppoe
```

由于 RPM 文件常常会安装、移除、升级等，某些动作可能会导致 RPM 数据库 `/var/lib/rpm/` 内的文件破损。此时你可以重建它

```bash
rpm --rebuilddb   # 重建数据库
```

## YUM 在线升级机制

yum 是通过分析 RPM 的标头资料后，根据各软件的相关性制作出属性相依时的解决方案，然后可以自动处理软件的相依属性问题，以解决软件安装或移除或升级的问题

由于 distribution 必须要先释出软件，然后将软件放置于 yum 服务器上，提供客户端的使用。因此我们想要使用 yum 的功能时，必须要先找到适合的 yum server 才行，而每个 yum server 可能都会提供许多不同的软件功能，这就是「软件库」。因此，你必须要前往 yum server 查询到相关的软件库网址后，再继续后续的设置

事实上，CentOS 在释出软件时已经制作出多个映像站（mirror site）提供全世界的软件更新使用。所以，理论上不需要处理任何设置，只要能够连上 internet ，就可以使用 yum

## 使用 yum 进行查询、安装、升级、与移除

### 查询功能：`yum [list|info|search|provides|whatprovides] ` 参数

```bash
yum [option] [查询工作项目] [相关参数]

选项与参数：
[option]：主要选项有：
	-y：当 yum 要等待用户输入时，自动提供 yes 的响应
	--installroot=/some/path：将该软件安装在 /some/path 路径下，而不是使用默认的路径
[查询工作项目] [相关参数]：
	search：搜索某个软件名称或则是描述（description）的重要关键字
	list：列出目前 yum 所管理的所有的软件名称与版本，类似 rpm -qa
	info：同上，不过类似 rpm -qai 的执行结果
	provides：从文件去搜索软件，类似 rpm -qf 的功能
```

```bash
# 范例 1：搜索磁盘阵列 raid 相关软件有哪些？
[root@study ~]# yum search raid
Loaded plugins: fastestmirror, langpacks		# yum 系统自己找出最近的 yum server
Loading mirror speeds from cached hostfile	# 找出速度最快的哪一部 yum server
 * base: mirrors.huaweicloud.com						# 下面的三个软件库，且来源为该服务器
 * extras: mirrors.huaweicloud.com
 * updates: mirrors.huaweicloud.com
========================================= N/S matched: raid ==========================================
dmraid.i686 : dmraid (Device-mapper RAID tool and library)
dmraid.x86_64 : dmraid (Device-mapper RAID tool and library)
dmraid-devel.x86_64 : Development libraries and headers for dmraid.
dmraid-events-logwatch.x86_64 : dmraid logwatch-based email reporting
libblockdev-mdraid.i686 : The MD RAID plugin for the libblockdev library
libblockdev-mdraid.x86_64 : The MD RAID plugin for the libblockdev library
libblockdev-mdraid-devel.i686 : Development files for the libblockdev-mdraid plugin/library
libblockdev-mdraid-devel.x86_64 : Development files for the libblockdev-mdraid plugin/library
libstoragemgmt-megaraid-plugin.noarch : Files for LSI MegaRAID support for libstoragemgmt
dmraid-events.x86_64 : dmevent_tool (Device-mapper event tool) and DSO
iprutils.x86_64 : Utilities for the IBM Power Linux RAID adapters
mdadm.x86_64 : The mdadm program controls Linux md devices (software RAID arrays)

  Name and summary matches only, use "search all" for everything.
# 上述找到了好多软件，冒号「:」左边的是软件名称，右边的则是 RPM 内的 name 设置（软件名）

# 范例 2：找出 mdadm 软件的功能
[root@study ~]# yum info mdadm
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirrors.huaweicloud.com
 * extras: mirrors.huaweicloud.com
 * updates: mirrors.huaweicloud.com
Installed Packages			# 这说明该软件已经安装到系统上了
Name        : mdadm			# 软件名
Arch        : x86_64		# 编译架构
Version     : 4.1				# 软件版本
Release     : 1.el7			# 释出的版本
Size        : 1.0 M			# 此软件的文件总大小
Repo        : installed	# 软件库回应说已安装的
From repo   : anaconda
Summary     : The mdadm program controls Linux md devices (software RAID arrays)
URL         : http://www.kernel.org/pub/linux/utils/raid/mdadm/
License     : GPLv2+
Description : The mdadm program is used to create, manage, and monitor Linux MD (software
            : RAID) devices.  As such, it provides similar functionality to the raidtools
            : package.  However, mdadm is a single program, and it can perform
            : almost all functions without a configuration file, though a configuration
            : file can be used to help with some common tasks.
# 其他的信息则自己翻译下吧
```

```bash
# 范例 3：列出 yum 服务器上提供的所有软件名称
[root@study ~]# yum list
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirror.bit.edu.cn
 * extras: mirror.bit.edu.cn
 * updates: mirror.bit.edu.cn
Installed Packages			# 已安装的软件
GConf2.x86_64                                           3.2.6-8.el7                          @anaconda
GeoIP.x86_64                                            1.5.0-14.el7                         @anaconda
LibRaw.x86_64                                           0.19.2-1.el7                         @anaconda
...
Available Packages		# 还可以安装的其他软件
...

# 软件列表数据含义： 软件名称   版本  在哪个软件库



# 范例 4：列出目前服务器上可供本机进行升级的软件有哪些
[root@study ~]# yum list updates
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirror.bit.edu.cn
 * extras: mirror.bit.edu.cn
 * updates: mirror.bit.edu.cn
base                                                                                                                   | 3.6 kB  00:00:00     
extras                                                                                                                 | 2.9 kB  00:00:00     
updates                                                                                                                | 2.9 kB  00:00:00     
Updated Packages
NetworkManager.x86_64                                                         1:1.18.0-5.el7_7.2                                       updates
NetworkManager-adsl.x86_64                                                    1:1.18.0-5.el7_7.2                                       updates
```

```bash
# 范例 5：列出提供 passwd 这个文件的软件有哪些
[root@study ~]# yum provides passwd
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirrors.huaweicloud.com
 * extras: mirrors.huaweicloud.com
 * updates: mirrors.huaweicloud.com
passwd-0.79-5.el7.x86_64 : An utility for setting or changing passwords using PAM
Repo        : base



passwd-0.79-5.el7.x86_64 : An utility for setting or changing passwords using PAM
Repo        : @anaconda
# 就是上面这个软件提供了 passwd 这个程序
```

通过上面的演示，大概知道 yum 如何用在查询上了，下面实际来应用一下

例题：利用 yum 的功能，找出以 pam 开头的软件名称有哪些，而其中尚未安装的有哪些

```bash
[root@study ~]# yum list pam*
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirrors.huaweicloud.com
 * extras: mirrors.huaweicloud.com
 * updates: mirrors.huaweicloud.com
Installed Packages		# 已安装的
pam.x86_64                                                             1.1.8-22.el7                                                  @anaconda
Available Packages		# 下面是可升级或未安装的，显示 updates 的话则是可升级的
pam.i686                                                               1.1.8-22.el7                                                  base     
pam-devel.i686                                                         1.1.8-22.el7                                                  base     
pam-devel.x86_64                                                       1.1.8-22.el7                                                  base     
pam_krb5.i686                                                          2.4.8-6.el7                                                   base     
pam_krb5.x86_64                                                        2.4.8-6.el7                                                   base     
pam_pkcs11.i686                                                        0.6.2-30.el7                                                  base     
pam_pkcs11.x86_64                                                      0.6.2-30.el7                                                  base     
pam_snapper.i686                                                       0.2.8-4.el7                                                   base     
pam_snapper.x86_64                                                     0.2.8-4.el7                                                   base     
pam_ssh_agent_auth.i686                                                0.10.3-2.21.el7                                               base     
pam_ssh_agent_auth.x86_64                                              0.10.3-2.21.el7                                               base
```

### 安装/升级功能：yum [install|update] 软件

```bash
yum [option] [安装与升级的工作项目] [相关参数]

install：接要安装的软件
update：接要升级的软件，若要整个系统都升级，直接 update
```

```bash
# 范例 1：将前一个练习找到的未安装的 pam-delvel 安装
[root@study ~]# yum install pam-devel
Loaded plugins: fastestmirror, langpacks  # 前 5 行找出最快的 yum server
Loading mirror speeds from cached hostfile
 * base: mirrors.huaweicloud.com
 * extras: mirrors.huaweicloud.com
 * updates: mirrors.huaweicloud.com
Resolving Dependencies		# 处理依赖软件
--> Running transaction check
---> Package pam-devel.x86_64 0:1.1.8-22.el7 will be installed
--> Finished Dependency Resolution
# 下表是一个总结性的显示
Dependencies Resolved

==============================================================================================================================
 Package                        Arch                        Version                           Repository                 Size
==============================================================================================================================
Installing:
 pam-devel                      x86_64                      1.1.8-22.el7                      base                      184 k

Transaction Summary
==============================================================================================================================
Install  1 Package		# 需要安装一个软件

Total download size: 184 k
Installed size: 528 k
Is this ok [y/d/N]: y
Downloading packages:
pam-devel-1.1.8-22.el7.x86_64.rpm                                                                      | 184 kB  00:00:00     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installing : pam-devel-1.1.8-22.el7.x86_64                                                                              1/1 
  Verifying  : pam-devel-1.1.8-22.el7.x86_64                                                                              1/1 

Installed:
  pam-devel.x86_64 0:1.1.8-22.el7                                                                                             

Complete!

```

### 移除软件 remove

```bash
# 移除刚刚安装的软件
[root@study ~]# yum remove pam-devel
Loaded plugins: fastestmirror, langpacks
Resolving Dependencies
--> Running transaction check
---> Package pam-devel.x86_64 0:1.1.8-22.el7 will be erased
--> Finished Dependency Resolution

Dependencies Resolved

==============================================================================================================================
 Package                       Arch                       Version                             Repository                 Size
==============================================================================================================================
Removing:
 pam-devel                     x86_64                     1.1.8-22.el7                        @base                     528 k

Transaction Summary
==============================================================================================================================
Remove  1 Package

Installed size: 528 k
Is this ok [y/N]: 
Is this ok [y/N]: y
Downloading packages:
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Erasing    : pam-devel-1.1.8-22.el7.x86_64                                                                              1/1 
  Verifying  : pam-devel-1.1.8-22.el7.x86_64                                                                              1/1 

Removed:
  pam-devel.x86_64 0:1.1.8-22.el7                                                                                             

Complete!
# 由于没有依赖软件，只移除一个软件
```

## yum 的配置文件

yum 由于有映像站软件库的 yum server，有可能会选择错误，所以可以手动修改 yum 的配置文件。

比如下面就有两个网址：

- http://ftp.twaren.net/Linux/CentOS/7/
- http://ftp.ksu.edu.tw/FTP/CentOS/7/

打开之后，有一堆的链接，这些链接就是这个 yum 服务器所提供的软件库了。

由于我们的测试机是 x86_64 的，点击一个 os 的软件库，再选择 x86_64 ，这个页面地址就是提供安装的网址： http://ftp.ksu.edu.tw/FTP/CentOS/7/os/x86_64/。 最重要的是 `repodata` http://ftp.ksu.edu.tw/FTP/CentOS/7/os/x86_64/repodata/  这个目录，该目录是分析 RPM 软件后产生的软件属性相依属性，因此，当你找软件库所在网址时，**最重要的是确定该网址下一定要有一个名为 repodata 的目录存在**。

```bash
[root@study ~]# vim /etc/yum.repos.d/CentOS-Base.repo 
[base]
name=CentOS-$releasever - Base
mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os&infra=$infra
#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
...
```

如上所述，有一个 base 软件库，个字段含义如下：

- `[bash]`：达标软件库的名字，里面的名称可以随意取。但是需要名称唯一
- name：只是说明这个软件库的意义
- `mirrorlist`：该软件库可以使用的站点，如果不想用，可以注释掉
- `baseurl`：最重要的配置，因为后面是软件库的实际地址。 mirrorlist 是由 yum 程序自动选择的站点，而 baseurl 则是指定固定的一个软件库网址，可以将刚刚找到的网址替换掉这里
- `enable=1`：软件库被启用。设置为 0 则不启用
- `gpgcheck=1`：RPM 的数字签名，是否需要查询 RPM 文件内的数字签名
- `gpgkey`：数字签名的公钥文件所在位置，使用默认值即可

在这里我想起来了，笔者在安装某些软件的时候，需要特别安装他们的公钥文件，就是因为这里不同软件库释放出来的软件，公钥不一致的问题

下面修改为我们选择的高速软件仓库

```bash
[root@study ~]# vim /etc/yum.repos.d/CentOS-Base.repo
[base]
name=CentOS-$releasever - Base
baseurl=http://ftp.ksu.edu.tw/FTP/CentOS/7/os/x86_64/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

#released updates 
[updates]
name=CentOS-$releasever - Updates
baseurl=http://ftp.ksu.edu.tw/FTP/CentOS/7/updates/x86_64/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

#additional packages that may be useful
[extras]
name=CentOS-$releasever - Extras
baseurl=http://ftp.ksu.edu.tw/FTP/CentOS/7/extras/x86_64/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

# 默认情况下，只有这三个仓库被启用，这里只修改这三个
```

下面来测试

```bash
# 范例 1： 列出目前 yum server 所使用的软件库有哪些
[root@study yum.repos.d]# yum repolist all
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
repo id                                                repo name                                                status
C7.0.1406-base/x86_64                                  CentOS-7.0.1406 - Base                                   disabled
C7.0.1406-centosplus/x86_64                            CentOS-7.0.1406 - CentOSPlus                             disabled
...
base                                                   CentOS-7 - Base                                          enabled: 10097
base-debuginfo/x86_64                                  CentOS-7 - Debuginfo                                     disabled
base-source/7                                          CentOS-7 - Base Sources                                  disabled
c7-media                                               CentOS-7 - Media                                         disabled
centosplus/7/x86_64                                    CentOS-7 - Plus                                          disabled
centosplus-source/7                                    CentOS-7 - Plus Sources                                  disabled
cr/7/x86_64                                            CentOS-7 - cr                                            disabled
extras                                                 CentOS-7 - Extras                                        enabled:   341
extras-source/7                                        CentOS-7 - Extras Sources                                disabled
fasttrack/7/x86_64                                     CentOS-7 - fasttrack                                     disabled
updates                                                CentOS-7 - Updates                                       enabled:  1787
updates-source/7                                       CentOS-7 - Updates Sources                               disabled
...

# 右边写着 enabled 的才是有激活的。
# 会发现有其他的软件库，是因为由多个配置文件的原因

# 可以看到，再次安装的时候，则会走固定的软件库了
[root@study yum.repos.d]# yum install pam-devel
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
base                                                                                                   | 3.6 kB  00:00:00     
extras                                                                                                 | 2.9 kB  00:00:00     
updates                                                                                                | 2.9 kB  00:00:00 
```

#### 修改软件库产生的问题与解决之道

由于我们是修改的系统默认的配置文件，事实上，我们应该在 `/etc/yum.repos.d/` 下新建一个扩展名为 `.repo` 的文件。

由于我们指定了特定的软件库，而不是其他软件开发商提供的软件库，因此才修改系统默认配置文件，但是可能由于使用的软件库版本有新旧之分，而 yum 会先下载软件库的清单到本机的 `/var/cache/yum` 中，我们只修改了网址，却没有修改软件库名称（中括号里面的名称），就有可能造成本机的列表与 yum 服务器的列表不同步，此时就会出现无法更新的问题了

出现这样的情况，只要清空本机缓存即可，可以手工，也可以通过 yum 的 clean 指令来

```bash
yum clean [packages|headers|all]

packages：将已下载的软件文件删除
headers：将下载的软件文件头删除
all：将所有软件库数据都删除
```

```bash
# 这里删除已下载过的所有软件库的相关数据（含软件本身与列表）
[root@study yum.repos.d]# yum clean all
Loaded plugins: fastestmirror, langpacks
Cleaning repos: base extras updates
Cleaning up list of fastest mirrors

```

### 国内镜像站（仓库源）

一般使用国内的镜像站，可以选择上面两种方式中的其中一种，根据你自己的喜好选择

- 网易镜像站：http://mirrors.163.com/.help/centos.html
- 清华大学镜像站：https://mirrors.tuna.tsinghua.edu.cn/help/centos/

## yum 的软件群组功能

通过 yum 在线安装一个软件是很简单的，如果需要安装一个大型项目，比如测试机安装系统的时候，只选择了 GNOME 这个窗口管理员，此时想安装 KDE 呢，不需要重新安装，可以通过 yum 的软件群组功能

```bash
yum [群组功能] [软件群组]

选项与参数：
	grouplist：列出所有可使用的  软件群组组，例如 Development Tools 之类的
	groupinfo：后面接 group_name，则可了解该 group 内含的所有软件名
	groupinstall：可以安装一整组的软件群组，非常好用
	groupremove：移除某个软件群组
```

```bash
# 范例 1：查询目前软件库与本机上课用于安装过的软件群组有哪些？
[root@study yum.repos.d]# yum grouplist
Loaded plugins: fastestmirror, langpacks
There is no installed groups file.
Maybe run: yum groups mark convert (see man yum)
Loading mirror speeds from cached hostfile
 * base: mirrors.huaweicloud.com
 * extras: mirrors.huaweicloud.com
 * updates: mirrors.huaweicloud.com
# 如果有已安装过系统环境群组
# Installed environment groups：
#	xxxxx
Available Environment Groups:		# 还可以安装的系统环境软件群组
   Minimal Install
   Compute Node
   Infrastructure Server
   File and Print Server
   Basic Web Server
   Virtualization Host
   Server with GUI
   GNOME Desktop
   KDE Plasma Workspaces
   Development and Creative Workstation
# 如果有已安装过的群组。则由下面这一项
# Installed groups：
#  xxx
Available Groups:			# 还可以安装的软件群组
   Compatibility Libraries
   Console Internet Tools
   Development Tools
   Graphical Administration Tools
   Legacy UNIX Compatibility
   Scientific Support
   Security Tools
   Smart Card Support
   System Administration Tools
   System Management
Done

```

上面的 Available Groups 中有一个  Scientific Support，想知道这个是什么，可以查看他的信息

```bash
[root@study yum.repos.d]# yum groupinfo "Scientific Support"
....
Group: Scientific Support
 Group-Id: scientific
 Description: Tools for mathematical and scientific computations, and parallel computing.
 Optional Packages:
   atlas
   fftw
   fftw-devel
....
```

描述中说了，提供 用于数学和科学计算的工具，以及并行计算的工具，下面则是有许多的软件，在安装该群组时，会被一起安装

```bash
# 安装这个群组
[root@study yum.repos.d]# yum groupinstall "Scientific Support"
Loaded plugins: fastestmirror, langpacks
There is no installed groups file.
Maybe run: yum groups mark convert (see man yum)
Loading mirror speeds from cached hostfile
 * base: mirrors.huaweicloud.com
 * extras: mirrors.huaweicloud.com
 * updates: mirrors.huaweicloud.com
Warning: Group scientific does not have any packages to install.
Maybe run: yum groups mark install (see man yum)
No packages in any requested group available to install or update
```

正常情况下，会安装好各项软件，但是这个群组里面的软件都是可选择的 「Optional Packages:」（在查看 groupinfo 里面有这个项目），而不是主要的「mandatory」，所以默认情况下，该群组软件不会安装任何软件，你可以使用  `yum install atlas fftw ...` 一个一个写进去安装，如果想要 groupinstall 默认安装好所有的 optional 软件，就需要修改配置文件

```bash
[root@study ~]# vim /etc/yum.conf 
# 增加下面这一行的设置
group_package_types=default,mandatory,optional
```

## EPEL/ELRepo 外挂软件以及自定义配置文件

有很多时候，可能我们要使用的软件没有纳入 CentOS 的软件库内，就无法使用 yum 来进行安装，但是我们可以使用 Tarball 去编译，当然这个又变麻烦了，好在有网友提供了预先编译版本了

在Fedora 基金会里面发展了一个外加软件计划（Extra Packages for Enterprise Linux，EPEL），该计划主要针对 Red Hat Enterprise Linux 的版本来开发的，刚好 CentOS 也是针对 RHEL 的版本处理的，所以也能支持该软件库的相关软件相依环境了，主页地址为：https://fedoraproject.org/wiki/EPEL，CentOS 7 主要可以使用的软件仓库为 ：https://dl.fedoraproject.org/pub/epel/7/x86_64/

除了上述的 Fedora 计划所提供的额外软件仓库外，社群里面也针对 CentOS 与 EPEL 的不足而提供的许多软件仓库，当时作者需要处理 PCI passthrough 虚拟化而用到的 ELRepo 软件仓库，下面是提供给 CentOS 7.x 的网址：

- http://elrepo.org/tiki/tiki-index.php
- http://elrepo.org/linux/elrepo/el7/x86_64
- http://elrepo.org/linux/kernel/el7/x86_64

该软件库与其他软件库比较不同的地方在于该软件库提供的数据大多是核心、核心模块与虚拟化相关软件有关。例如 NVidia 的驱动程序也在里面，尤其提供了最小的核心（取名为 kernel-ml，就是 Linux 的核心）。

当然还有其他机构提供的软件仓库，这个就需要我们自己去寻找了。

那么我们怎么通过 EPEL 计划来安装 NetCDF 以及 R 软件呢？

1. 先针对 epel 进行 yum 配置文件处理

   ```bash
   # 我们新建一个文件
   [root@study ~]# vim /etc/yum.repos.d/epel.repo
   [epel]
   name=epel packages
   baseurl=https://dl.fedoraproject.org/pub/epel/7/x86_64/
   gpgcheck=0
   enabled=0
   ```

   这里默认是不启用该仓库的，只是未来有需要的时候才进行安装。

2. 使用该仓库来进行安装 netcdf 和 R 软件

   ```bash
   [root@study ~]# yum --enablerepo=epel install netcdf R
   
   # 未来当你不加上 --enablerepo=epel 时，这个 EPEL 的软件并不会更新
   ```

### 使用本机的原版光盘

比如你的主机没有网络，但是却有很多软件要安装，你的系统也都还没有任何升级的动作，这个时候，就可以使用本机的光盘作为软件来源。

首先，将你的光盘挂载到某个目录。这里假设挂载到  `/mnt` 了。如下编写配置文件

```bash
[root@study ~]# vim /etc/yum.repos.d/cdrom.repo
[mycdrom]
name=mycdrom
baseurl=file:///mnt
gpgcheck=0
enabled=0

[root@study ~]# yum --enablerepo=mycdrom install software_name
```

## 全系统自动升级

我们在安装软件的时候，都需要我们手动选择 yes/no 来决定是否升级，其实也可以使用 `-y` 参数自动应答 `yum -y update`，再配合 crontab 来达到系统自动升级软件的需求

```bash
[root@study ~]# echo '10 1 * * * root /usr/bin/yum -y --enablerepo=epel update' > /etc/cron.d/yumupdate
# 每天 1 点 10 分开始升级软件
```

## 管理的选择：RPM 还是 Tarball

这一直是一个有趣的问题：如果我要升级，或则是全新安装一个新的软件，选择 RPM 还是 Tarball 来安装？

这个问题考虑的因素有很多，作者通常是这样建议：

1. 优先选择原厂的 RPM 功能

   由于原厂释出的软件通常具有一段时间的维护期。

   比如：RHEL 与 CetnOS 每一个版本至少提供 5 年以上的更新期限，这对于我们的系统安全性来说，是在是非常棒。加上 yum 自动升级，易于安装、移除、升级等特点

2. 选择软件官网释出的 RPM 或则是提供的软件库

   软件太多，原厂并不会都包含，比如 CentOS 就没有提供 NTFS 的相关模块，此时你可以到官网去查询，看看有没有提供 RPM 文件，如果提供了软件库网址，就更方便了

3. 利用 Tarball 安装特殊软件

   某些特殊用途的软件并不会特别帮你制作 RPM 文件的，此时也不建议你自行制作 SRPM 来转成 RPM，因为太耗时。如果你的确有很多主机需要安装，那么将源码制作成 RPM 就很有价值了。

4. 用 Tarball 测试新版软件

   你可能想尝鲜或则使用新软件，但是原本厂商并没有提供新版的 RPM 包，此时你就可以使用 Tarball 安装到 `/usr/local` 下，而且大多数软件安装不同版本在系统上也不会有干扰。

## 基础服务管理：以 Apache 为例

在第 17 章谈到 systemd 的服务管理，那时仅使用 vsftpd 这个比较简单的服务来做示例。如今网络已经配置好，且有 yum 了，这里使用 www 服务的 httpd 来实践下

在默认的情况下，你无需修改服务的配置文件，通过默认值来处理你的服务即可，那么可以通过以下的流程来安装服务软件：

1. 安装：yum install 你的软件
2. 启动：systemctl start 你的软件
3. 开机启动：systemctl enable 你的软件
4. 防火墙 `firewall-cmd --add-service="你的服务"; firewall-cmd --permanent --add-service="你的服务"`
5. 测试：用软件去查阅你的服务是否正常

下面进行实践，一般来说 www 网站服务器需要有 www 服务器软件 + 网页程序语言 + 数据库系统 + 程序语言与数据库的链接软件等。在 CentOS 上，我们需要的软件就有 httpd + php + mariadb-server + php-mysql

```bash
# 0. 先检查软件是否有安装
[root@study ~]# rpm -q httpd php mariadb-server php-mysql
package httpd is not installed
package php is not installed
mariadb-server-5.5.64-1.el7.x86_64  # 这个安装好了，其他三个没有安装
package php-mysql is not installed

# 1. 安装所需要的软件
[root@study ~]# yum install httpd php mariadb-server php-mysql 

# 2.3 启动与开机启动
[root@study ~]# systemctl daemon-reload 
[root@study ~]# systemctl start httpd         
[root@study ~]# systemctl enable httpd
Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.
[root@study ~]# systemctl status httpd
* httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor preset: disabled)
   Active: active (running) since Thu 2020-04-09 23:03:04 CST; 21s ago
     Docs: man:httpd(8)
           man:apachectl(8)
 Main PID: 16641 (httpd)
   Status: "Total requests: 0; Current requests/sec: 0; Current traffic:   0 B/sec"
   CGroup: /system.slice/httpd.service
           |-16641 /usr/sbin/httpd -DFOREGROUND
           |-19479 /usr/sbin/httpd -DFOREGROUND
           |-19480 /usr/sbin/httpd -DFOREGROUND
           |-19481 /usr/sbin/httpd -DFOREGROUND
           |-19482 /usr/sbin/httpd -DFOREGROUND
           `-19483 /usr/sbin/httpd -DFOREGROUND

Apr 09 23:02:20 study.centos.mrcode systemd[1]: Starting The Apache HTTP Server...
Apr 09 23:03:04 study.centos.mrcode systemd[1]: Started The Apache HTTP Server.

# 4. 防火墙
[root@study ~]# firewall-cmd --list-all
public (active)
  target: default
  icmp-block-inversion: no
  interfaces: enp0s3 enp0s8
  sources: 
  services: dhcpv6-client ssh			# 这里还没有 http 的服务
  ports: 
  protocols: 
  masquerade: no
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules: 
# 下面开始配置  
[root@study ~]# firewall-cmd --add-service="http"; 
success
[root@study ~]# firewall-cmd --permanent --add-service="http"
success
[root@study ~]# firewall-cmd --list-all
public (active)
  target: default
  icmp-block-inversion: no
  interfaces: enp0s3 enp0s8
  sources: 
  services: dhcpv6-client http ssh		# 就出现在这里了
  ports: 
  protocols: 
  masquerade: no
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules: 
```

这个时候，在你的图形界面中浏览器中访问：http://localhost  就能看到一个网页了，也可以通过在宿主机中的浏览器访问虚拟机的 IP 地址，因为防火墙已经放行该服务了，通过 IP 也能访问到


## SRPM 的使用：rpmbuild

注意：默认为安装该软件，可通过 `yum install rpm-build` 安装

假如你有一个 SRPM 的文件，如何安装？如何修改 SPRM 里面的源码？如何重新编译？

## 利用默认值安装 SRPM 文件 (`--rebuild/--recompile`)

假如你有一个 SRPM 文件，不想修改里面的源码文件，可以直接编译安装

```bash
rpmbuild --rebuild xx.src.rpm
rpmbuild --recompile xx.src.rpm

主要选项有：
	--rebuild：仅执行「编译」与「打包」动作
	--recompile：执行「编译」「打包」「安装」动作
```

以上两个选项都没有修改过 SRPM 内的设置，仅通过再次编译来产生 RPM 可安装软件文件。一般来说，如果编译顺利的话，那么编译过程所产生的中间暂存盘会被自动删除，如果发生任何错误，则中间文件会被保留在系统上，以供我们除错使用

这里用 ntp 软件的 SRPM 来练习。在  [vault.centos.org](http://vault.centos.org/) 中选择你正确的 CentOS 版本，然后在 updates 软件看中选择 ntp 软件 SRPM，我这里选择了 http://vault.centos.org/7.0.1406/updates/Source/SPackages/ntp-4.2.6p5-19.el7.centos.src.rpm 的软件下载

```bash
# 下载软件
wget http://vault.centos.org/7.0.1406/updates/Source/SPackages/ntp-4.2.6p5-19.el7.centos.src.rpm

# 尝试直接编译
[root@study ~]# rpmbuild --rebuild /root/ntp-4.2.6p5-19.el7.centos.src.rpm 
warning: user mockbuild does not exist - using root
warning: group mockbuild does not exist - using root
...
error: Failed build dependencies:
        libcap-devel is needed by ntp-4.2.6p5-19.el7.x86_64
        openssl-devel is needed by ntp-4.2.6p5-19.el7.x86_64
        libedit-devel is needed by ntp-4.2.6p5-19.el7.x86_64
        pps-tools-devel is needed by ntp-4.2.6p5-19.el7.x86_64
        autogen is needed by ntp-4.2.6p5-19.el7.x86_64
        autogen-libopts-devel is needed by ntp-4.2.6p5-19.el7.x86_64
# 会告诉你有相依赖的软件未安装，
[root@study ~]# yum install libcap-devel openssl-devel libedit-devel pps-tools-devel autogen autogen-libopts-devel

# 再次尝试编译
[root@study ~]# rpmbuild --rebuild /root/ntp-4.2.6p5-19.el7.centos.src.rpm 
# 会经过一段漫长的时间进行编译
...
Checking for unpackaged file(s): /usr/lib/rpm/check-files /root/rpmbuild/BUILDROOT/ntp-4.2.6p5-19.el7.centos.x86_64
Wrote: /root/rpmbuild/RPMS/x86_64/ntp-4.2.6p5-19.el7.x86_64.rpm
Wrote: /root/rpmbuild/RPMS/noarch/ntp-perl-4.2.6p5-19.el7.noarch.rpm
Wrote: /root/rpmbuild/RPMS/x86_64/ntpdate-4.2.6p5-19.el7.x86_64.rpm
Wrote: /root/rpmbuild/RPMS/x86_64/sntp-4.2.6p5-19.el7.x86_64.rpm
Wrote: /root/rpmbuild/RPMS/noarch/ntp-doc-4.2.6p5-19.el7.noarch.rpm
Wrote: /root/rpmbuild/RPMS/x86_64/ntp-debuginfo-4.2.6p5-19.el7.x86_64.rpm
Executing(%clean): /bin/sh -e /var/tmp/rpm-tmp.8JAsU0
+ umask 022
+ cd /root/rpmbuild/BUILD
+ cd ntp-4.2.6p5
+ /usr/bin/rm -rf /root/rpmbuild/BUILDROOT/ntp-4.2.6p5-19.el7.centos.x86_64
+ exit 0
Executing(--clean): /bin/sh -e /var/tmp/rpm-tmp.Zz7sN6
+ umask 022
+ cd /root/rpmbuild/BUILD
+ rm -rf ntp-4.2.6p5
+ exit 0
# 可以看到上面输出了很多执行脚本和日志，包括输出到的目录
# 编译好的软件就会放置到
[root@study rpmbuild]# ll /root/rpmbuild/RPMS/x86_64/
total 2420
-rw-r--r--. 1 root root  552196 Apr 11 22:27 ntp-4.2.6p5-19.el7.x86_64.rpm
-rw-r--r--. 1 root root 1757652 Apr 11 22:27 ntp-debuginfo-4.2.6p5-19.el7.x86_64.rpm
-rw-r--r--. 1 root root   83060 Apr 11 22:27 ntpdate-4.2.6p5-19.el7.x86_64.rpm
-rw-r--r--. 1 root root   75392 Apr 11 22:27 sntp-4.2.6p5-19.el7.x86_64.rpm

```

这种方式，一般来说，因为该编译可能会根据你的系统硬件而优化，所以可能效果会好一点点，但是，人类可能感受不到这种优化带来的效果，所以一般不建议使用 SRPM 安装。那么当你找不到你这个 distribution 版本的软件时间，去别的 distribution 下载 SRPM 来安装，这样也算个方向。

一般来说，如果你有需要用到 SRPM 的文件，大部分的原因就是，你需要重新修改里面的某些设置，比如加入某些特殊的功能等。此时就需要将 SRPM 拆开，编辑里面的配置文件，再重新编译。下面来练习这种方式

## SRPM 使用的路径与需要的软件

SRPM 含有 source code，那么其中必定有配置文件，所以需要知道 SRPM 在进行编译的时候会用到哪些目录？由于每个用户应该都有能力安装自己的软件，因此 SRPM 安装、设置、编译、最终结果所使用的目录与操作者家目录有关系。比如，你使用 root 的身份来进行 SRPM 的操作，那么应该会用到下列的目录



- `/root/rpmbuild/SPECS/`：该软件的配置文件，例如软件的信息参数、设置项目等

- `/root/rpmbuild/SOURCES/`：软件的原始文件（`*.tar.gz 的文件`） 以及 config 配置文件
- `/root/rpmbuild/BUILD`/：在编译过程中，有些暂存的数据都会放置在该目录中
- `/root/rpmbuild/RPMS/`：经过编译之后，并且顺利编译成功之后，将打包完成的文件放在该目录中，包含了 x86_64，noarch... 等的次要目录
- `/root/rpmbuild/SRPMS/`：与 RPMS 目录相似，放置的是 SRPM 封装的文件

::: tip
以前只有 root 身份才能使用编译行为，同时源码都会放到 `/usr/src/redhat/`，如今放置在 `/~username/rpmbuild/` 目录下
:::

如果在编译过程中发生不明错误，会再 `/tmp` 下产生一个相对应的错误文件，可以根据该错误文件进行除错工作。如果编译成功，那么刚刚解压在上述几个目录中的文件都会被清理掉，只剩下`/root/rpmbuild/SRPMS/` 中编译好的文件了

由于 SRPM 需要重新编译，所以我们需要 [第 21 章中源码所需基础软件](../21/04.md) ，不要忘记安装

实践练习：将上个练习下载的 ntp 的 SRPM 软件直接安装到系统中（不要先编译），然后查阅下所有用到的目录有哪些

```bash
# 1. 这里使用 root 身份进行安装
[root@study ~]# rpm -ivh ntp-4.2.6p5-19.el7.centos.src.rpm 
Updating / installing...
   1:ntp-4.2.6p5-19.el7.centos        ################################# [100%]
warning: user mockbuild does not exist - using root
warning: group mockbuild does not exist - using root
# 这里的操作，之后，就直接被安装了，可以找到如下的说明，但是和上面的对不上
# 所以笔者这里有点疑惑，到底安装没有？
[root@study SPECS]# rpm -qa | grep ntp
ntpdate-4.2.6p5-29.el7.centos.x86_64


# 2. 查询 /root/rpmbuild 目录
[root@study ~]# ll -l /root/rpmbuild/
total 4
drwxr-xr-x. 2 root root    6 Apr 11 22:27 BUILD
drwxr-xr-x. 2 root root    6 Apr 11 22:27 BUILDROOT
drwxr-xr-x. 4 root root   34 Apr 11 22:27 RPMS
drwxr-xr-x. 2 root root 4096 Apr 11 22:32 SOURCES
drwxr-xr-x. 2 root root   22 Apr 11 22:32 SPECS    # 它最重要
drwxr-xr-x. 2 root root    6 Apr 11 22:24 SRPMS

[root@study ~]# ll -l /root/rpmbuild/{SOURCES,SPECS}
/root/rpmbuild/SOURCES:
total 4324
-rw-rw-r--. 1 root root     559 Dec 20  2014 ntp-4.2.4p7-getprecision.patch
-rw-rw-r--. 1 root root     661 Dec 20  2014 ntp-4.2.6p1-cmsgalign.patch
...

/root/rpmbuild/SPECS:
total 44
-rw-rw-r--. 1 root root 41210 Dec 20  2014 ntp.spec		# 该文件是重点

```

### 配置文件的主要内容 `*.spec`

前一个小节的练习，我们知道在 `/root.rembuild/SOURCES` 会放置原始文件 （tarball）以及相关的补丁文件（patch file），我们也知道编译需要的步骤大致是 `./configure,make,make check,make install` 等，那这些动作就写在 SPECS 目录中的

```bash
[root@study ~]# cd /root/rpmbuild/SPECS/
# 1. 这个部分在介绍整个软件的基本相关信息，版本，释出次数等

Summary: The NTP daemon and utilities		# 建议说明这个软件的功能
Name: ntp																# 软件名称
Version: 4.2.6p5												# 软件版本
Release: 19%{?dist}											# 软件的释出次数
# primary license (COPYRIGHT) : MIT			# 下面又很多 # 批注说明
....
License: (MIT and BSD and BSD with advertising) and GPLv2
Group: System Environment/Daemons
Source0: http://www.eecis.udel.edu/~ntp/ntp_spool/ntp4/ntp-4.2/ntp-%{version}.tar.gz
Source1: ntp.conf												# 写 SourceN 的就是源码文件
Source2: ntp.keys												# 源码与多个
....
# ntpbz #802														# 下面是不定文件，就是 PatchN
Patch1: ntp-4.2.6p1-sleep.patch
# add support for dropping root to ntpdate
Patch2: ntp-4.2.6p4-droproot.patch
.....

# 2. 这部分则是设置相依属性需求的地方

URL: http://www.ntp.org									# 下面说明这个软件的相依性
Requires(post): systemd-units						# 还有编译过程需要哪些软件等
Requires(preun): systemd-units
Requires(postun): systemd-units
Requires: ntpdate = %{version}-%{release}
BuildRequires: libcap-devel openssl-devel libedit-devel perl-HTML-Parser
BuildRequires: pps-tools-devel autogen autogen-libopts-devel systemd-units
.....
%package -n ntpdate											# 该软件包还包含很多次软件
Summary: Utility to set the date and time via NTP
Group: Applications/System
Requires(pre): shadow-utils
Requires(post): systemd-units
Requires(preun): systemd-units
Requires(postun): systemd-units
.....

# 3. 编译前的预处理，以及编译过程中所需要进行的指令，都写在这里
# 尤其是 %build 下的数据，几乎就是 makefile 里面的信息

%prep																	# 这部分大部分在处理补丁
%setup -q -a 5

%patch1 -p1 -b .sleep									# 这些 patch 与前面的 PatchN 有关
%patch2 -p1 -b .droproot
%patch3 -p1 -b .bcast
%patch4 -p1 -b .cmsgalign
......

%build																# 其实就是 ./configure、make 等动作
sed -i 's|$CFLAGS -Wstrict-overflow|$CFLAGS|' configure sntp/configure
export CFLAGS="$RPM_OPT_FLAGS -fPIE -fno-strict-aliasing -fno-strict-overflow"
export LDFLAGS="-pie -Wl,-z,relro,-z,now"
%configure \													# ./configure 的意思
        --sysconfdir=%{_sysconfdir}/ntp/crypto \
        --with-openssl-libdir=%{_libdir} \
        --without-ntpsnmpd \
        --enable-all-clocks --enable-parse-clocks \
        --enable-ntp-signd=%{_localstatedir}/run/ntp_signd \
        --disable-local-libopts
echo '#define KEYFILE "%{_sysconfdir}/ntp/keys"' >> ntpdate/ntpdate.h
echo '#define NTP_VAR "%{_localstatedir}/log/ntpstats/"' >> config.h

make %{?_smp_mflags}								# make 的意思

.....
%install														# 安装过程中所进行的各项动作了
make DESTDIR=$RPM_BUILD_ROOT bindir=%{_sbindir} install

mkdir -p $RPM_BUILD_ROOT%{_mandir}/man{5,8}
sed -i 's/sntp\.1/sntp\.8/' $RPM_BUILD_ROOT%{_mandir}/man1/sntp.1
mv $RPM_BUILD_ROOT%{_mandir}/man{1/sntp.1,8/sntp.8}
rm -rf $RPM_BUILD_ROOT%{_mandir}/man1

.......

# 4. 这里列出，这个软件释出的文件有哪些的意思

%files														# 这软件所属的文件有哪些
%dir %{ntpdocdir}
%{ntpdocdir}/COPYRIGHT
%{ntpdocdir}/ChangeLog
........

# 5. 列出这个软件的更改历史记录文件

%changelog
* Fri Dec 19 2014 CentOS Sources <bugs@centos.org> - 4.2.6p5-19.el7.centos
- rebrand vendorzone

```

要注意到的是 ntp.sepc 这个文件，这是主要的将 SRPM 编译成 RPM 的配置文件，它的基本规则可以这样看：

1. 整个文件的开头有 Summary 为开始，这部分的设置都是最基础的说明内容
2. 然后每个不同的段落之间，都以 `%` 来做开头，例如 `%prep` 与 `%install` 等

### 系统整体信息方面

刚刚在 ntp.sepc 中看到的就有以下的重要信息：

- Summary：软件的主要说明，例如上表中说明了本软件是针对 NTP 的软件功能与工具等
- Name：软件的名称（最终会是 RPM 文件的名称构成之一）
- Version：软件的版本（也是 RPM 文件名构成之一）
- Release：该版本打包的次数说明（也是 RPM 文件名构成之一）。由于我们想要修改下东西，所以将这里的 `19%{?dist}` 修改为 `20.mrcode`
- License：软件的授权模式，看起来涵盖了所有知名的 Open source 授权
- Group：该软件在安装的时候，主要放置到哪一个软件群组中（yum grouplist 的特点）
- URL：源码的主要官网
- SourceN：软件的来源，如果是网络上下载的软件，通常这里一定会有这个信息来告诉大家这个原始文件的来源，此外，如果有多个软件来源，则会以 Source0、Source1... 开处理源码
- PatchN：作为不定的 patch file，也是可以有多个
- BuildRoot：作为编译时，该使用哪个目录来暂存中间文件（如果编译过程的目标文件、链接文件等）

上述信息为必须存在的项目，下面的则为可使用的额外设置

- Requires：如果这个软件还需要其他的软件支持，就必须配置，则当你制作成 RPM 后，系统就会自动去检查，这就是相依属性的主要来源
- BuildRequires：编译过程中所需要的软件。Requires 指的是**安装时需要检查**，因为与实际运行有关，而 BuildRequires 则是 **编译时** 所需要的软件，只有在 SRPM 编译为 RPM 时才会检查的项目

根据上面的设置，最终的文件名会是 `{Name}-{Version}-{Release}.{Arch}.rpm` 的样式，以我们上面的设置来说，文件名应该会是 `ntp-4.2.6p5-20.mrcode.x86_64.rpm` 

- `%description`

  将你的软件做一个简短的说明，这个也是必须的，在使用 `rpm -qi 软件名称` 出现的一些基础说明就包括这里的设置信息

- `%prep`

  pre 这个关键词本就有「在...之前」的含义，因此该项目指「尚未进行设置或安装之前，你要编译完成的 RPM 帮你实现做的事情」，就是 prepare 的简写，它的主要事项有：

  1. 进行软件的补丁（patch）等相关工作
  2. 寻找软件所需要的目录是否已经存在？确认用的
  3. 事先建立你的软件所需要的目录，或则事先进行的任务
  4. 如果待安装的 Linux 系统内已经有安装的时候可能会被覆盖掉的文件时，那么久必须进行备份的工作

  在本例中，你会发现程序会使用 patch 去进行补丁的动作，所以程序的源码才会更新到最新

- `%build`

  该段落在配置 make 编译称为可执行的程序。会发现在此部分的程序代码，就是 `./configure,make` 等项目。一般来说，如果你会使用 SRPM 来进行重新编译的行为，**通常就是要重新 `./configure` 并给予新的参数设置，于是这部分就可能会修改**

- `%install`

  编译完成后，就要安装了，也就是类似 Tarball 里面的 make install

- `%files`

  这个软件安装的文件都需要写到这里来，也包括目录，以备查验用。此外也可以指定每个文件的类型，包括帮助文件（`%doc 后面接的文件`） 与配置文件 `%config 后面接的文件`

- `%changelog`

  主要记录该软件曾经的更新记录，星号 `*` 后面应该要以时间、修改者、email 与软件版本来作为说明，减号 `-` 后面则是你详细的说明，在这部分我们就新增了两行，内容如下

  ```bash
  %changelog
  # * 2020-04-11 mrcode <mrcode@mail.mrcode.cn> - 4.2.6p5-20.mrcode
  # 刚开始我如上写的，并没有按他们的规范写，在编译时间就报如下错误了
  [root@study SPECS]# rpmbuild -ba ntp.spec 
  error: bad date in %changelog: 2020-04-11 mrcode <mrcode@mail.mrcode.cn> - 4.2.6p5-20.mrcode
  
  # 所以正确的写入如下
  * Sat Apr 11 2020 Mrcode mrcode<mrcode@mail.mrcode.cn> - 4.2.6p5-20.mrcode
  - only rbuild this SRPM to RPM
  ```

修改到这里也差不多了，你也应该需要了解这个 ntp.spec 文件有多重要，当我们使用 rpm -q 查询一堆信息时，其实都是这里写入的。下面来了解如果将 SRPM 编译出来

## SRPM 的编译指令（`-ba、-bb`）

要将在 `/root/rpmbuild` 下的数据编译或则是单纯的打包为 RPM 或 SRPM 时，就需要 rpmbuild 指令与相关选项了，这里介绍两个常用选项

```bash
rpmbuild -ba ntp.spec  # 仅编译并同时产生 RPM 与 SRPM 文件
rpmbuild -bb ntp.spec  # 仅编译成 RPM 文件
```

这个时候，系统会这样做：

1. 先进入到 BUILD 目录，即 `/root/rpmbuild/BUILD`

2. 根据 `*.spec` 文件内的 Name 与 Version 定义出工作目录名称。

   以上面的例子为例，那么系统就会在 BUILD 目录中先删除 ntp-4.2.6p5 的目录，在重新建立一个 ntp-4.2.6p5 的目录，并进入该目录

3. 在新建的目录里面，针对 SOURCES 目录下的来源文件，也就是 `*.spec` 里面的 Source 设置的哪个文件，以 tar 进行解压缩

   以我们这个例子来说，则会在 `/root/rpmbuild.BUILD/ntp-4.2.6p5` 中，将 `/root/rpmbuild/SOURCES/ntp-*` 等多个源码文件进行解压缩

4. 在开始 `%build 和 %install` 的设置与编译

5. 最后将完成打包的文件放置到该放置的地方去，如果你的系统是 x86_64 的话，那么最后编译成功的 rpm 文件则会被放置在 ``/root/rpmbuild/RPMS/x86_64` 里面

大概过程如上，最后的结果数据会放置在 RPMS 目录下，我们这个案例中，要同时打包 RPM 与 SRPM，则可以如下操作

```bash
[root@study SPECS]# cd /root/rpmbuild/SPECS/
[root@study SPECS]# rpmbuild -ba ntp.spec 
....
Wrote: /root/rpmbuild/SRPMS/ntp-4.2.6p5-20.mrcode.src.rpm
Wrote: /root/rpmbuild/RPMS/x86_64/ntp-4.2.6p5-20.mrcode.x86_64.rpm
Wrote: /root/rpmbuild/RPMS/noarch/ntp-perl-4.2.6p5-20.mrcode.noarch.rpm
Wrote: /root/rpmbuild/RPMS/x86_64/ntpdate-4.2.6p5-20.mrcode.x86_64.rpm
Wrote: /root/rpmbuild/RPMS/x86_64/sntp-4.2.6p5-20.mrcode.x86_64.rpm
Wrote: /root/rpmbuild/RPMS/noarch/ntp-doc-4.2.6p5-20.mrcode.noarch.rpm
Wrote: /root/rpmbuild/RPMS/x86_64/ntp-debuginfo-4.2.6p5-20.mrcode.x86_64.rpm
Executing(%clean): /bin/sh -e /var/tmp/rpm-tmp.D7ojeA
+ umask 022
+ cd /root/rpmbuild/BUILD
+ cd ntp-4.2.6p5
+ /usr/bin/rm -rf /root/rpmbuild/BUILDROOT/ntp-4.2.6p5-20.mrcode.x86_64
+ exit 0

[root@study SPECS]# find /root/rpmbuild/ -name 'ntp*rpm'
/root/rpmbuild/RPMS/x86_64/ntp-4.2.6p5-19.el7.x86_64.rpm
/root/rpmbuild/RPMS/x86_64/ntpdate-4.2.6p5-19.el7.x86_64.rpm
/root/rpmbuild/RPMS/x86_64/ntp-debuginfo-4.2.6p5-19.el7.x86_64.rpm
/root/rpmbuild/RPMS/x86_64/ntp-4.2.6p5-20.x86_64.rpm
/root/rpmbuild/RPMS/x86_64/ntpdate-4.2.6p5-20.x86_64.rpm
/root/rpmbuild/RPMS/x86_64/ntp-debuginfo-4.2.6p5-20.x86_64.rpm
/root/rpmbuild/RPMS/x86_64/ntp-4.2.6p5-20.mrcode.x86_64.rpm
/root/rpmbuild/RPMS/x86_64/ntpdate-4.2.6p5-20.mrcode.x86_64.rpm
/root/rpmbuild/RPMS/x86_64/ntp-debuginfo-4.2.6p5-20.mrcode.x86_64.rpm
/root/rpmbuild/RPMS/noarch/ntp-perl-4.2.6p5-19.el7.noarch.rpm
/root/rpmbuild/RPMS/noarch/ntp-doc-4.2.6p5-19.el7.noarch.rpm
/root/rpmbuild/RPMS/noarch/ntp-perl-4.2.6p5-20.noarch.rpm
/root/rpmbuild/RPMS/noarch/ntp-doc-4.2.6p5-20.noarch.rpm
/root/rpmbuild/RPMS/noarch/ntp-perl-4.2.6p5-20.mrcode.noarch.rpm
/root/rpmbuild/RPMS/noarch/ntp-doc-4.2.6p5-20.mrcode.noarch.rpm
/root/rpmbuild/SRPMS/ntp-4.2.6p5-20.src.rpm
/root/rpmbuild/SRPMS/ntp-4.2.6p5-20.mrcode.src.rpm

# 就看到一件出现了我们的 20.mrcode 版本的软件了
# 有些文件软件是与硬件等级无关的，所以出现了 ntp-perl-4.2.6p5-20.mrcode.noarch.rpm 的 noarch 软件
```

## 制作一个我们自己的 SRPM 软件

在之前的小节中，我们 [编写了软件 main-0.1](../21/04.md)，把它制作成 main-0.1-1.x86_64.rpm

### 制作源码文件 tarball 产生

我们提供了 main-0.1 版本的软件，并提供了一个 main-0.2 的补丁文件，那么需要这样做：

- `main-0.1.tar.gz` 放在 `/root/rpmbuild/SOURCES/`
- `main-0.1-to-0.2.patch` 放在 `/root/rpmbuild/SOURCES/`
- `main.spec` 放在 `/root/rpmbuild/SPECS/`

```bash
# 1. 先来处理源码部分。假设你的 /root/rpmbuild/SOURCES/ 目录以及存在了
# 注意，如果 patch 部分报错，建议直接在之前章节中的下载链接下载
[root@study ~]# cd /root/
[root@study main-0.1]# tar -zcf main-0.1.tgz main-0.1
# 记得需要将目录打包
[root@study ~]# tar -ztv -f main-0.1.tgz 
drwxr-xr-x root/root         0 2020-04-12 11:28 main-0.1/
-r-------- root/root      4482 2020-04-12 11:06 main-0.1/cos_value.c
-r-------- root/root       101 2009-06-09 22:23 main-0.1/haha.c
-r-------- root/root       318 2020-04-12 10:58 main-0.1/main.c
-r-------- root/root       188 2020-04-12 10:58 main-0.1/Makefile
-r-------- root/root       186 2020-04-12 10:58 main-0.1/sin_value.c

[root@study ~]# cp main-0.1.tgz /root/rpmbuild/SOURCES/
[root@study ~]# cp main-0.1-to-0.2.patch /root/rpmbuild/SOURCES/
[root@study ~]# cd /root/rpmbuild/SOURCES/
[root@study SOURCES]# ll main-*
-rw-r--r--. 1 root root 9273 4月  12 11:07 main-0.1.tgz
-r--------. 1 root root 1538 4月  12 11:07 main-0.1-to-0.2.patch
```

### 建立 `*.spec` 的配置文件

这个文件的建立是所有 RPM 制作里面最重要的，需要认真编写。为了方便我们的制作，在 CentOS7 下，vim *.spec 的时候，如果该文件不存在，则会直接给我们一个模板

```bash
[root@study SOURCES]# cd /root/rpmbuild/SPECS/
# 下面的内容就是给我们的模板信息
[root@study SPECS]# vim main.spec
Name:
Version:
Release:        1%{?dist}
Summary:

Group:
License:
URL:
Source0:

BuildRequires:
Requires:

%description


%prep
%setup -q


%build
%configure
make %{?_smp_mflags}


%install
make install DESTDIR=%{buildroot}
%files
%doc



%changelog

# 下面开始编写信息
[root@study SPECS]# vim main.spec
Name: main
Version: 0.1
Release:        1%{?dist}
Summary: Shows sin and cos value.

Group: Scientific Support
License: GPLv2
URL: http:/mrcode.cn/
Source0: main-0.1.tgz							# 文件名一定要正确
Patch0: main-0.1-to-0.2.patch

# BuildRequires:		没有用到的一定要删掉，否则可能还是会识别到，并报错

%description
This package will let you input your name and calculate sin cos value

%prep
%setup -q
%patch0 -p1											# 要用来作为 patch 的动作


%build
make clean main									# 编译，不要安装

%install
mkdir -p %{buildroot}/usr/local/bin
install -m 755 main %{buildroot}/usr/local/bin			# 顺利的安装行为

%files
/usr/local/bin/main

%changelog
* Sat Apr 11 2020 Mrcode mrcode<mrcode@mail.mrcode.cn> - 4.2.6p5-20.mrcode
- build the program

```

### 编译成为 RPM 与 SRPM

前面的 spec 文件建立后，后续的动作就简单了

```bash
[root@study ~]# cd /root/rpmbuild/SPECS/

# 上面的 spec 文件太重要了，我是搞了 2 个小时，差不多才搞好
# 有写错命令的，有没有删除空配置项目的

[root@study SPECS]# rpmbuild -ba main.spec 
执行(%prep): /bin/sh -e /var/tmp/rpm-tmp.pZIZNq
+ umask 022
+ cd /root/rpmbuild/BUILD
+ cd /root/rpmbuild/BUILD
+ rm -rf main-0.1
+ /usr/bin/gzip -dc /root/rpmbuild/SOURCES/main-0.1.tgz
+ /usr/bin/tar -xf -
+ STATUS=0
+ '[' 0 -ne 0 ']'
+ cd main-0.1
+ /usr/bin/chmod -Rf a+rX,u+w,g-w,o-w .
+ echo 'Patch #0 (main-0.1-to-0.2.patch):'
Patch #0 (main-0.1-to-0.2.patch):
+ /usr/bin/patch -p1 --fuzz=0
+ /usr/bin/cat /root/rpmbuild/SOURCES/main-0.1-to-0.2.patch
patching file cos_value.c
patching file main.c
patching file Makefile
patching file sin_value.c
+ exit 0
执行(%build): /bin/sh -e /var/tmp/rpm-tmp.TXvVHo
+ umask 022
+ cd /root/rpmbuild/BUILD
+ cd main-0.1
+ make clean main
rm -f main main.o haha.o sin_value.o cos_value.o
cc    -c -o main.o main.c
cc    -c -o haha.o haha.c
cc    -c -o sin_value.o sin_value.c
cc    -c -o cos_value.o cos_value.c
gcc -o main main.o haha.o sin_value.o cos_value.o -lm
+ exit 0
执行(%install): /bin/sh -e /var/tmp/rpm-tmp.S8b0Xm
+ umask 022
+ cd /root/rpmbuild/BUILD
+ '[' /root/rpmbuild/BUILDROOT/main-0.1-1.el7.x86_64 '!=' / ']'
+ rm -rf /root/rpmbuild/BUILDROOT/main-0.1-1.el7.x86_64
++ dirname /root/rpmbuild/BUILDROOT/main-0.1-1.el7.x86_64
+ mkdir -p /root/rpmbuild/BUILDROOT
+ mkdir /root/rpmbuild/BUILDROOT/main-0.1-1.el7.x86_64
+ cd main-0.1
+ mkdir -p /root/rpmbuild/BUILDROOT/main-0.1-1.el7.x86_64/usr/local/bin
+ install -m 755 main /root/rpmbuild/BUILDROOT/main-0.1-1.el7.x86_64/usr/local/bin
+ /usr/lib/rpm/find-debuginfo.sh --strict-build-id -m --run-dwz --dwz-low-mem-die-limit 10000000 --dwz-max-die-limit 110000000 /root/rpmbuild/BUILD/main-0.1
extracting debug info from /root/rpmbuild/BUILDROOT/main-0.1-1.el7.x86_64/usr/local/bin/main
dwz: Too few files for multifile optimization
/usr/lib/rpm/sepdebugcrcfix: Updated 0 CRC32s, 1 CRC32s did match.
+ /usr/lib/rpm/check-buildroot
+ /usr/lib/rpm/redhat/brp-compress
+ /usr/lib/rpm/redhat/brp-strip-static-archive /usr/bin/strip
+ /usr/lib/rpm/brp-python-bytecompile /usr/bin/python 1
+ /usr/lib/rpm/redhat/brp-python-hardlink
+ /usr/lib/rpm/redhat/brp-java-repack-jars
处理文件：main-0.1-1.el7.x86_64
Provides: main = 0.1-1.el7 main(x86-64) = 0.1-1.el7
Requires(rpmlib): rpmlib(CompressedFileNames) <= 3.0.4-1 rpmlib(FileDigests) <= 4.6.0-1 rpmlib(PayloadFilesHavePrefix) <= 4.0-1
Requires: libc.so.6()(64bit) libc.so.6(GLIBC_2.2.5)(64bit) libc.so.6(GLIBC_2.7)(64bit) libm.so.6()(64bit) libm.so.6(GLIBC_2.2.5)(64bit) rtld(GNU_HASH)
处理文件：main-debuginfo-0.1-1.el7.x86_64
Provides: main-debuginfo = 0.1-1.el7 main-debuginfo(x86-64) = 0.1-1.el7
Requires(rpmlib): rpmlib(FileDigests) <= 4.6.0-1 rpmlib(PayloadFilesHavePrefix) <= 4.0-1 rpmlib(CompressedFileNames) <= 3.0.4-1
检查未打包文件：/usr/lib/rpm/check-files /root/rpmbuild/BUILDROOT/main-0.1-1.el7.x86_64
写道:/root/rpmbuild/SRPMS/main-0.1-1.el7.src.rpm
写道:/root/rpmbuild/RPMS/x86_64/main-0.1-1.el7.x86_64.rpm
写道:/root/rpmbuild/RPMS/x86_64/main-debuginfo-0.1-1.el7.x86_64.rpm
执行(%clean): /bin/sh -e /var/tmp/rpm-tmp.oIpzDR
+ umask 022
+ cd /root/rpmbuild/BUILD
+ cd main-0.1
+ /usr/bin/rm -rf /root/rpmbuild/BUILDROOT/main-0.1-1.el7.x86_64
+ exit 0
[root@study SPECS]# 

# 这就编译好了
[root@study SPECS]# ll /root/rpmbuild/RPMS/x86_64/main-*
-rw-r--r--. 1 root root 5428 4月  12 12:25 /root/rpmbuild/RPMS/x86_64/main-0.1-1.el7.x86_64.rpm
-rw-r--r--. 1 root root 4460 4月  12 12:25 /root/rpmbuild/RPMS/x86_64/main-debuginfo-0.1-1.el7.x86_64.rpm

[root@study SPECS]# ll /root/rpmbuild/SRPMS/main-*
-rw-r--r--. 1 root root 3724 4月  12 12:25 /root/rpmbuild/SRPMS/main-0.1-1.el7.src.rpm

```

### 安装、测试、实际查询

```bash
[root@study ~]# yum install /root/rpmbuild/RPMS/x86_64/main-0.1-1.el7.x86_64.rpm 
[root@study ~]# rpm -ql main 
/usr/local/bin/main

[root@study ~]# rpm -qi main 
Name        : main
Version     : 0.1
Release     : 1.el7
Architecture: x86_64
Install Date: Sun Apr 12 12:30:24 2020
Group       : Scientific Support
Size        : 7200
License     : GPLv2
Signature   : (none)
Source RPM  : main-0.1-1.el7.src.rpm
Build Date  : Sun Apr 12 12:25:11 2020
Build Host  : study.centos.mrcode
Relocations : (not relocatable)
URL         : http:/mrcode.cn/
Summary     : Shows sin and cos value.
Description :
This package will let you input your name and calculate sin cos value

# 这就从打包、制作、出来一个自己的软件了
```

## 重点回顾

- 为了避免使用者自行编译的困扰，开发商自行在特定的硬件与操作系统平台上预先编译好软件，并将软件以特殊的格式封包成文件，提供终端用户直接安装到固定的操作系统上，并提供简单的查询、安装、移除等流程。此称为软件管理员，常见的软件管理员有 RPM 与 DPKG 两大主流
- RPM 的全名是 RedHat Package Manager，原本是 Red Hat 公司所发展，流程甚光
- RPM 类型的软件中，所含有的软件是经过编译后的 binary program，所以可以直接安装在用户的系统上，不过，也由于如此，所以 RPM 对于安装者的环境要求相当严格
- RPM 除了将软件安装到用户的系统之外，还会将该软件的版本、名称、软件与目录配置、系统需求等数据就到数据库 `/var/lib/rpm` 中，方便未来的查询与升级、移除
- RPM 可针对不同的硬件等级来加以编译，制作出来的文件可以扩展名：i386、i586、i686、x86_64、noarch 来分辨
- RPM 最大的问题为软件之间的依赖问题
- SRPM 为 Source RPM，内含的文件为 Source code 而非 binary file，所以安装 SRPM 时，还需要经过 compile，不过，SRPM 最大的优点就是让使用者自行修改设置参数 `makefile、configure 的参数`，以符合使用者自己的 Linux 环境
- RPM 软件的属性相依问题，已经开源由 yum 或则是 APT 等方式加以克服。CentOS 使用的是 yum 方式
- yum 服务器提供多个不同的软件库放置个别软件，以提供客户端分别管理软件类别 


## 本章习题

## 情景模拟题

通过 EPEL 安装 NTFS 文件系统所需要的软件

- 目标：利用 EPEL 提供的软件库来搜索是否有 NTFS 所需要的各项模块
- 目标：你的 LInux 必须要已经接上 internet 才行
- 需求：最好了解磁盘容量是否够用，以及如何启动服务等

前面小节讲过之后，就非常简单了，配置好 yum 的仓库软件库后，使用下面的指令来安装即可

```bash
# 找出所需要的软件名称
yum --enablerepo=epel search ngfs

# 安装
yum --enablerepo=epel install ntfs-3g ntfsprogs 来安装即可
```

## 简单题部分

- 如果你曾经修改过 yum 配置文件内的软件库设置（`/etc/yum.repos.d/*.repo`），导致下次使用 yum 进行安装时老发现错误，此时你这么做？

  先确认你的配置文件确实是正确的，如果没有问题，可以将 yum 的缓存清除，使用 `yum clean all`.  事实上清空的是 `/var/cache/yum/` 目录

- 简单说明 RPM 与 SRPM 的异同

  - RPM：有程序打包者，通过程序源码，在特定的平台上编译成功的 binary program 数据，并将该数据制作成 RPM 格式，方便相同软、硬件平台的用户安装使用。在安装时显得很简单，因为程序打包者的平台与使用者的平台预设为相同

  - SRPM：是通过 RPM 相同的配置文件数据，不过将源码直接抱在 SRPM 文件中，而不经过编译。因为 SRPM 所内含的数据为源码，所以安装时，必须要再经过编译的行为才能成为 RPM 并提供使用者安装

  - 假设我想要安装一个软件，例如 pkgname.i386.rpm ，但却老是发生无法安装的问题，可以加入哪些参数来强制安装它？

    可以加入 `--nodeps` 等参数。例如 `rpm -ivh --nodeps pkgname.i386.rpm`

  - 承上题，强制安装之后，该软件是否可以正常执行？为什么？

    一般来说，应该是不能执行的，因为软件具有依赖属性的问题，如果依赖的软件未安装，那么涉及到这部分的时候，就无法运行

  - 有些人使用 CentOS 7.x 安装在自己的 Atom CPU 上，却发现无法安装，在查询了该原版光盘的内容后，发现里面的文件名为 `***.x86_64.rpm` 。无法安装的可能原因是？

    Atom 虽然也属于 x86 的架构，但是某些 atom 属于 32 位的系统。 CentOS7 仅支持 64 位了，所以无法安装了

  - 使用 `rpm -Fvh *.rpm` 和 `rpm -Uvh *.rpm` 来升级时，两者有何不同？

    - `-Fvh`：后面接的软件，如果原本未安装，则直接安装，已安装则直接升级
    - `-Uvh`：后面接的软件，如果原本未安装，则不安装，已安装时，则直接升级

  - 假设有一个厂商推出软件时，自行处理了数字签名，你要安装他们的软件，所以需要数字签名，如果他们的签名文件为 signe，如何安装它？

    ```bash
    rpm -import signe
    ```

  - 承上，假设该软件厂商提供了 yum 的安装网址为 `http://their.server.name/path/` 那么如何处理 yum 的配置文件？

    自行创建一个配置文件 `/etc/yum.repos.d/therir.repo` ，配置如下：

    ```bash
    [their]
    name=their server name
    baseurl=http://their.server.name/path/
    enable=1
    gpgcheck=0
    ```

    然后使用 yum 安装该软件