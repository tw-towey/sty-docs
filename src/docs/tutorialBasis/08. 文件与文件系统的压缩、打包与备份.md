# 文件与文件系统的压缩、打包与备份

# 压缩文件的用途与技术

文件压缩技术一般用于的场景是：当文件容量很大的时候，想要降低一些容量，在网络中传输时间少，当然下载的人就能更快的下载完，还有数据归档使用 cd 或则 dvd 来存储，但是某些单一文件比这些传统的一次性存储媒体还要大、等等的场景。

简单说就是：这些大型文件通过压缩技术之后，可以将他的磁盘使用量降低，达到减低文件容量的效果

## 文件压缩的原理是什么？

计算机最小的计量单位是 bits，不过目前我们使用的计算机系统中都是使用 bytes 单位来计量的，1 bytes=8bits，计算机存储文件是二进制的，当这个 8 bits 中没有被填满时，就会出现大量的 bit 被 0 填充，实际上他们是没有什么意义的，一些工程师利用一些复杂的计算方式，将这些没有使用到的空间去掉，来达到让文件占用空间变小的目的，这就是 **压缩技术**

还有一种压缩技术是将重复的数据进行统计记录。比如：你的数据为「1111....」有 100 个 1，压缩技术会记录「100 个 1」，而不是真的写了 100 个 1 出来。这样也能达到减少文件体积的目的

简单说：文件里面有相当多的「空间」存在，并不是完全填满的，而压缩技术就是将这「空间」填满，让整个文件占用的容量下降。但是被压缩过的文件无法被直接使用，需要还原回未压缩前的模样，这就是 **解压缩** 技术。

压缩后与压缩的文件所占用的磁盘空间大小，就可以被称为是「压缩比」，更多的技术可以查阅 [GZIP 文件格式规范](https://www.ietf.org/rfc/rfc1952.txt) 

解压缩有什么好处呢？Linux 3.10.81（CentOS 7 用的延伸版本）完整核心大小约 570MB 左右，由于核心主要多是 ASCII code 的纯文本形态文件，这种文件的「多余空间」是比较多的。那么压缩之后的核心仅有 76MB 左右，相差几倍。网络传输时间减少，你的磁盘占用也减少。


# Linux 系统常用的压缩指令

在 linux 环境中，压缩文件的扩展名大多是：.tar、.tar.gz、.tgz、.Z、.bz2、.xz ，为什么会有这么多？

虽然在 linux 下扩展名没有啥作用，但是支持的压缩指令非常多，彼此之间无法互通压缩或解压缩，扩展名用于分别是使用哪种软件来解压缩。常用的扩展名如下：

- .Z：compress 程序压缩的文件
- .zip：zip 程序压缩的文件
- .gz：gzip 程序压缩的文件
- .bz2：bzip2 程序压缩的文件
- .xz：xz 程序压缩的文件
- .tar：tar 程序打包的数据，并没有压缩过
- .tar.gz：tar 程序打包的数据，并经过 gzip 的压缩
- .tar.bz2：同上，经过了 bzip2 压缩
- .tar.xz：同上，经过了 xz 的压缩

linux 上常见的压缩指令是 gzip、bzip2 以及最新的 xz，还有支持 windows 的 zip，至于其他的压缩指令基本上都淘汰了。这些指令通常仅能针对一个文件来压缩与解压缩，如此一来每次压缩与解压缩都要一大堆文件，所以 tar （打包）软件就出现了

tar 可以将很多文件「打包」成为一个文件，将很多文件集结为一个文件，但是没有提供压缩的功能，后来 GNU 计划中，将整个 tar 与压缩的功能结合在一起，提供了更强大的压缩与打包功能。

## gzip、zcat/zmore/zless/zgrep

gzip 可以说是应用最广的压缩指令，目前可用解开 compress、zip 与 gzip 等软件所压缩的文件，语法如下

```bash
gzip [-cdtv#] 文档名
zcat 文档名.gz
```

选项与参数：

- c：将压缩的数据输出到屏幕上，可通过数据流重导向来处理
- d：解压缩的参数
- t：可以用来检验一个压缩文件的一致性，看看文件有无错误
- v：可以显示出原文件、压缩文件的压缩比等信息
- `#`：为数字的意思，代表压缩等级
  - -1：最快，但是压缩比最差
  - -9：最慢，但是压缩比最好
  - -6：默认值

实践练习

```bash
# 找出 /etc 下（不含子目录）容量最大的文件，并将他们复制到 /tmp,然后以 gzip 压缩
# S 排序时按文件 size，r 翻转，倒序；对于参数，笔者这里使用 man ls 查看的参数说明，记不住的时候就可以这样做
# ls -ldSr /etc/* 最大的排在最后，莫非使用了 S 就是降序排列的吗？
[mrcode@study ~]$ ls -ldS /etc/*
-rw-r--r--.  1 root root   670293 Jun  7  2013 /etc/services
-rw-r--r--.  1 root root   104251 Oct  4 18:28 /etc/ld.so.cache

[mrcode@study ~]$ cd /tmp/
[mrcode@study tmp]$ cp /etc/services .
[mrcode@study tmp]$ gzip -v services 
services:        79.7% -- replaced with services.gz
[mrcode@study tmp]$ ll /etc/services /tmp/services*
-rw-r--r--. 1 root   root   670293 Jun  7  2013 /etc/services
-rw-r--r--. 1 mrcode mrcode 136088 Oct 28 22:39 /tmp/services.gz
# 可以看到压缩比为 79.7，压缩之后变成了 130 多 k
```

这里需要注意，使用 gzip 进行压缩时，默认状态下原本的文件会被压缩成 .gz 的文件，并且原始文件不存在了（文案已经提示了）；另外 gzip 压缩的文件在 windows 中可以被 WinRAR、7zip 软件解压缩

```bash
# 由于 services 是文件内容，将压缩后的文件内容读出来
zcat services.gz  
# 该文件过大，直接读完，我们看不到最前面的内容了
# 可以使用 zmore、zless 去读取

# 将 services.gz 加压缩
# 这里使用 -d 来解压缩，还有一个 gunzip 指令也可以解压缩，但是有点难记住它
[mrcode@study tmp]$ gzip -d services.gz 
[mrcode@study tmp]$ ll -l services*
# 同样，默认会将 .gz 的删除，剩下原来的文件名
-rw-r--r--. 1 mrcode mrcode 670293 Oct 28 22:39 services

# 将上面解开的文件，使用最佳压缩比压缩，并保留原文件
# 这个例子就明白 -c 使用数据流重导来处理是啥意思了，压缩输出到指定文件中
# 这里的 > 后续再 bash 章节会详细讲解
[mrcode@study tmp]$ gzip -9 -c services > services.gz
[mrcode@study tmp]$ ll -l services*
-rw-r--r--. 1 mrcode mrcode 670293 Oct 28 22:39 services
-rw-rw-r--. 1 mrcode mrcode 135489 Oct 28 22:50 services.gz

# 还可以在 services.gz 找那个找出 http 关键词在哪里（关键词搜索）
[mrcode@study tmp]$ zgrep -n 'http' services.gz 
# 下面会输出好多包含 http 的信息
14:#       http://www.iana.org/assignments/port-numbers
89:http            80/tcp          www www-http    # WorldWideWeb HTTP
```

在压缩文档中搜索字符的话可以使用 zgrep、egrep 等指令

## bzip2、bzcat/bzmore/bzgrep

bzip2 可以说是取代了 gzip 并提供更佳的压缩比。使用方式几乎与 gzip 相同

```bash
bzip2 [-cdkzv#] 文档名
bzcat 文档名.bz2
```

选项与参数：

- c：将压缩的过程产生的数据输出到屏幕上
- d：解压缩的参数
- k：保留源文件
- z：压缩的参数（默认值，可以不加）
- v：可以显示出源文件/压缩文件的压缩比信息
- `#`：与 gzip 一样，-9 最佳、-1 最快

实践练习

```bash
[mrcode@study tmp]$ bzip2 -v services
  services:  5.409:1,  1.479 bits/byte, 81.51% saved, 670293 in, 123932 out.
[mrcode@study tmp]$ ll -l services*
-rw-r--r--. 1 mrcode mrcode 123932 Oct 28 22:39 services.bz2
-rw-rw-r--. 1 mrcode mrcode 135489 Oct 28 22:50 services.gz
# bz2 的压缩率比 gz 的压缩率还要好，看文件大小

# 读取 bz2 文件内容
bzcat services.bz2
# 解压,默认都是会删除掉原文件，包括压缩也是
[mrcode@study tmp]$ bzip2 -d services.bz2 
[mrcode@study tmp]$ ls -l services*
-rw-r--r--. 1 mrcode mrcode 670293 Oct 28 22:39 services
-rw-rw-r--. 1 mrcode mrcode 135489 Oct 28 22:50 services.gz

# 这里使用 -k 参数来保留源文件，并使用最优压缩比
# 还可以使用 -c 来输出 bzip2 -9 -c services > services.gz
[mrcode@study tmp]$ bzip2 -9 -k services
[mrcode@study tmp]$ ls -l services*
-rw-r--r--. 1 mrcode mrcode 670293 Oct 28 22:39 services
-rw-r--r--. 1 mrcode mrcode 123932 Oct 28 22:39 services.bz2

```

使用方式 bzip2 与 gzip 几乎一模一样，不过压缩率好的一般都会更耗时

## xz、xzcat/xzmore/xzless/xzgrep

xz 比 bzip2 压缩比更高，用法也与 bzip2、gzip 就一模一样

```bash
xz [-dtlkc#] 文档名
xcat 文档名.xz
```

选项与参数：

- d：解压缩
- t：测试压缩文件的完整性，看是否有错误
- l：列出压缩文件的相关信息
- k：保留原本的文件
- c：将数据由屏幕上输出
- `#`：同样，压缩比数值

```bash
# 压缩
[mrcode@study tmp]$ xz -v services
services (1/1)
  100 %        97.3 KiB / 654.6 KiB = 0.149                                    
[mrcode@study tmp]$ ls -l services*
-rw-r--r--. 1 mrcode mrcode 123932 Oct 28 22:39 services.bz2
-rw-rw-r--. 1 mrcode mrcode 135489 Oct 28 22:50 services.gz
-rw-r--r--. 1 mrcode mrcode  99608 Oct 28 22:39 services.xz
# 看看上面的压缩，果真 xz 压缩比是最好的
# 列出压缩文件信息
[mrcode@study tmp]$ xz -l services.xz 
Strms  Blocks   Compressed Uncompressed  Ratio  Check   Filename
    1       1     97.3 KiB    654.6 KiB  0.149  CRC64   services.xz

# 读取压缩文件内容
 xzless services.xz 、xzcat services.xz 都可以
# 解压缩
[mrcode@study tmp]$ xz -d services.xz 
# 使用 -k 压缩并保留源文件
[mrcode@study tmp]$ xz -k services


# 可以使用 time 指令统计他们的时间
# time [gzip|bzip2|xz] -c services > services.[gz|bz2|xz]
# 上面的语法，下面是实际的指令
[mrcode@study tmp]$ time gzip -c services > services.gz;\
> time bzip2 -c services > services.bz2;\
> time xz -c services > services.xz ;
real    0m0.023s	# 看这个汇总时间
user    0m0.021s
sys     0m0.002s

real    0m0.043s
user    0m0.036s
sys     0m0.007s

real    0m0.232s		# 看这个汇总时间
user    0m0.227s
sys     0m0.005s

一个 0.023s 一个 0.232s，相差 10 倍
```

# 打包指令：tar

前面讲解的 gzip、bzip2、xz 也能够针对目录进行压缩，但是是将目录内所有文件 **分别** 压缩的。而在 windows 下可以使用 winRAR 之类的压缩文件，将好多数据包成一个文件的样式。

这种将多个文件或目录包成一个大文件的指令功能，就可以称呼为 **打包指令**，tar 就是这样一个功能的打包指令，同时还可以通过压缩指令将该文件进行压缩。windows 中的 WinRAR 也支持 .tar.gz 的解压缩

tar 的选项与参数非常多，这里只接受几个常用的选项

```bash
打包与压缩：`tar [-z|-j|-J][cv][-f 待建立的文件名] filename`
观察文件：  `tar [-z|-j|-J][tv][-f file.tar]`
解压缩：	  `tar [-z|-j|-J][xf][-f file.tar] [-C 目录]`

特别注意：`[-z|-j|-J]` 不可同时出现在一串指令中
特殊注意：c、t、x 也不可同时出现在一串指令中
```

选项与参数

- c：建立打包文件，可搭配 `-v`来观察过程中被打包的文件名
- t：查看打包文件的内容含有哪些文件，重点在查看文件名
- x：接打包或解压缩的功能，可搭配 -C 在特定目录解开，特别注意 **c、t、x 不能同时出现在一起**
- z：通过 gzip 的支持进行压缩、解压缩；此时文件名最好为 `*.tar.gz`
- j：通过 bzip2 的支持进行压缩、解压缩；此时文件名最好为 `*.tar.bz2`
- J：通过 xz  的支持进行压缩、解压缩；此时文件名最好为 `*.tar.xz`
- v：在压缩、解压缩的过程中，将正在处理的文件名显示出来
- f：后面要立刻接要被处理的文件名，建议 -f 单独写一个选项（不容易忘记）
- C：在指定目录解压缩
- p：保留备份数据的原本权限与属性，常用语备份（-c）重要的配置文件
- P：保留绝对路径，保留 root 跟路径
- `--exclude=FILE`：在压缩过程中，排除指定的文件，不打包

最常用的是以下命令：

- 压    缩：`tar -jcv -f filename.tar.bz2 要被压缩的文件或目录`
- 查    询：`tar -jtv -f filename.tar.bz2`
- 解压缩：`tar -jxv -f filename.tar.bz2 -C 指定目录解开`

小提示：上面 -jcvf 可以写一起，但是阅读起来就没有上面这样分开好理解



## 使用 tar 加入 -z、-j 或 -J 的参数备份 /etc/ 目录

```bash
# 备份 /etc/ 需要 root 权限，否则会出现一堆错误
[mrcode@study ~]$ su -
Password:
Last login: Sun Oct 27 20:38:34 CST 2019 on pts/0

[root@study ~]# time tar -zpcv -f /root/etc.tar.gz /etc
tar: 从成员名中删除开头的“/”		# 注意这里的警告
/etc/
/etc/fstab
/etc/crypttab
...
real    0m2.329s		# 耗时 2.329 秒
user    0m1.322s
sys     0m0.308s

# -p 重点是保留文件的权限与属性
# 下面去掉了 -v，所以不会显示处理的文件名
[root@study ~]# time tar -jpc -f /root/etc.tar.bz2 /etc
tar: 从成员名中删除开头的“/”

real    0m3.012s
user    0m2.710s
sys     0m0.078s

[root@study ~]# time tar -Jpc -f /root/etc.tar.xz /etc
tar: 从成员名中删除开头的“/”

real    0m14.836s
user    0m13.511s
sys     0m0.224s

[root@study ~]# ll -h /root/etc*
-rw-r--r--. 1 root root  11M 10月 29 00:05 /root/etc.tar.bz2
-rw-r--r--. 1 root root  12M 10月 29 00:01 /root/etc.tar.gz
-rw-r--r--. 1 root root 8.2M 10月 29 00:06 /root/etc.tar.xz

# etc 占用 42M
[root@study ~]# du -sh /etc/
42M     /etc/

```

前面讲解 cp 指令复制的时候也涉及到复制后的文件权限与属性问题，这里的 -p 选项也是这样



## 查阅 tar 文件的数据内容（可查看文件名）与备份文件名是否有根目录的意义

```bash
# -v 把权限属性也列出来了
# 这里查看文件名前面无根路径的
[root@study ~]# tar -jtv -f /root/etc.tar.bz2
drwxr-xr-x root/root         0 2019-10-04 18:38 etc/
-rw-r--r-- root/root       808 2019-10-27 22:43 etc/fstab
-rw------- root/root         0 2019-10-04 18:20 etc/crypttab
lrwxrwxrwx root/root         0 2019-10-04 18:20 etc/mtab -> /proc/self/mounts
-rw-r--r-- root/root        51 2019-10-04 18:20 etc/resolv.conf
```

为什么需要拿到根目录呢？主要是为了安全，使用 tar 备份的数据可能会需要解压缩回来使用，在 tar 所记录的文件名（上面 -jtv 显示的文件名）就是解压缩后的实际文件名。如果拿到了根目录，则会在当前目录解压。比如现在在 /tmp ，解压后就变成 /tmp/etc/xxx；如果不拿掉根目录，源文件就被覆盖了

```bash
[root@study ~]# tar -jPc -f /root/etc.and.root.tar.bz2 /etc
[root@study ~]# tar -jtv -f /root/etc.and.root.tar.bz2
[root@study ~]# tar -jtv -f /root/etc.and.root.tar.bz2
tar: 从成员名中删除开头的“/”
drwxr-xr-x root/root         0 2019-10-04 18:38 /etc/
-rw-r--r-- root/root       808 2019-10-27 22:43 /etc/fstab
-rw------- root/root         0 2019-10-04 18:20 /etc/crypttab
lrwxrwxrwx root/root         0 2019-10-04 18:20 /etc/mtab -> /proc/self/mounts
# 对比下，确实是带上了根路径
```

## 将备份的数据解压缩，并考虑指定目录压缩（-C 选项的应用）

```bash
[root@study ~]# pwd
/root
[root@study ~]# tar -jx -f etc.tar.bz2
[root@study ~]# ll -d etc*
drwxr-xr-x. 143 root root     8192 10月  4 18:38 etc
-rw-r--r--.   1 root root 10520237 10月 29 00:15 etc.and.root.tar.bz2
-rw-r--r--.   1 root root 10518433 10月 29 00:05 etc.tar.bz2
-rw-r--r--.   1 root root 12212046 10月 29 00:01 etc.tar.gz
-rw-r--r--.   1 root root  8580036 10月 29 00:06 etc.tar.xz

# 解压到指定目录
tar -zx -f etc.tar.gz -C /tmp
# 记得删除解压后的文件
rm -rf /tmp/etc/ /root/etc
```

## 仅解开单一文件

前面讲解的都是解开该压缩包中的所有文件。

```bash
# 利用 -t 查看文件名，接管道查找 shadow
[root@study ~]# tar -jtv -f /root/etc.tar.bz2 | grep 'shadow'
---------- root/root      1271 2019-10-04 18:31 etc/shadow-
---------- root/root       797 2019-10-04 18:31 etc/gshadow
---------- root/root      1266 2019-10-04 18:31 etc/shadow 		# 假设要提取出这个文件
---------- root/root       791 2019-10-04 18:31 etc/gshadow-

# 后面接需要提取出来的文件路径
[root@study ~]# tar -jxv -f /root/etc.tar.bz2 etc/shadow
etc/shadow
[root@study ~]# ll etc
总用量 4
----------. 1 root root 1266 10月  4 18:31 shadow

```

## 打包某目录，但不包含该目录下的某些文件

```bash
[root@study ~]# tar -jc -f /root/system.tar.bz2 --exclude=/root/etc* --exclude=/root/system.tar.bz2 /etc /root
tar: 从成员名中删除开头的“/”
tar: 从硬连接目标中删除开头的“/”

```

## 仅备份比某个时刻还要新的文件

```bash
# 先找出比 /etc/passwd 还要新的文件
# 前面 touch 中介绍过 --newer 和 --newer-mtime
# newer 包含 mtime 和 ctime，而 --newer-mtime 只包含 mtime
[root@study ~]# find /etc -newer /etc/passwd
/etc
/etc/fstab
/etc/group
/etc/gshadow
...

[root@study ~]# ls --full-time  /etc/passwd
-rw-r--r--. 1 root root 2323 2019-10-04 18:31:08.332738182 +0800 /etc/passwd

[root@study ~]# tar -jcv -f /root/etc.newer.the.passwd.tar.bz2 --newer-mtime="2019-10-04" /etc/*
tar: 选项 --newer-mtime: 将日期 ‘2019-10-04’ 当作 2019-10-04 00:00:00
tar: 从成员名中删除开头的“/”
/etc/abrt/
tar: /etc/abrt/abrt-action-save-package-data.conf: 文件未改变；未输出
tar: /etc/abrt/abrt.conf: 文件未改变；未输出
tar: /etc/abrt/gpg_keys.conf: 文件未改变；未输出

# 验证下是否被打进去了，这里搜索都搜不到，确实没有被打进去
[root@study ~]# tar -jtv -f etc.newer.the.passwd.tar.bz2 | grep 'etc/abrt/abrt.conf'
[root@study ~]# tar -jtv -f etc.newer.the.passwd.tar.bz2 | grep 'abrt.conf'
```

可以进行差异文件的记录与备份，例如：在一个月前进行过一次完整的数据备份，那么这个月备份至需要备份更改过的文件即可，直接写到上次备份的时间点即可

## 基本名称：tarfile、tarball？

tar 可以只打包不压缩 `tar -c -f file.tar`，这种文件称为 tarfile，如果有压缩就称为 tarball。

此外 tar 还可以将文件打包到特别的装置中去，例如，`tar -c -f /dev/st0/home /root/etc` ,把 etc 打包到磁带机去（磁带机是一次性读取、写入装置，因此不能使用 cp 等指令）

## 特殊应用：利用管线命令与数据流

关于数据流重导向与管线命令在胡须 bash 章节再详细讲解

```bash
[mrcode@study ~]$ cd /tmp/
[mrcode@study tmp]$ tar -cv -f - /etc/ | tar -xv -f -
# 前面是将 /etc/ 打包到 - ，后面是吧 - 解压
# 这里的 - 表示标准的输出 和输出，可以吧 - 想成是内存中的一个缓冲区
# 这里命令像  cp -r /etc /tmp 的效果
# 这里不想用 -r 命令，所以使用 tar 打包到特殊的装置 - 中，然后管线前面输出的作为后面用来解压，没有产生中间文件，完成了复制的功能
```

# # 例题：系统备份范例

系统上有非常多的目录需要进行备份，也不建议将备份数据放到 /root 目录下，假设目前已经知道重要的目录有：

- `/etc/`：配置文件
- `/home/` ：用户的家目录
- `/var/spool/mail/`：系统中所有的邮件信箱
- `/var/spool/cron/`：所有账户的工作排成配置文件
- `/root/`：系统管理员的家目录

前面做过的练习，/home/loop* 不需要备份，/root 下的压缩文件也不需要备份，假设需要将备份的数据放到 /backups 中，并且该目录仅有 root 权限进入，此外，每次备份的文件名希望不相同。

```bash
# 创建备份目录，并修改权限
[root@study ~]# mkdir /backups
[root@study ~]# chmod 700 /backups/
[root@study ~]# ll -d /backups/
drwx------. 2 root root 6 10月 29 01:33 /backups/

# 这里的 xxx 需要手动写上想要的日期等字符串每次就不一样了，并不是用脚本变量啥的
tar -zcv -f /backups/xxx.tar.gz --exclude="/home/loop*" --exclude="/root/*.gz" --exclude="/root/*.bz2" --exclude="/root/*.xz" /etc/ /home/ /var/spool/mail /var/spool/cron /root 

[root@study ~]# ll -h /backups/
总用量 13M
-rw-r--r--. 1 root root 13M 10月 29 01:37 xxx.tar.gz

```

## 解压缩后的 SELinux 课题

假如你的系统必须要以备份的数据来回填到原本的系统中，那么需要特别注意复原后的系统 SELinux 问题，尤其是在系统文件上面。比如：/etc 下的文件群。SElinux 是比较特别的细部权限设定，具体的会在第 16 章介绍。SELinux 的权限问题，可能让你的系统无法存取某些配置文件内容，导致影响到系统的正常使用权。

有一个例子，通过上面的 tar 备份，然后在另外一部系统上还原回来，但是无法正常的登录系统，在单位维护模式去操作系统，看起来一切都正常，但是这里就是无法登录。大部分原因就是因为 /etc/shadow 密码文件的 SELinux 类型在还原时被更改了，简单的处理方式有如下几个：

- 通过各种可行的救援方式登录系统，修改 /etc/seliux/config 文件，将 SELinux 改成 permissive 模式，重新启动系统就可以了
- 在第一次复原系统后，不要立即重新启动，先使用 `restorecon  -Rv /etc` 自动修复下 SELinux 的类型即可
- 通过各种可行的方式登录系统，建立 /.autorelabel 文件，重新启动后系统会自动修复 SELinux 的类型，并且又会再次重新启动，之后就正常了

# XFS 文件系统的备份与还原

使用 tar 通常是针对目录树系统来进行备份的工作，如果是针对整个文件系统来进行备份与还原。在 CentOS 7 中可以使用 xfsdump 与 xfsrestore 指令来进行

## XFS 文件系统备份 xfsdump

支持的功能：

- 全量备份：完整备份文件系统（full backup）

- 增量备份：Incremental backup

  第一次全量备份之后，就可以选择增量备份了

  增量备份的差异文件存放在 /var/lib/xfsdump/inventory 中

xfsdump 有如下限制：

- 不支持没有挂载的文件系统备份，所以只能备份已挂载的
- 必须使用 root 的权限才能操作，涉及文件系统的关系
- 只能备份 XFS 文件系统
- 备份下来的数据（文件或存储媒体）只能让 xfsrestore 解析
- 是通过文件系统的 UUID 来分辨各个备份档的，因此不能备份两个具有相同 UUID 的文件系统

简单操作时的语法如下（完整的选项非常复杂）

```bash
xfsdump [-L S_label][-M M_label][-l #][-f 备份档] 带备份资料
xfsdump -I
```

选项与参数：

- L：xfsdump 会记录每次备份的 session 标头，这里可以填写针对此文件系统的建议说明
- M：xfsdump 可以记录存储媒体的标头，这里可以填写此媒体的建议说明
- l：小写的 L，指定等级。有 0~9 共 10 个等级，预设为 0 完整备份
- f：有点类似 tar，后面接产生的文件，例如 /dev/st0 装置文件名或其他一般文件名等
- I：从 /var/lib/xfsdump/inventory 列出目前备份的信息状态

注意：xfsdump 预设仅支持文件系统的备份，并不支持目录的备份。如 /etc 不是一个独立的文件系统

### 用 xfsdump 备份完整的文件系统

```bash
# 1. 先确定 /boot 是独立的问价系统
[mrcode@study ~]$ df -h /boot/
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda2      1014M  171M  844M  17% /boot
# 挂载点是 /boot 文件系统是 /dev/sda2 装置，是独立的文件系统

# 2. 将完整备份的文件名记录为 /srv/boot.dump
# 指定了一个等级0，后面 lm 都是说明，后面是要保存的文件地址，最后是要备份的装置
[root@study ~]# xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot
xfsdump: using file dump (drive_simple) strategy
xfsdump: version 3.1.7 (dump format 3.0) - type ^C for status and control
xfsdump: level 0 dump of study.centos.mrcode:/boot	# level 0 开始备份本机 /boot 系统	
xfsdump: dump date: Tue Oct 29 03:03:50 2019  # 备份时间
xfsdump: session id: 49ac1ac5-c63b-4778-9b87-f77f3b1d703a # dump 的 ID
xfsdump: session label: "boot_all"	# 上面写的说明
xfsdump: ino map phase 1: constructing initial dump list # 开始备份
xfsdump: ino map phase 2: skipping (no pruning necessary)
xfsdump: ino map phase 3: skipping (only one dump stream)
xfsdump: ino map construction complete
xfsdump: estimated dump size: 144381568 bytes
xfsdump: /var/lib/xfsdump/inventory created
xfsdump: creating dump session media file 0 (media 0, file 0)
xfsdump: dumping ino map
xfsdump: dumping directories
xfsdump: dumping non-directory files
xfsdump: ending media file
xfsdump: media file size 144048736 bytes
xfsdump: dump size (non-dir files) : 143807160 bytes
xfsdump: dump complete: 1 seconds elapsed
xfsdump: Dump Summary:
xfsdump:   stream 0 /srv/boot.dump OK (success)
xfsdump: Dump Status: SUCCESS
# 如果不在指令中增加 -L 和 -M 会进入互动模式，让你手动填写确认后才会开始备份

[root@study ~]# ll /srv/boot.dump 
-rw-r--r--. 1 root root 144048736 10月 29 03:03 /srv/boot.dump

[root@study ~]# ll /var/lib/xfsdump/inventory/
总用量 16
-rw-r--r--. 1 root root  312 10月 29 03:03 13d0663f-4cbd-412d-aa9f-975eb18da590.InvIndex
-rw-r--r--. 1 root root 5080 10月 29 03:03 6ad3d9fa-9c06-4968-9250-c1a70b5629ed.StObj
-rw-r--r--. 1 root root  576 10月 29 03:03 fstab

```

### 用 xfsdump 进行增量备份（Incremental backups）

增量是在全量的基础上，也就是至少有 level 0 ，才能够几区有其他的增量备份（1~9）

```bash
# 查看 xfsdump 信息
[root@study ~]# xfsdump -I
file system 0:
        fs id:          13d0663f-4cbd-412d-aa9f-975eb18da590
        session 0:
                mount point:    study.centos.mrcode:/boot
                device:         study.centos.mrcode:/dev/sda2
                time:           Tue Oct 29 03:03:50 2019
                session label:  "boot_all"
                session id:     49ac1ac5-c63b-4778-9b87-f77f3b1d703a
                level:          0
                resumed:        NO
                subtree:        NO
                streams:        1
                stream 0:
                        pathname:       /srv/boot.dump
                        start:          ino 69 offset 0
                        end:            ino 1577745 offset 0
                        interrupted:    NO
                        media files:    1
                        media file 0:
                                mfile index:    0
                                mfile type:     data
                                mfile size:     144048736
                                mfile start:    ino 69 offset 0
                                mfile end:      ino 1577745 offset 0
                                media label:    "boot_all"
                                media id:       da10035c-1c0b-4773-a56e-409a17fe9913
xfsdump: Dump Status: SUCCESS

# 可以看到，有一个 level 0
# 下面先在 boot 中建立一个大约 10MB 的文件
[root@study ~]# dd if=/dev/zero of=/boot/testing.img bs=1M count=10
记录了10+0 的读入
记录了10+0 的写出
10485760字节(10 MB)已复制，0.00396854 秒，2.6 GB/秒

# 2. 建立差异备份，这里使用 -l 1 指定了 level 1 的被增量备份
[root@study ~]# dd if=/dev/zero of=/boot/testing.img bs=1M count=10
记录了10+0 的读入
记录了10+0 的写出
10485760字节(10 MB)已复制，0.00396854 秒，2.6 GB/秒
[root@study ~]# xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot
xfsdump: using file dump (drive_simple) strategy
xfsdump: version 3.1.7 (dump format 3.0) - type ^C for status and control
xfsdump: level 1 incremental dump of study.centos.mrcode:/boot based on level 0 dump begun Tue Oct 29 03:03:50 2019
xfsdump: dump date: Tue Oct 29 03:11:00 2019
xfsdump: session id: 8a8a1680-2a91-4292-943d-0d0a51fa2d67
xfsdump: session label: "boot_2"
xfsdump: ino map phase 1: constructing initial dump list
xfsdump: ino map phase 2: pruning unneeded subtrees
xfsdump: ino map phase 3: skipping (only one dump stream)
xfsdump: ino map construction complete
xfsdump: estimated dump size: 10506880 bytes
xfsdump: creating dump session media file 0 (media 0, file 0)
xfsdump: dumping ino map
xfsdump: dumping directories
xfsdump: dumping non-directory files
xfsdump: ending media file
xfsdump: media file size 10510952 bytes
xfsdump: dump size (non-dir files) : 10488408 bytes
xfsdump: dump complete: 0 seconds elapsed
xfsdump: Dump Summary:
xfsdump:   stream 0 /srv/boot.dump1 OK (success)
xfsdump: Dump Status: SUCCESS

[root@study ~]# ll -h /srv/boot*
-rw-r--r--. 1 root root 138M 10月 29 03:03 /srv/boot.dump
-rw-r--r--. 1 root root  11M 10月 29 03:11 /srv/boot.dump1

# 3. 最后再观察下备份情况
[root@study ~]# xfsdump -I
file system 0:
        fs id:          13d0663f-4cbd-412d-aa9f-975eb18da590
        session 0:
                mount point:    study.centos.mrcode:/boot
                device:         study.centos.mrcode:/dev/sda2
                time:           Tue Oct 29 03:03:50 2019
                session label:  "boot_all"
                session id:     49ac1ac5-c63b-4778-9b87-f77f3b1d703a
                level:          0
                resumed:        NO
                subtree:        NO
                streams:        1
                stream 0:
                        pathname:       /srv/boot.dump
                        start:          ino 69 offset 0
                        end:            ino 1577745 offset 0
                        interrupted:    NO
                        media files:    1
                        media file 0:
                                mfile index:    0
                                mfile type:     data
                                mfile size:     144048736
                                mfile start:    ino 69 offset 0
                                mfile end:      ino 1577745 offset 0
                                media label:    "boot_all"
                                media id:       da10035c-1c0b-4773-a56e-409a17fe9913
        session 1:
                mount point:    study.centos.mrcode:/boot
                device:         study.centos.mrcode:/dev/sda2
                time:           Tue Oct 29 03:11:00 2019
                session label:  "boot_2"
                session id:     8a8a1680-2a91-4292-943d-0d0a51fa2d67
                level:          1
                resumed:        NO
                subtree:        NO
                streams:        1
                stream 0:
                        pathname:       /srv/boot.dump1
                        start:          ino 113 offset 0
                        end:            ino 114 offset 0
                        interrupted:    NO
                        media files:    1
                        media file 0:
                                mfile index:    0
                                mfile type:     data
                                mfile size:     10510952
                                mfile start:    ino 113 offset 0
                                mfile end:      ino 114 offset 0
                                media label:    "boot_2"
                                media id:       2c0d4e02-11cd-45a4-b131-8bc6505403fe
xfsdump: Dump Status: SUCCESS
# 可以看到上面出现了 session 1 和 level 1
```

## XFS 文件系统还原 xfsrestore

备份文件就是在急用时可以还原系统的重要数据，用 xfsdump 备份的数据可以使用 xfsresotre 来还原

```bash
xfsrestore -I	# 观察备份文件资料
xfsrestore [-f 备份文件名][-L S_label][-s] 待复原的目录  # 单一文件全系统复原
xfsrestore [-f 备份文件名] -r 待复原目录	# 通过增量备份文件复原系统
xfsrestore [-f 备份文件名] -i 待复原目录	# 进入互动模式
```

选项与参数：

- I：与 xfsdump 相同的输出
- f：后面接的就是备份的文件，企业界可能会接 /dev/st0 等磁带机，我们这里接文件名
- L：session 的 label name ，就是在 -I 输出中查询到的数据
- s：需要接特定目录，复原某一个文件或目录的意思
- r：如果是用文件来存储备份数据，这个选项就不需要使用。如果是一个磁带内有多个文件，需要这东西来达成增量复原
- i：进入互动模式，进阶管理员使用的，一般我们不太需要操作它

### 用 xfsrestore 观察 xfsdump 后的备份数据内容

```bash
[root@study ~]# xfsrestore -I
file system 0:
        fs id:          13d0663f-4cbd-412d-aa9f-975eb18da590
        session 0:
                mount point:    study.centos.mrcode:/boot
                device:         study.centos.mrcode:/dev/sda2
                time:           Tue Oct 29 03:03:50 2019
                session label:  "boot_all"
                session id:     49ac1ac5-c63b-4778-9b87-f77f3b1d703a
                level:          0
                resumed:        NO
                subtree:        NO
                streams:        1
                stream 0:
                        pathname:       /srv/boot.dump
                        start:          ino 69 offset 0
                        end:            ino 1577745 offset 0
                        interrupted:    NO
                        media files:    1
                        media file 0:
                                mfile index:    0
                                mfile type:     data
                                mfile size:     144048736
                                mfile start:    ino 69 offset 0
                                mfile end:      ino 1577745 offset 0
                                media label:    "boot_all"
                                media id:       da10035c-1c0b-4773-a56e-409a17fe9913
        session 1:
								mount point:    study.centos.mrcode:/boot
                device:         study.centos.mrcode:/dev/sda2
                time:           Tue Oct 29 03:11:00 2019
                session label:  "boot_2"
                session id:     8a8a1680-2a91-4292-943d-0d0a51fa2d67
                level:          1
                resumed:        NO
                subtree:        NO
                streams:        1
                stream 0:
                        pathname:       /srv/boot.dump1
                        start:          ino 113 offset 0
                        end:            ino 114 offset 0
                        interrupted:    NO
                        media files:    1
                        media file 0:
                                mfile index:    0
                                mfile type:     data
                                mfile size:     10510952
                                mfile start:    ino 113 offset 0
                                mfile end:      ino 114 offset 0
                                media label:    "boot_2"
                                media id:       2c0d4e02-11cd-45a4-b131-8bc6505403fe
xfsrestore: Restore Status: SUCCESS
# 和前面输出的一样
# 这里重点是看到这个文件系统是 /boot 挂载点，有两个备份 level 0 和 level 1
# 可以看到这两个备份文件的大小，更重要的是 session label
```

### 简单复原 level 0 的文件系统

```bash
# 1. 直接将数据覆盖回去即可
# 这里使用了 -L 就是那个 session label
[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /boot
xfsrestore: using file dump (drive_simple) strategy
xfsrestore: version 3.1.7 (dump format 3.0) - type ^C for status and control
xfsrestore: using online session inventory
xfsrestore: searching media for directory dump
xfsrestore: examining media file 0
xfsrestore: reading directories
xfsrestore: 11 directories and 337 entries processed
xfsrestore: directory post-processing
xfsrestore: restoring non-directory files
xfsrestore: restore complete: 0 seconds elapsed
xfsrestore: Restore Summary:
xfsrestore:   stream 0 /srv/boot.dump OK (success)
xfsrestore: Restore Status: SUCCESS

# 2. 将备份资料在 /tmp/boot 下解开
[root@study ~]# mkdir /tmp/boot
[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /tmp/boot/
xfsrestore: using file dump (drive_simple) strategy
xfsrestore: version 3.1.7 (dump format 3.0) - type ^C for status and control
xfsrestore: using online session inventory
xfsrestore: searching media for directory dump
xfsrestore: examining media file 0
xfsrestore: reading directories
xfsrestore: 11 directories and 337 entries processed
xfsrestore: directory post-processing
xfsrestore: restoring non-directory files
xfsrestore: restore complete: 0 seconds elapsed
xfsrestore: Restore Summary:
xfsrestore:   stream 0 /srv/boot.dump OK (success)
xfsrestore: Restore Status: SUCCESS

# 看到两个大小不一致
[root@study ~]# du -sm /boot/ /tmp/boot/
148     /boot/
138     /tmp/boot/

# 对比下发现 /boot 下多了一个 testing.img
[root@study ~]# diff -r /boot/ /tmp/boot/
只在 /boot/ 存在：testing.img
```

这里注意了，笔者以为这样复原之后，会完全还原到复原之前的内容的，这里的规则是：**同名的文件被覆盖，其他系统内的新的问价会被保留** 

```bash
# 3. 仅复原备份档内的 grub2 到 /tmp/boot2 里面去
[root@study ~]# mkdir /tmp/boot2
[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all -s grub2 /tmp/boot2
xfsrestore: using file dump (drive_simple) strategy
xfsrestore: version 3.1.7 (dump format 3.0) - type ^C for status and control
xfsrestore: using online session inventory
xfsrestore: searching media for directory dump
xfsrestore: examining media file 0
xfsrestore: reading directories
xfsrestore: 11 directories and 337 entries processed
xfsrestore: directory post-processing
xfsrestore: restoring non-directory files
xfsrestore: restore complete: 0 seconds elapsed
xfsrestore: Restore Summary:
xfsrestore:   stream 0 /srv/boot.dump OK (success)
xfsrestore: Restore Status: SUCCESS
[root@study ~]# ll -h /tmp/boot2/
总用量 0
drwx------. 5 root root 97 10月  4 18:32 grub2

```

## 复原增量备份资料

增量还原有顺序，比如由 level 0 -> level1 -> level2 那么还原的时候，也需要按照这个顺序

```bash
[root@study ~]# xfsrestore -f /srv/boot.dump1 /tmp/boot
xfsrestore: using file dump (drive_simple) strategy
xfsrestore: version 3.1.7 (dump format 3.0) - type ^C for status and control
xfsrestore: searching media for dump
xfsrestore: examining media file 0
xfsrestore: dump description: 
xfsrestore: hostname: study.centos.mrcode
xfsrestore: mount point: /boot
xfsrestore: volume: /dev/sda2
xfsrestore: session time: Tue Oct 29 03:11:00 2019
xfsrestore: level: 1
xfsrestore: session label: "boot_2"
xfsrestore: media label: "boot_2"
xfsrestore: file system id: 13d0663f-4cbd-412d-aa9f-975eb18da590
xfsrestore: session id: 8a8a1680-2a91-4292-943d-0d0a51fa2d67
xfsrestore: media id: 2c0d4e02-11cd-45a4-b131-8bc6505403fe
xfsrestore: using online session inventory
xfsrestore: searching media for directory dump
xfsrestore: reading directories
xfsrestore: 1 directories and 12 entries processed
xfsrestore: directory post-processing
xfsrestore: restoring non-directory files
xfsrestore: restore complete: 0 seconds elapsed
xfsrestore: Restore Summary:
xfsrestore:   stream 0 /srv/boot.dump1 OK (success)
xfsrestore: Restore Status: SUCCESS

```

### 仅还原部分文件的 xfsrestore 互动模式

使用 -s 参数可以接部分数据来还原，当文件太多时，又不知道里面有哪些文件，可以使用互动模式，比如想要知道 level0 的备份数据里面有哪些东西

```bash
[root@study ~]# xfsrestore -f /srv/boot.dump -i /tmp/boot3
xfsrestore: using file dump (drive_simple) strategy
xfsrestore: version 3.1.7 (dump format 3.0) - type ^C for status and control
xfsrestore: searching media for dump
xfsrestore: examining media file 0
xfsrestore: dump description: 
xfsrestore: hostname: study.centos.mrcode
xfsrestore: mount point: /boot
xfsrestore: volume: /dev/sda2
xfsrestore: session time: Tue Oct 29 03:03:50 2019
xfsrestore: level: 0
xfsrestore: session label: "boot_all"
xfsrestore: media label: "boot_all"
xfsrestore: file system id: 13d0663f-4cbd-412d-aa9f-975eb18da590
xfsrestore: session id: 49ac1ac5-c63b-4778-9b87-f77f3b1d703a
xfsrestore: media id: da10035c-1c0b-4773-a56e-409a17fe9913
xfsrestore: using online session inventory
xfsrestore: searching media for directory dump
xfsrestore: reading directories
xfsrestore: 11 directories and 337 entries processed
xfsrestore: directory post-processing

 ========================== subtree selection dialog ==========================

the following commands are available:
        pwd 
        ls [ <path> ]
        cd [ <path> ]
        add [ <path> ]		# 可以加入还原文件列表中
        delete [ <path> ] # 从还原列表中删除文件，不是删除，只是从列表中移出去
        extract 	# 开始还原动作
        quit 
        help 

-> ls		# ls 查看有哪些文档
              75 initramfs-3.10.0-1062.el7.x86_64.img 
              77 vmlinuz-0-rescue-f228ab37c368416c84c6b27971ba45a9 
              76 initramfs-0-rescue-f228ab37c368416c84c6b27971ba45a9.img 
              74 vmlinuz-3.10.0-1062.el7.x86_64 
              73 symvers-3.10.0-1062.el7.x86_64.gz 
              72 config-3.10.0-1062.el7.x86_64 
              71 System.map-3.10.0-1062.el7.x86_64 
              70 .vmlinuz-3.10.0-1062.el7.x86_64.hmac 
              68 grub/
         1572928 grub2/
              67 efi/

 -> add grub/

 -> add grub2/

 -> add config-3.10.0-229.el7.x86_64
config-3.10.0-229.el7.x86_64 not found			# 这个里面不能按退格键，我输出了，不过提示未找到

 -> extract
 --------------------------------- end dialog ---------------------------------

xfsrestore: restoring non-directory files
xfsrestore: restore complete: 182 seconds elapsed
xfsrestore: Restore Summary:
xfsrestore:   stream 0 /srv/boot.dump OK (success)
xfsrestore: Restore Status: SUCCESS

# 查看还原的目录下，的确只有我们需要的两个
[root@study ~]# ls -l /tmp/boot3
总用量 0
drwxr-xr-x. 2 root root 27 10月  4 18:22 grub
drwx------. 5 root root 97 10月  4 18:32 grub2

```

# 光盘写入工具

企业喜欢使用磁带来进行备份，容量高、存储时限常、耐摔等等，至于以前的 DVD/CD 等，因为存储速度慢、容量没有大幅度提升，很少使用了

虽然现在很少使用了，不过在特别的情况下，没有这东西又不行，因此这里介绍在文本模式的刻录行为是怎么处理的，通常做法是这样的：

1. 现将所需要备份的数据建立成为一个映像文档（iso)，利用 mkisofs 指令来处理
2. 将该映像文件刻录到光盘或则 DVD 中，利用 cdrecord 指令来处理

## mkisofs 建立映像文档

刻录可开机与不可开机的光盘，使用方法不太一样

### 制作一般数据光盘映像文件

```bash
mkisofs [-o 映像文档][-Jrv][-V vol][-m file] 待备份文件 -graft-point isodir=systemdir ..
```

选项与参数：

- o：接想要产生的映像文档名
- J：产生较兼容于 windows 机器的文件名结构，可增加文件名长度 64 个 unicode 字符
- r：通过 Rock Ridge 产生支持 Unix/Linux 的文件数据，可记录较多的信息（如 UID/GID) 等
- v：显示建立 ISO 文件的过程
- V vol：建立 Volume ，有点像 windows 在文件总管内看到的 CD title 的东西
- m file：-m 为排除文件（exclude），后面的文件不备份到该映像文档中，也可以使用 * 通配符
- -graft-point：graft 有转嫁或移植的意思，相关资料在下面说明

mkisofs 有非常多好用的选项，只想制作数据光盘时，上述的选项就够用了。光盘格式一般称为 iso9660，这种格式一般仅支持旧版的 DOS 文件名（文件只能以 8.3 即 文件名 8 个字符，扩展名 3 个字符的方式存在）。如果加上 -r 选项后，文件信息能够被记录得比较完整

此外，一般预设的情况下，所有要被加到映像中的文件都会被放置到映像文件的根目录，如此一来可能会造成刻录后的文件分类不易的情况，可以使用 -graft-point 选项

- 映像文件中的目录所在 等于 实际 Linux 文件系统的目录所在
- /movies=/srv/movies（在 Linux 的 /srv/movies 内的文件，加到映像文件中的 /movies/ 目录）
- /linux/etc=/etc（将 Linux 中的 /etc/ 内的所有数据备份到映像文件中的 /liux/etc 目录中

```bash
# 假如想要讲 /root、/home、/etc 等目录内的数据通过刻录起来的话，先要处理下映像
# 先不使用 -graft-point 的选项处理
[root@study ~]# mkisofs -v -o /tmp/system.img /root /home/ /etc/
I: -input-charset not specified, using utf-8 (detected in locale settings)
genisoimage 1.1.11 (Linux)
Scanning /root
... 很多的文件记录输出
Writing:   The File(s)                             Start Block 955
  9.23% done, estimate finish Tue Oct 29 03:55:51 2019
 18.47% done, estimate finish Tue Oct 29 03:55:51 2019
 27.72% done, estimate finish Tue Oct 29 03:55:51 2019
 36.94% done, estimate finish Tue Oct 29 03:55:51 2019
 46.19% done, estimate finish Tue Oct 29 03:55:51 2019
 55.39% done, estimate finish Tue Oct 29 03:55:51 2019
 64.62% done, estimate finish Tue Oct 29 03:55:51 2019
 73.85% done, estimate finish Tue Oct 29 03:55:51 2019
 83.08% done, estimate finish Tue Oct 29 03:55:52 2019
 92.33% done, estimate finish Tue Oct 29 03:55:52 2019
Total translation table size: 0
Total rockridge attributes bytes: 0
Total directory bytes: 1869824
Path table size(bytes): 13350
Done with: The File(s)                             Block(s)    53057
Writing:   Ending Padblock                         Start Block 54012
Done with: Ending Padblock                         Block(s)    150
Max brk space used 378000
54162 extents written (105 MB)
# 笔者这个直接成功了，在树上因为 /etc/crontab 和 /root/crontab 中有相同的文件
# 他们没有被归档的时候，都会出现在映像文档中的根目录，所以报错

[root@study ~]# ll -h /tmp/system.img 
-rw-r--r--. 1 root root 106M 10月 29 03:55 /tmp/system.img

# 查看该映像中的内容
# 可以挂载到某个目录下，再查看
[root@study ~]# mount -o loop /tmp/system.img /mnt/
mount: /dev/loop0 写保护，将以只读方式挂载
[root@study ~]# df -h /mnt/
文件系统        容量  已用  可用 已用% 挂载点
/dev/loop0      106M  106M     0  100% /mnt
# 使用 ll /mnt 指令查看，只发现里面全是没有路径的文件
```

发现所有的数据都放在了映像文件中的根目录，下面使用归档再看看

```bash
# 卸载掉
umount /mnt

[root@study ~]# mkisofs -r -V 'linux_file' -o /tmp/system.img -m /roo/etc --graft-point /root=/root /home/=/home /etc=/etc

[root@study ~]# ll -h /tmp/system.img 
-rw-r--r--. 1 root root 107M 10月 29 04:05 /tmp/system.img
[root@study ~]# mount -o loop /tmp/system.img /mnt/
mount: /dev/loop0 写保护，将以只读方式挂载
[root@study ~]# ll /mnt/
总用量 46
dr-xr-xr-x. 143 root root 38912 10月  4 18:38 etc
dr-xr-xr-x.   4 root root  2048 10月  8 23:01 home
dr-xr-xr-x.   7 root root  4096 10月 29 00:57 root
dr-xr-xr-x.   9 root root  2048 10月 29 04:05 rr_moved
```

## 制作/修改可开机光盘映像文档

要制作一键安装系统的光盘，需要修改原版光盘映像文件，改成可以自动加载某些程序的流程；刻录成光盘后，放入光驱，只要开机利用光盘来开机，就直接安装系统，不再需要询问管理员一些问题，等于是自动化处理，当然这些流程很麻烦，需要了解 kickstart 等相关技术，这里先不谈。本章让你知道如何让光盘内容被修改之后，还可以刻录成可开机的映像文档

笔者刚开始使用 mac，传入虚拟机文档不知道怎么弄，特别慢。就不跟着练习了，直接截图了

```bash
# 查看 iso 的信息
isoinfo -d -i /home/CentOS-7.iso 
# 挂载该 iso 到 /mnt
mount /home/CentOS-7.iso /mnt
mkdir /srv/newcd
# rsync 可以完整复制所有的权限属性等数据，也可以进行镜像处理
# 现在 newcd 总已经是完整映像文档的内容了
rsync -a /mnt /srv/newcd
ll /srv/newcd/
# 这里就可以修改 newcd 里面的内容了，假设已经处理完
ll /srv/newcd/isolinux
cd /srv/newcd
mkisofs -o /custom.iso -b isolinux/isolinux.bin -c isolinux/boot.cat \
> -no-emul-boot -V 'CentOS 7 x86_64' -boot-load-size 4 -boot-info-table -R -J -v -T
# 运行之后，就会存在一个 /custom.img 的文件存在,可以将该文件刻录到光盘上
```

![image-20191101234333791](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20191101234333791.png)

![image-20191101234746782](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20191101234746782.png)

## cdrecord 光盘刻录工具

新版的 CentOS 7 使用的是 wodim 指令来进行刻录行为（旧版是 cdrecord，为了兼容 wodim 也链接了旧版的）

```bash
# 常见的指令入戏
wodim --devices dev/det/sr0			# 查询刻录机的 BUS 位置
wodim -v dev=/dev/sr0 blank=[fast|all]	# 抹除重复读写片
wodim -v dev=/dev/sr0 -format		# 格式化 DVD + RW
wodim -v dev=/dev/sr0 [可用选项功能] file.iso
```

选项与参数：

- devices：用在扫描磁盘总线并找出可用的刻录机，后续的装置为 ATA 接口
- v：在 cdrecord 运作的过程中，显示过程
- dev=/dev/sr0：可以找出此光驱的 bus 地址，非常重要
- `blank[fast|all]：blank 为抹除可重复写的 Cd/DVD-RW ，使用 fast 较快，all 较完成
- format：对光盘进行格式化，但是仅针对 DVD+RW 这种格式的 DVD
- 可用选项与功能：
  - `-data`：指定后面的文件以数据格式写入，不是以 CD 音轨（-audio）方式写入
  - speed=x：指定刻录速度，例如 CD 可用 speed=40 为 40 倍数，DVD 则可用 speed=4 之类
  - `-eject`：指定刻录完毕后自动退出光盘
  - fs=Ym：指定多少缓存存储器，可用在将映像档先暂存至缓冲存储器。预设为 4m，一般建议可增加到 8m，不过还是得视你的刻录机而定
- 针对 DVD 的选项功能：
  - driveropts=burnfree：打开 Buffer Underrun Free 模式的写入功能
  - `-sao`：支持 DVD-RW 的格式

### 侦测你的刻录机所在位置

文不能模式的刻录确实比较麻烦，需要先找到刻录机才行。早期刻录机都是使用 SCSI 接口，因此配合 SCSI 接口认定来查询

```bash
[root@study ~]# ll /dev/sr0 
brw-rw----+ 1 root cdrom 11, 0 10月 28 21:38 /dev/sr0	 # 一般 Linux 光驱文件名
[root@study ~]# wodim --devices dev=/dev/sr0
wodim: Warning: controller returns zero sized CD capabilities page.
wodim: Warning: controller returns wrong size for CD capabilities page.
wodim: Warning: controller returns wrong page 0 for CD capabilities page (2A).
wodim: Overview of accessible drives (1 found) :
-------------------------------------------------------------------------
 0  dev='/dev/sr0'      rwrw-- : 'VBOX' 'CD-ROM'
-------------------------------------------------------------------------

#笔者这个是虚拟机的，因此无法真正的使用，那么下面的指令直接记录书上的步骤
```

### 进入 CD/DVD 的刻录动作

如何将 /tmp/system.img 刻录到 cd/dvd 里面？

```bash
# 0. 先抹除光盘的原始内容：（非可重复读写则可略过此步骤）
wodim -v dev=/dev/sr0 blank=fast
# 中间会抛出一堆信息告诉你抹除的进度，而且会有 10 秒的时间等待你取消
# 1. 开始刻录; eject 刻录完成之后，DVD 会被退出光驱，记得推回去
wodim -v dev=/dev/sr0 speed=4 -dummy -eject /tmp/system.img
# 2. 刻录完成后，测试挂载一下，检验内容
mount /dev/sr0/mnt
dh -h /mnt
ll /mnt
umount /mnt
```

简单刻录上面的语法就够了，但是还是建议在图形化界面中来刻录

# 其他常见的压缩与备份工具

## dd

在前面 第七章中特殊 loop 装置挂载时使用过 dd 这个指令，dd 指令不只是制作一个文件，它最大的功效可能就是备份了，因为 dd 可以读取磁盘装置的内容（几乎是直接读取扇区 sector），然后将装置备份成一个文件，下面讲解几个比较重要的选项

```bash
dd if="input_file" of="output_file" bs="block_size" count="number"

if：输入文件，也可以是装置
of：输出文件，也可以是装置
bs：规划一个 block 的大小，若未指定则预设为 512bytes（一个 sector 大小）
count：多少个 bs
```

实践与练习

```bash
# 将 /etc/passwd 备份到 /tmp/passwd.back 中
[root@study ~]# dd if=/etc/passwd of=/tmp/passwd.back
记录了4+1 的读入
记录了4+1 的写出
2323字节(2.3 kB)已复制，0.000202909 秒，11.4 MB/秒
[root@study ~]# ll /tmp/passwd.back /etc/passwd
-rw-r--r--. 1 root root 2323 10月  4 18:31 /etc/passwd
-rw-r--r--. 1 root root 2323 10月 29 09:37 /tmp/passwd.back
# /etc/passwd 文件为 2323bytes
# 没有设置 bs，默认为 512bytes，4+1 表示有 4 个完整的 512bytes
# 以及一个未满 512bytes 的 block

# 将刚刚刻录的光驱内容，再次备份下来称为映像文档
 [root@study ~]# dd if=/dev/sr0 of=/tmp/system.iso
记录了150708+0 的读入
记录了150708+0 的写出
77162496字节(77 MB)已复制，0.503923 秒，153 MB/秒
[root@study ~]# ll /tmp/system.iso 
-rw-r--r--. 1 root root 77162496 10月 29 09:41 /tmp/system.iso
[root@study ~]# mount /tmp/system.iso /mnt/
mount: /dev/loop1 写保护，将以只读方式挂载
[root@study ~]# ll /mnt/
总用量 62742
-r--r--r--. 1 root root      763 1月  22 2019 AUTORUN.INF
-r-xr-xr-x. 1 root root     6384 7月  12 17:06 autorun.sh
dr-xr-xr-x. 2 root root      792 7月  12 17:13 cert
dr-xr-xr-x. 2 root root     1824 7月  12 17:13 NT3x
dr-xr-xr-x. 2 root root     2652 7月  12 17:13 OS2
-r-xr-xr-x. 1 root root     4821 7月  12 17:06 runasroot.sh
-r--r--r--. 1 root root      547 7月  12 17:13 TRANS.TBL
-r--r--r--. 1 root root  3731646 7月  12 17:05 VBoxDarwinAdditions.pkg
-r--r--r--. 1 root root     3949 7月  12 17:05 VBoxDarwinAdditionsUninstall.tool
-r-xr-xr-x. 1 root root  8601012 7月  12 17:07 VBoxLinuxAdditions.run
-r--r--r--. 1 root root 16584704 7月  12 17:07 VBoxSolarisAdditions.pkg
-r-xr-xr-x. 1 root root 22909888 7月  12 17:12 VBoxWindowsAdditions-amd64.exe
-r-xr-xr-x. 1 root root   270104 7月  12 17:07 VBoxWindowsAdditions.exe
-r-xr-xr-x. 1 root root 12125152 7月  12 17:09 VBoxWindowsAdditions-x86.exe     
[root@study ~]# umount /mnt/
# 本来是虚拟机，不应该有内容的把。看下文件内容，应该就是虚拟机的工具之类的
[root@study ~]# ll /dev/sr0 
brw-rw----+ 1 root cdrom 11, 0 10月 28 21:38 /dev/sr0
[root@study ~]# mount /dev/sr0 /mnt/
mount: /dev/sr0 写保护，将以只读方式挂载
[root@study ~]# ll /mnt/
总用量 62742
-r--r--r--. 1 root root      763 1月  22 2019 AUTORUN.INF
-r-xr-xr-x. 1 root root     6384 7月  12 17:06 autorun.sh
dr-xr-xr-x. 2 root root      792 7月  12 17:13 cert
dr-xr-xr-x. 2 root root     1824 7月  12 17:13 NT3x
dr-xr-xr-x. 2 root root     2652 7月  12 17:13 OS2
-r-xr-xr-x. 1 root root     4821 7月  12 17:06 runasroot.sh
-r--r--r--. 1 root root      547 7月  12 17:13 TRANS.TBL
-r--r--r--. 1 root root  3731646 7月  12 17:05 VBoxDarwinAdditions.pkg
-r--r--r--. 1 root root     3949 7月  12 17:05 VBoxDarwinAdditionsUninstall.tool
-r-xr-xr-x. 1 root root  8601012 7月  12 17:07 VBoxLinuxAdditions.run
-r--r--r--. 1 root root 16584704 7月  12 17:07 VBoxSolarisAdditions.pkg
-r-xr-xr-x. 1 root root 22909888 7月  12 17:12 VBoxWindowsAdditions-amd64.exe
-r-xr-xr-x. 1 root root   270104 7月  12 17:07 VBoxWindowsAdditions.exe
-r-xr-xr-x. 1 root root 12125152 7月  12 17:09 VBoxWindowsAdditions-x86.exe

# 这个实例是直接记录步骤，笔者没有 usb 的环境
# 假设你的 usb 是 /dev/sda ，将上面的 image 刻录到 USB 磁盘中
lsblk /dev/sda
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda   8:0    0   2G   0 disk    				# 这里是 disk 

dd if=/tmp/system.iso of=/dev/sda
mount /dev/sda /mnt
ll /mnt
# 有一个小技巧，可以使用这里的 dd 将 iso 文件写入 USB 磁盘
# 那么久会变成可开机光盘一样的功能，可以让你用 USB 来安装 linux ，速度快很多（因为 DVD 刻录很慢）

# 将你的 /boot 整个文件系统通过 dd 备份下来
[root@study ~]# df -h /boot/
文件系统        容量  已用  可用 已用% 挂载点
/dev/sda2      1014M  181M  834M   18% /boot
[root@study ~]# dd if=/dev/sda2 of=/tmp/sda2.img
记录了2097152+0 的读入
记录了2097152+0 的写出
1073741824字节(1.1 GB)已复制，5.96824 秒，180 MB/秒
[root@study ~]# ll -h /tmp/sda2.img 
-rw-r--r--. 1 root root 1.0G 10月 29 09:52 /tmp/sda2.img

```

使用 dd 来备份是无可奈何的情况，因为默认 dd 是一个一个扇区去读写的，而且即使没有用到的扇区也会写入备份档中，因此整个文件会变得与磁盘一模一样大。缺点即优点，因此不管是什么类容都可以备份和还原

## cpio

cpio 可以备份任何东西，包括装置设备文件。不过 cpio 有个大问题，不会主动找文件，被动接收，所以需要配合类似 find 等可以找到文件名的指令来使用，因此涉及到了后续才会讲解的数据流重导向。

这里如果不明白什么是数据流重导向，那么后续学习之后再回过头来看这里

```bash
备份：cpio -ovcB > [file|device]
还原：cpio -ivcdu < [file|device]
查看：cpio -ivct < [file|device]
```

备份选项参数：

- o：将数据 copy 输出到文件或装置上
- B：让预设的 Blocks 可以增加至 5120bytes（预设是 512bytes），好处是：可以让大文件的存储速度加快许多（请参考 i-nodes 概念）

还原选项参数：

- i：将数据从文件或装置中 copy 出来
- d：自动建立目录，使用 cpio 所备份的数据内容不见得会在同一层目录中，因此必须要让 cpio 在还原时可以建立新目录
- u：自动的将较新的文件覆盖旧文件
- t：需要配合 -i 使用，可以用在查看以 cpio 建立的文件或装置的内容

一些共享选项参数：

- v：输出处理的文件名
- c：一种较新的 portable format 方式存储

实践练习：

```bash
# 找出 /boot 下的所有文件，将其备份到 /tmp/boot.cpio 
[root@study ~]# cd /
[root@study /]# find boot -print
boot
boot/efi
boot/efi/EFI
boot/efi/EFI/centos
boot/efi/EFI/centos/fw
....
# 通过 find 可以找到 boot 下存在的文件名包括文件与目录，但请千万不要是绝对路径
# 如果是绝对路径，和之前解压缩时类似的问题

# 这里就看明白了，上面语法中其实是没有指定需要备份的文件有哪些的
# 这里使用管道符号把 find boot 找到的文件名传递给了后续的 cpio 处理
[root@study /]# find boot | cpio -ocvB > /tmp/boot.cpio
[root@study /]# ll -h /tmp/boot.cpio 
-rw-r--r--. 1 root root 147M 10月 29 10:29 /tmp/boot.cpio
[root@study /]# file /tmp/boot.cpio 
/tmp/boot.cpio: ASCII cpio archive (SVR4 with no CRC)

# 将刚刚的文件在 /root 目录下解开
[root@study /]# cd ~
[root@study ~]# cpio -idvc < /tmp/boot.cpio 
[root@study ~]# ll /root/boot/
总用量 135200
-rw-r--r--. 1 root root   152976 10月 29 10:31 config-3.10.0-1062.el7.x86_64
drwx------. 3 root root       17 10月 29 10:31 efi
drwxr-xr-x. 2 root root       27 10月 29 10:31 grub
drwx------. 5 root root       97 10月 29 10:31 grub2
-rw-------. 1 root root 78606868 10月 29 10:31 initramfs-0-rescue-f228ab37c368416c84c6b27971ba45a9.img
-rw-------. 1 root root 31799826 10月 29 10:31 initramfs-3.10.0-1062.el7.x86_64.img
-rw-r--r--. 1 root root   318717 10月 29 10:31 symvers-3.10.0-1062.el7.x86_64.gz
-rw-------. 1 root root  3594971 10月 29 10:31 System.map-3.10.0-1062.el7.x86_64
-rw-r--r--. 1 root root 10485760 10月 29 10:31 testing.img
-rwxr-xr-x. 1 root root  6734016 10月 29 10:31 vmlinuz-0-rescue-f228ab37c368416c84c6b27971ba45a9
-rwxr-xr-x. 1 root root  6734016 10月 29 10:31 vmlinuz-3.10.0-1062.el7.x86_64
```

cpio 可以将系统的数据完整的备份到磁带机上去：

- 备份：`find / | cpio -ocvB > /dev/st0`
- 还原：`cpio -idvc < /dev/sto`

虽然 cpio 不是特别的方便，但是备份可是利器，因为可以备份任何文件，包括 /dev/ 下的任何装置文件

其实系统中有一个使用 cpio 建立的文件 /boot/initramfs-xxx ，现在来解开他看看

```bash
# 先看下属于什么文件格式
[root@study ~]# file /boot/initramfs-3.10.0-1062.el7.x86_64.img 
/boot/initramfs-3.10.0-1062.el7.x86_64.img: gzip compressed data, from Unix, last modified: Fri Oct  4 18:31:46 2019, max compression

# 完了，笔者的系统比书上的新，已经不是 cpio 的了
# 那么下面只记录下解开步骤
mkdir /tmp/initramfs
cd /tmp/initramfs
cpio -idvc < /boot/initramfs-xx/img
```

## 重点回顾

- 压缩指令通过一些运算方法将原本的文件进行压缩，以减少文件所占用的磁盘容量。压缩前后的文件所占用的磁盘容量比值称为「压缩比」
- 压缩的好处是可以减少磁盘容量的浪费，在 www 网站也可以利用文件压缩的技术来进行数据的传送，好让网站带宽的可利用率上升
- 压缩文件的扩展名大多是：`*.gz、*.bz2、*.xz、*.tar、*.tar.bz2、*.tar.xz`
- 常见的压缩指令有 gzip、bzip2、xz。压缩率最佳的是 xz，若可以不计时间成本，建议使用 xz
- tar 可以用来进行文件打包，并可支持 gzip、bzip2、xz 压缩
- 压缩：tar -Jcv -f filename.tar.xz 要被压缩的文件或目录名称
- 查询：tar -Jtv -f filename.tar.xz 
- 解压：tar -Jxv -f filename.tar.xz  -C 指定解压目录
- xfsdump 指令可备份文件系统或单一目录
- xfsdump 的备份若针对文件系统时，可以进行 0-9 的 level 差异备份，其中 level 0 为完整备份
- xfsrestore 指令可还原被 xfsdump 建立的文件
- 要建立光盘刻录数据时，可通过 mkisofs 指令来处理
- 可通过 wodim 来写入 cd 或 dvd 刻录机
- dd 可备份完整的 partition 或 dsk，因为 dd 可读取磁盘的 sector 表面数据
- cpio 为相当优秀的备份指令，不过必须搭配类似 find 指令来读入需要备份的文件名数据，方可进行备份动作