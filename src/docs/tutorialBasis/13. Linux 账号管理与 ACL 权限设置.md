# Linux 账号管理与 ACL 权限设置

不同的使用者有不同的账户与密码，也应该拥有不同的权限，可以通过 user/group 的特殊权限设置来规范不同的群组开发项目。在 Linux 下可以通过很多种方式来限制用户能够使用的系统资源，比如 第十章的 bash 中提到的 ulimit 限制、特殊权限限制，如 umask 等。通过这些手段可以规范出不同使用者的使用资源

## Linux 的账户与群组

账户管理是管理员工作中相当重要的一环，并且所有一般用户的账户申请，都必须需要管理员的协助才可以，所以必须了解下如何管理好一个服务器主机账户。

在管理 Linux 主机的账户时，我们必须先来了解下 Linux 到底是如何辨别每一个使用者的

## 使用者标识符：UID 与 GID

登录使用的账户，但是账户与 ID 对应在 /etc/passwd 中，Linux 主机针对 ID 进行识别

比如下载过 tarball 类型的文件，解压之后的文件中，文件拥有者的字段可能显示「不明的数字」，这说明在很多场景下几乎上都是用 ID 来识别的

在第 5 章中提到过，每一个文件都具有「拥有人与拥有群组」的属性，所以每个使用者至少会取得两个 ID:

- UID：user id
- GID：group id

文件也是通过 UID 与 GID 来判别他的拥有者与群组的，当有要显示文件属性的需求时，系统会依据 `/etc/passwd` 与 `/etc/group` 的内容，找到 UID/GID 对应的账户与组名再显示出来。

可以通过一个小测试来验证，使用 root 身份 `vim /etc/passwd` 然后将一般身份的使用者 ID 随便更改一个号码，然后再到这个一般身份的目录下查看该账户拥有的文件，就会发现该文件的拥有人变成了「数字」

```bash
# 确定有 mrcode 账户
[root@study ~]# id mrcode
uid=1000(mrcode) gid=1000(mrcode) groups=1000(mrcode)

# 查看该文件的拥有者，显示是 mrcode
[root@study ~]# ll -d /home/mrcode/
drwx------. 16 mrcode mrcode 4096 Feb 18 13:34 /home/mrcode/

# 修改 mrcode 的 UID 1000 变成 2000
[root@study ~]# vim /etc/passwd
mrcode:x:2000:1000:mrcode:/home/mrcode:/bin/bash

# 再次查看文件的拥有者，从原先的 mrcode 变成了 1000.变成了数字
# 最后记得还原回来
[root@study ~]# ll -d /home/mrcode/
drwx------. 16 1000 mrcode 4096 Feb 18 13:34 /home/mrcode/
```

上面的例子仅说明 UID 与账户的对应性，在 LInux 下，不要随意锈钢系统上某些账户的 UID，否则可能导致某些程序无法进行。

如果上述操作，不修改回去的话，那么下次 mrcode 登录时就无法进入自己的家的目录，因为他的 UID 已经锈钢为 2000 了，但是他家目录（/home/mrcode） 却记录的是 1000，由于权限是 700，因此他讲无法进入元宝的家的目录

## 使用者账户

Linux 的用户需要通过 tty1~tty6 的终端机提供的 login 接口，并输入账户与密码后才能够登录。如果是通过网络的话，至少需要学习使用 ssh 功能（服务器篇讲解）。那么输入账户密码后，系统处理了如下东西：

1. 先找 `/etc/passwd`中是否有你输入的账户？如果有则将账户对应的 UID 与 GID（在/etc/group）读出来，该账户的家目录与 shell 设置也读出来。如果没有则跳出
2. 再核对密码表，在 `/etc/shadow`找出对应的账户与 UID，进行比对
3. 如果一切都正确，就进入 Shell 的管控阶段

大致流程如上，当登录时，`/etc/passwd`与`/etc/shadow`会被用到（很多攻击者会将特殊账户写在  `/etc/passwd` 中），所以如果要备份 Linux 系统账户，则这两个文件一定要备份

与使用者相关的两个非常重要的文件

- `/etc/passwd`：管理 UID/GID 重要参数相关
- `/etc/shadow`：管理密码相关

那么下面来简单介绍这两个文件，通过 `man 5 passwd`  和 `man 5 shadow` 了解详情

### `/etc/passwd` 文件结构

每一行表示一个账户，其中有些特殊的账户是系统正常运行所必须的，可以简称他为系统账户，例如 bin、daemon、adm、nobody 等，这些账户请不要随意的修改，那么账户内容如下所示

```bash
[root@study ~]#head -n 4 /etc/passwd
root:x:0:0:root:/root:/bin/bash		# 第一行是 root 账户
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin

```

每个 Linux 系统都会有第一行，root 管理员这行，每行使用「:」分割为 7 个字段，分别是：

1. 账户名称：用来对应 UID

2. 密码

   早期 Unix 系统密码放在该字段上的，该文件特性是所有程序都能够读取，为了安全，则放到 `/etc/shadow` 中了，该字段使用 x 来占位，表示不使用了

3. UID

   使用者标识，通常 UID 有如下几个限制需要了解下：

   - id=0 系统管理员：所以当你要让其他的账户名称也具有 root 权限时，将该账户的 UID 修改为 0 即可。不过不建议这样做，容易让系统管理员混乱

   - id=1~999 系统账户：

     系统保留使用的 ID，除了 0 之外，其他的 UID 权限与特性并没有不一样，默认 1000 以下作为系统保留账户只是一个习惯；

     比如系统上启动的网络服务或背景服务希望使用较小的权限去运作，因此就需要这些小权限账户去执行。通常这些账户是不可登陆的，所以在第十章中提到的 `/sbin/nologin` 这个特殊的 shell 的存在

     根据系统账户的由来，通常这类账户又大概区分为两种：

     - 1~200：由 distributions 自行建立的系统账户
     - 201~999：若用户有系统账户需求时，可以使用的账户 UID
     - id=1000~60000：给一般使用者用的。在 linux 核心 3.10.x 版本，已经可以支撑到 4294967295（2的32次方-1）这么大的 UID 了

4. GID：与 `/etc/group` 有关，该文件与 `/etc/passwd`类似，只是它是用来规范组名与 GID 的对应

5. 用户信息说明

   没有什么重要用途，用来描述该账户的意义。但是使用 finger 功能时，该字段可以提供很多的信息，本章后面 chfn 指令会讲解

6. 家的目录

   以 root 为例，root 的家目录在 /root，所以当 root 登录后，就默认在 /root 目录下。

   如果你有个账户的使用空间特别的大，想要将该账户家的目录移动到其他硬盘去，就可以在该字段修改，默认的用户家目录在 /home/yourIdName

7. Shell

   在前面第十章 BASH 提到过很多次，当用户登录系统后，会取得一个 Shell 来与系统核心进行交互。该字段就是预设 shell 环境，如果想要用 shell 代替让账户无法取得 shell 环境的登录，那么就可以修改为 `/sbin/nologin`，也可以用来制作纯 pop 邮件账户者的数据

##  `/etc/shadow` 文件结构

很多程序运行都与权限有关系，权限与 UID/GID 有关，因此需要读取 `/etc/passwd` 来获取不同账户的权限。因此 `/etc/passwd`  的权限为 `-rw-r--r--`，谁都可以读取该文件，早期密码放到第个字段上，虽然也加密过，但是不安全，因为加密的密码可以通过暴力破解方式取得原始密码

```bash
[root@study ~]# head -n 4 /etc/shadow
root:$6$eC75oi.rU.wJPhgN$C.C.qFXTvmJ64qFnez88TdcsHuuQAqtAYrukgBYBspgSZbCgzvJuv4OVJ9gaEfA2/.T7e68AZW7RoZt6ubeHD0::0:99999:7:::
bin:*:17834:0:99999:7:::
daemon:*:17834:0:99999:7:::
adm:*:17834:0:99999:7:::

```

每一行一个密码，已「:」分割为 9 个字段

1. 账户名称，用来与 /etc/passwd 中账户名称对应

2. 密码：经过加密的密码

   虽然加密过，但是也有可能被破解出来，该文件的预设权限为 `-rw------ 或 ------`，因此该文件只有 root 才可以读写

   另外加密方式不同，字符串长度也不同，由于固定加密方式产生的密码长度必须一致，因此该字段长度改变后，该密码就失效了，所以有一些软件通过在该字段前加上 `! 或 *` 来达到让密码暂时失效的目的

3. 最近修改密码的日期：记录了修改密码的那一天的日期

   比如 17834 ，这个是以  1970-01-01 作为第一天而累加出来的日期，1970-01-01 + 17834 天 得到的一个时间，想要了解该日期可以使用后续讲解的 chage 指令，想要知道某个日期累计了多少天，可以使用下面的公式来计算

   ```bash
   # 2015/05/04 为计算的日期
   # 86400 是每一天的秒数
   # %s 是 1970/01/01 累计以来的总秒数
   # 由于 bash 只支持整数，因此需要加 1 来补齐 1970/01/01 当天
   [root@study ~]# echo $(($(date --date='2015/05/04' +%s)/86400+1))
   16559
   ```

4. 密码不可被修改的天数：与第 3 个字段相比

   也就是该密码最近修改之后，需要经过几天后才可以修改，0 标识不限制，非 0 ，比如 20，则标识 20 天内都无法修改密码

5. 密码需要重新锈钢的天数：与第 3 个字段相比

   也就是该密码在最近修改之后，生效的天数，如果超过这个天数则该密码为过期，不可使用。99999=273 年，也大概标识不限制了

6. 密码需要变更期限前的警告天数：与第 5 个字段相比

   在到期前 n 天，系统发出警告给该账户，告诉你该账户还有 n 天密码过期了，请尽快修改该密码。如上面的例子为 7 天，则到期之前 7 天内，系统会警告该用户

7. 密码过期后的账户宽限时间：与第 5 个字段相比

   密码有效期 = 更新日期（3 字段） + 重新变更日期（5 字段），过了该期限后用户依旧没有更新密码，那么该密码就算过期了。虽然过期了，但是还可以登录系统取得 bash。不过，当你登录系统时，系统会强制要求必须重新设置密码才能登录继续使用，这就是密码过期特性

   该字段意思为：当密码过期几天后，那么再登录系统则完全无法登录了

8. 账户失效日期

   与第 3 个字段一样，使用的是 1970 年以来的总数日设置的。表示该账户在此规定的日期之后，将无法再使用。这就是账户失效，而无论密码是否有过期，该账户都无法使用

   该字段一般会用在收费服务的系统中，规定一个日期让该账户无法使用

9. 保留：保留字段，防止以后有新功能的加入

由于 shadow 的重要性，因此不可随意修改，但是如果忘记密码了怎么办？

- 一般用户密码忘记：找系统管理员帮忙，可以以 root 身份使用 passwd 指令来处理，而不需要旧密码
- root 密码忘记：这个就麻烦了，只有通过各种手段进入 Linux 再去修改 /etc/shadow 文件，比如
  - 第 19 章中讲解的重启进入单人维护模式，系统会主动的给予 root 权限的 bash 接口，此时再用 passwd 修改密码即可
  - 使用 Live CD 开机后挂载根目录去修改 /etc/shadow 文件，将 root 的密码字段清空，再登录时就相当于不要密码了

另外，shadow 的密码加密机制，可以通过以下指令获取

```bash
[root@study ~]# authconfig --test | grep hashing
 password hashing algorithm is sha512		# 密码加密算法为 sha512
```

## 关于群组：有效与初始群组、groups、newgrp

上面讲解了两个文件，GUID 对应的两个文件则是 `/etc/group 和 /etc/gshadow` 

### `/etc/group 文件结构`

```bash
[root@study ~]# head -n 4 /etc/group
root:x:0:
bin:x:1:
daemon:x:2:
sys:x:3:
```

共 4 个字段

1. 组名：与第三字段 GID 对应

2. 群组密码

   通常不需要设置，如果非要设置，该配置也移动到 /etc/gshadow 文件中了。目前很少有机会设置群组管理员

3. GID：与 /etc/passwd 中第 4 个字段对应

4. 此群组支持的账户名称

   一个账户可以加入多个群组，某个账户加入此群组时，将该账户填入该字段即可，比如 mrcode 与 alex 加入 root 群组，该字段内容为 `mrcode,alex`，整行数据为 `root:x:0:mrcode,alex`

下面为图示 `/etc/pgroup 、 /etc/passwd 、/etc/shadow` 三个文件之间的关联关系

![image-20200219172929946](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20200219172929946.png)

还有一个问题，用户可以有多个群组，那么在工作的时候以哪个群组为准？下面来讲解 **有效群组** 的概念

### 有效群组（effective group）与初始群组（inital group）

每个使用者在 `/etc/passwd` 中的第 4 个字段是 GID，该 GID 则是初始群组，当用户登录系统，立刻就拥有该群组的相关权限。

```bash
# 没有添加次要群组的信息
[root@study ~]# grep mrcode /etc/passwd /etc/group /etc/gshadow
/etc/passwd:mrcode:x:1000:1000:mrcode:/home/mrcode:/bin/bash	# 这里有的 1000 gid
/etc/group:mrcode:x:1000:mrcode	# 这个是 1000 对应的组，书上说在新版中初始群组名称不会在这一行的 第 4 个字段出现了，现在这里是出现了的，不知道是什么原因
/etc/gshadow:mrcode:!!::mrcode


# -G 修改用户所附加的群组，次要群组，也就是说，把 mrcode 账户分配给了 users 这个用户组
[root@study ~]# usermod -a -G users mrcode
[root@study ~]# grep mrcode /etc/passwd /etc/group /etc/gshadow
/etc/passwd:mrcode:x:1000:1000:mrcode:/home/mrcode:/bin/bash	# 这里 gid 指向的是 初始群组
/etc/group:users:x:100:mrcode		# 这一行是多出来的，把 mrcode 账户添加到了 users 这个用户组后面
/etc/group:mrcode:x:1000:mrcode		
/etc/gshadow:users:::mrcode			# 这一行是多出来的
/etc/gshadow:mrcode:!!::mrcode

```

那么如上， mrcode 就拥有一个初始群组 GID=1000 的（mrcode 组）和 users 组，因此在读取/写入/执行文件时，针对群组部分，只要是 mrcode 与 users 群组拥有的功能，使用者 mrcode 都可以拥有。不过这个是针对已经存在的文件而言，如果要建立一个新的文件或则是新的目录，那么新文件的群组是  mrcode 还是 users？ 这个就需要检查当时的有效群组了 

### groups：有效与支持群组的观察

如果已 mrcode 这个使用者的身份登录后，可以通过 groups 指令知道我所有支持的群组

```bash
[mrcode@study ~]$ groups
mrcode users
```

这里输出了两个群组，和上述查看到文件中内容一致，那么 **第一个输出的即为有效群组**，也就是说现在已 touch 建立一个新文件，那么该文件的拥有者为 mrcode，群组也是 mrcode 组

```bash
[mrcode@study ~]$ touch test
[mrcode@study ~]$ ll test
-rw-rw-r--. 1 mrcode mrcode 0 2月  19 18:01 test
```

### newgrp：有效群组的切换

newgrp 指令可以切换有效群组，前提为，你已经有支持的群组

```bash
[mrcode@study ~]$ newgrp users
[mrcode@study ~]$ groups
users mrcode		# 第一个输出也已经修改了
[mrcode@study ~]$ touch test2
[mrcode@study ~]$ ll test*
-rw-rw-r--. 1 mrcode mrcode 0 2月  19 18:01 test
-rw-r--r--. 1 mrcode users  0 2月  19 18:03 test2		# 可以看到已经变更了
[mrcode@study ~]$ exit	# 最后记得离开 newgrp 环境
exit
[mrcode@study ~]$ groups
mrcode users
```

newgrp 指令可以变更目前用户的有效群组，而且是以另外一个 shell 来提供这个功能，

![image-20200220164846764](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20200220164846764.png)

上图是一个示意图，图中 dmtsai 是书上的用户名（笔者这里用的是 mrcode），新的 shell 的有效 GID 对应的是 users，虽然用户的环境设置（例如环境变量等其他数据）不会有影响，但是使用者的「群组权限」会被重新计算。

那么切换有效群组的前提是，你需要加入到这个组，可以通过两种方法加入：

- root 身份使用 usermod 加入
- 没有 root 身份，但是有设置群组管理员，可以让群组管理员通过  gpasswd 加入他所管理的群组中（后续讲解）

### `/etc/gshadow`

可以使用 newgrp 来切换有效群组，但是如果对 gshadow 不懂的话，可能也无法顺利使用 newgrp

```bash
[root@study ~]# head -n 4 /etc/gshadow
root:::
bin:::
daemon:::
sys:::

```

该文件每行有 4 个字段

1. 组名
2. 密码栏：开头为 `!` 标识无合法密码，所以无群组管理员
3. 群组管理员的账户（相关信息在 gpasswd 指令中介绍）
4. 有加入该群组支持的所属账户（与 /etc/group 内容相同）

以系统管理员角度来说，gshadow 文件最大的功能是建立群组管理员，现在很少使用群组管理员了，后续 gpasswd 指令中来实践

## 账号管理

由新增与移除使用者开始讲解

## 新增与移除账户（使用者）

涉及到 useradd、相关配置文件、passwd、usermod、userdel 等知识点

### useradd

```bash
useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM] [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账户

选项与参数：

	-u：UID 是一组数字。直接指定一个特定的 UID 给该账户
	-g：字符串的初始组名，该字符串的 GID 在 /etc/passwd 的第 3 个字段内
	-G：字符串的次要群组，该选项会修改 /etc/group 内的相关字段
	-M：强制！不要建立用户家目录（系统账户默认值）
	-m：强制！要建立用户家目录（一般账户默认）
	-c：/etc/passwd 中第 5 字段的说明内容，可以随便设置
	-d：指定某个目录成为家目录，请务必使用决定路径
	-r：建立一个系统账户，该账户的 UID 有限制（参考 /etc/login.defs）
	-s：后面接一个 shell，若没有指定则预设是 /bin/bash
	-e：后面接一个日期，格式为 YYYY-MM-DD ，此项可写入 shadow 第 8 字段，即是账户失效日期
	-f：后面接 shadow 的第 7 字段，该密码是否会失效。0 为立刻失效，-1 为永远不失效（密码只会过期而强制域登录时重新设置）

```

注意这里是没有密码配置的，密码的设置需要用到 passwd 指令

实践练习，创建一般账户

```bash
# 范例 1： 完全参考默认值创建一个用户，名称为 mrcode1
[root@study ~]# useradd mrcode1
[root@study ~]# ll -d /home/mrcode1/
drwx------. 3 mrcode1 mrcode1 78 Feb 20 17:12 /home/mrcode1/
# 默认会创建家目录，且权限为 700，这是重点！

[root@study ~]# grep mrcode1 /etc/passwd /etc/shadow /etc/group
/etc/passwd:mrcode1:x:1001:1001::/home/mrcode1:/bin/bash
/etc/shadow:mrcode1:!!:18312:0:99999:7:::
/etc/group:mrcode1:x:1001:			# 预设会建立一个与账户同名的群组名
```

可以看到系统规定好了非常多的默认值，所以可以简单的使用 useradd 账户名 来创建使用者。 CentOS 这些默认值主要会帮我们处理几个操作

- 在 `/etc/passwd` 中创建一行与账户相关的数据，包括建立 UID、GID、家目录等
- 在 `/etc/shadow` 中创建该账户的密码相关参数，但是无密码
- 在 `/etc/group` 中创建一个与账户名同名的组名
- 在 `/home` 下创建一个与账户同名的目录作为家的目录，且权限为 700

对于账户密码需要使用 passwd 指令来完成。如果需要定制相关参数，就需要使用选项与参数来详细定制了

```bash
# 范例 2：假设已知道系统中有一个组名为 users，且 UID 1500 并不存在，请用 users 为初始群组，以及 UID 为 1500 创建一个名为 mrcode2 的账户
[root@study ~]# useradd -u 1500 -g users mrcode2
[root@study ~]# ll -d /home/mrcode2
drwx------. 3 mrcode2 users 78 Feb 20 17:20 /home/mrcode2

[root@study ~]# grep mrcode2 /etc/passwd /etc/shadow /etc/group
/etc/passwd:mrcode2:x:1500:100::/home/mrcode2:/bin/bash
/etc/shadow:mrcode2:!!:18312:0:99999:7:::
# 对比上述文件，是不是发现少了一个 mrcode2 的群组？因为初始群组是 users（并且已经存在了），所以就没有必要创建 mrcode2 群组了
```

创建系统账户（system account）

```bash
# 范例 3 ：创建一个系统账户，名为 mrcode3
[root@study ~]# useradd -r mrcode3

# 可以看到没有创建家的目录
[root@study ~]# ll -d /home/mrcode3
ls: cannot access /home/mrcode3: No such file or directory

[root@study ~]# grep /etc/passwd /etc/shadow /etc/group
/etc/passwd:mrcode3:x:988:982::/home/mrcode3:/bin/bash
/etc/shadow:mrcode3:!!:18312::::::
/etc/group:mrcode3:x:982:

```

注意上面的 988:982,前面谈到过，一般账户的 UID 为 1000 以后，那么用户创建的系统账户一般是小于 1000 的。另外由于系统账户要是用来进行运行操作系统所需服务的权限设置，所以系统账户默认都不会主动建立家的目录

系统内置了默认值，那么这些默认值是出自哪里的呢？这就需要了解下 useradd 所使用的参考文件了

### 相关配置文件（useradd 参考文件）

可以使用 `useradd -D`显示默认值

```bash
[root@study ~]# useradd -D
GROUP=100						# 预设群组
HOME=/home						# 默认加目录所在目录
INACTIVE=-1						# 密码失效日，在 shadow 内的第 7 字段
EXPIRE=							# 账户失效日，在 shadow 内的第 8 字段
SHELL=/bin/bash					# 预设的 shell
SKEL=/etc/skel					# 用户家的目录内容数据参考目录
CREATE_MAIL_SPOOL=yes			# 是否主动帮使用者建立邮件信息（mailbox）
```

#### `/etc/default/useradd`

以上信息是存在 `/etc/default/useradd` 文件中的，那么默认值造成的行为是：

- `GROUP=100`：100 这个 GID 对应的群组也就是 users

  但是对于 mrcode1 来说，他的初始群组是 mrcode1，而不是 users，这是因为针对群组的角度有以下两种：

  - 私有群组机制

    系统会建立一个与账户一样的群组给使用者作为初始群组。这种机制比较有保密性，因为使用者都有自己的群组，而家目录权限也将会设定为 700（仅有自己可以进入自己的家目录）。代表性的 distributions 有 RHEL、Fedora、CentOS 等

  - 公共群组机制

    就是以默认值来给定初始群组，因此每个账户都属于 users（默认值）群组，且默认家目录通常的权限会是 `drwx-xr-x ... username users ...`。代表 distributions 有 SuSE 等

  我们的学习机是 CentOS，所以看到的不是默认值

- `HOME=/home`：用户家目录的基准目录（basedir）

  用户名的家目录通常是与账户名相同的，比如 /home/mrcode1

- `INACTIVE=-1`：密码过期后是否会失效的设定值

  在前面讲到 shadow 文件结构，第 7 个字段将会影响密码过期后，在多久时间内还可以使用旧密码登录。0 表示立刻失效，-1 表示永远不失效，如 30 ，则标识过期 30 天后失效

- `EXPIRE=` ：账户失效日期

  shadow 文件中第 8 字段内容，设置账户在哪个日期后直接失效，通常不会设置此项目，如果是付费的回会员系统，则有可能使用

- `SHELL=/bin/bash`：默认使用的 shell 程序文件名

  假如你的系统为 mail server，希望每个账户只能使用 email 的收发信功能，不允许用户登录系统取得 shell，就可以在这里设置为 `/sbin/nologin`，那么预设新用户创建后就无法登录了。

- `SKEL=/etc/skel`：用户家目录参考基准目录

  比如一个新用户 mrcode1 ，那么他的家的目录 `/home/mrcode1` 中的数据是由这里的基准目录中的数据复制过去的。

- `CREATE_MAIL_SPOOL=yes`：建立使用者的 mailbox

  `ll /var/spool/mail/mrcode1` 查看会存在该文件，

#### `/etc/login.defs`

初上上述的基本设置之外， UID/GID 密码参数是在 `/etc/login.defs` 中配置的

```bash
# 这里去掉了原始文件中的注释描述
MAIL_DIR	/var/spool/mail				# 用户默认邮箱目录

PASS_MAX_DAYS	99999					# /etc/shadow 内的第 5 字段，多少天需要变更密码
PASS_MIN_DAYS	0						# /etc/shadow 内的第 4 字段，多少天不可重新设置密码
PASS_MIN_LEN	5						# 密码最短的字符长度，已被 pam 模块取代，该配置已失效
PASS_WARN_AGE	7						# /etc/shadow 内的第 6 字段，过期前 7 天会发送警告消息

UID_MIN                  1000			# 用户的最小 UID ，1000 以下由系统保留
UID_MAX                 60000			# 最大的 UID
SYS_UID_MIN               201			# 保留给用户自行创建的系统账户最小 UID
SYS_UID_MAX               999			# 保留给用户自行创建的系统账户最大 UID

GID_MIN                  1000			# 自定义组的最小 GID
GID_MAX                 60000			# 自定义组的最大 GID
SYS_GID_MIN               201			# 保留给用户创建的系统账户组 ID
SYS_GID_MAX               999			


CREATE_HOME	yes							# 在不加 —M 或 -m 时，是否主动创建用户家目录

UMASK           077						# 用户家目录建立的 umask，因此权限会是 700

USERGROUPS_ENAB yes						# 使用 userdel 删除时，是否删除初始群组
	
ENCRYPT_METHOD SHA512					# 密码加密的机制使用的是  sha512 
```

具体如下：

- `mailbox` 所在目录

  用户的默认 mailbox 文件存放目录 `/var/spool/mail`

- `shadow` 面膜第 4、5、6 字段内容

  `/etc/shadow` 内每一行基本上都有  `0:99999:7` 的存在，就是这里预设的

- `UID/GID` 数值相关

  虽然 LInux 核心支持的账户可大 2的32次方 ，但是一台主机上管理这么多账户也很麻烦。

  那么数值自增原理是：拿到这里配置的 `UID_MIN`和 `/etc/passwd` 中搜寻最大的 UID 数值，并找出两个源中最大的一个+1 得到新用户的 UID

  比如使用 `useradd -r sysaccount` 就会得到 大于 201 小于 1000 的 UID 了

- 用户家目录设置

  `CREATE_HOME	yes` 会让你在使用 useradd 时，自动加上 -m 属性创建家的目录，如果不需要则会加上 -M ，家的目录全是是 `drwx------` 是因为 UMASk=077 的缘故

- 用户删除与密码设置

  `USERGROUPS_ENAB yes	` 使用 userdel 删除时，且该账户所属的初始群组已经没有人在该组下了，则删掉该组。

小结：使用 useradd 指令在 linux 上创建账户时，至少会参考：

- `/etc/default/useradd`
- `/etc/login.defs`
- `/etc/skel/*`

这些文件作为默认值等参考，而承载与记录数据则是 `/etc/passwd`、`/etc/shadow`、`/etc/group`、`/etc/gshadow` 与家目录。所以如果你了解整个程序修改的是那些文件和内容，也可以直接手动修改这些文件。

### passwd

使用 useradd 创建账户之后，在预设的情况下，该账户暂时无法登录，因为在 `/etc/shadow` 第 2 个字段中内容为 `!!`，这个是一个无效密码，所以无法被登录。

```bash
passwd [--stdin] [账户名称]		# 所有人均可使用来修改自己的密码
passwd [-l] [-u] [--stdin] [-S] [-n 天数] [-x 天数] [-w 天数] [-i 日期] 账户			# root 功能

选项与参数：

	--stdin：可以接受前一个管线的数据，作为密码输入，对 shell script 中有较大作用
	-l：Lock 意思，就是会将 /etc/shadow 第 2 字段前面加上 ! 使密码失效
	-u：Unlock，与 -l 相反
	-S：列出密码相关参数，也就是 shadow 文件内的大部分信息
	-n：后面接天数，shadow 第 4 字段，多久不可修改密码
	-x：后面接天数，shadow 第 5 字段，多久内必须要修改密码
	-w：后面接天数，shadow 第 6 字段，密码过期天的警告天数
	-i：后面接天数，shadow 第 7 字段，密码失效天数，当密码过期后多久失效
```

实战练习

```bash
# 用 root 给 mrcode2 设置密码
[root@study mrcode]# passwd mrcode2
Changing password for user mrcode2.
New password: 						# 这里我输入了 12345678，有一个警告
BAD PASSWORD: The password fails the dictionary check - it is too simplistic/systematic
Retype new password: 				# 这里还是输入 12345678 成功了
passwd: all authentication tokens updated successfully.
```
在 root 账户下，虽然有提示，但是最后还是会给你过，可见 root 账户的威力有多大。那么使用一般账户来修改自己的密码

```bash
# 范例 2 ：使用 mrcode2 登录后，修改 mrcode2 自己的密码
[mrcode2@study ~]$ passwd 
Changing password for user mrcode2.
Changing password for mrcode2.
(current) UNIX password: 
New password: 
# 密码太简单，无法通过
BAD PASSWORD: The password fails the dictionary check - it is based on a dictionary word
New password: 
# 与旧密码类似，无法通过
BAD PASSWORD: The password is too similar to the old one
New password: 
BAD PASSWORD: The password fails the dictionary check - it does not contain enough DIFFERENT characters
# 超过重试次数，直接结束了
passwd: Have exhausted maximum number of retries for service
[mrcode2@study ~]$ 
[mrcode2@study ~]$ passwd 
Changing password for user mrcode2.
Changing password for mrcode2.
(current) UNIX password: 
# 旧密码输入不正确，直接结束
passwd: Authentication token manipulation error
[mrcode2@study ~]$ 
[mrcode2@study ~]$ passwd 
Changing password for user mrcode2.
Changing password for mrcode2.
(current) UNIX password: 
New password: 
Retype new password: 
# 终于修改成功了，需要符合条件的密码，还不能是简单的重复的密码
passwd: all authentication tokens updated successfully.

```

密码规范校验非常严格，新的 distribution 大多使用 PAM 模块来进行密码的校验，包括太短、密码与账户相同、密码为字典常见字符串等，都会被拒绝。

root 账户修改密码，不用输入旧密码，而一般用户则需要先输入旧密码。

PAM 模块的管理机制写在 `/etc/pam.d/passwd` 中，而该文件与密码有关的测试模块使用 `pam_cracklib.so`，该模块会校验密码相关的信息，并且取代 `/etc/login.defs`内的 `PASS_MIN_LEN` 的设置，对于 PAM 后续会再介绍。理论上你的密码最好符合以下要求：

- 密码不能与账户相同
- 密码不要选用字典里面会出现的字符串
- 密码长度需要超过 8 个字符
- 密码不要使用个人信息，如身份证、手机号码、其他电话号码等
- 密码不要使用简单的关系，如 1+1=2 等
- 密码尽量使用大小写字符、数字、特殊字符组合等

为了方便系统管理，新版 passwd 还加入了很多创意选项，个人认为最好用的大概是 `--stdin`了，如下面这样修改密码

```bash
# 范例 3：使用 standard input 建立用户的密码
# 这里使用 root 身份吧 mrcode2 的密码设置成了 abc543CC
[root@study mrcode]# echo "abc543CC" | passwd --stdin mrcode2
Changing password for user mrcode2.
passwd: all authentication tokens updated successfully.
```

上面指令会直接更新用户密码，好处是方便处理，缺点是这个密码会保留在指令中，若被攻击，人家可以在 `/root/.bash_history` 中找到该密码，所以该操作一般仅用在 shell script 的大量账户创建中。

注意：该选项并不存在所有的 distribution 版本中，请使用 `man passwd` 确认是否有该选项

```bash
范例 4：管理 mrcode2 的密码具有 60 天变更、密码过期 10 天后账户失效的设置
[root@study mrcode]# passwd -S mrcode2
mrcode2 PS 2020-02-24 0 99999 7 -1 (Password set, SHA512 crypt.)
# 用户最近修改密码 2020-02-24 , 0 最小天数、99999 变更天数、7 警告天数，密码不会失效

[root@study mrcode]# passwd -x 60 -i 10 mrcode2
Adjusting aging data for user mrcode2.
passwd: Success
[root@study mrcode]# passwd -S mrcode2
mrcode2 PS 2020-02-24 0 60 7 10 (Password set, SHA512 crypt.)
```

那么怎么让某个账户暂时无法登录主机呢？比如 mrcode2 这个账户老乱来，最简单的办法就是让他无法登录主机，可以让他的密码变成不合法的 （shadow 第 2 字段长度变更）

```bash
# 范例 5：让 mrocde2 的账户失效
[root@study mrcode]# passwd -l mrcode2 
Locking password for user mrcode2.
passwd: Success
[root@study mrcode]# passwd -S mrcode2
mrcode2 LK 2020-02-24 0 60 7 10 (Password locked.)		# 被锁住了

[root@study mrcode]# grep 'mrcode2' /etc/shadow
# 查看第2字段，密码前面增加了 !!
mrcode2:!!$6$UhalDiXq$q7lGzX.sMx55zXJwmWKNghBrHjEAvuutRcUcqrhxWbjoWy0Z3R7tIoeIio2tuptBenG62JjjVIdfaRFIQwJKw.:18316:0:60:7:10::

# 解锁账户，发现 !! 被去掉了
[root@study mrcode]# passwd -u mrcode2
Unlocking password for user mrcode2.
passwd: Success
[root@study mrcode]# grep 'mrcode2' /etc/shadow
mrcode2:$6$UhalDiXq$q7lGzX.sMx55zXJwmWKNghBrHjEAvuutRcUcqrhxWbjoWy0Z3R7tIoeIio2tuptBenG62JjjVIdfaRFIQwJKw.:18316:0:60:7:10::
```

### chage

除了使用 `passwd -S` 之外，chage 可以使密码参数显示更详细

```bash
chage [-ldEImMW] 账户名

选项与参数：
	-l: 列出该账户的详细密码参数
	-d：后面接日期，修改 shadow 第 3 字段，最近一次修改密码的日期，格式为 YYYY-MM-DD
	-E：后面接日期，修改 shadow 第 8 字段，账户失效日，格式 YYYY-MM-DD
	-I：后面接天数，修改 shadow 第 7 字段，密码失效日期
	-m：后面接天数，修改 shadow 第 4 字段，密码最短保留天数
	-M：后面接天数，修改 shadow 第 5 字段，密码多久需要修改
	-W：后面接天数，修改 shadow 第 6 字段，密码过期前警告天数
```

```bash
# 范例 1：列出 mrcode2 的详细密码参数
[root@study mrcode]# chage -l mrcode2 
Last password change					: Feb 24, 2020
Password expires					: Apr 24, 2020
Password inactive					: May 04, 2020
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 60
Number of days of warning before password expires	: 7
```

使用  passwd 看不到这么详细的配置，使用 chage 就可以了，更详细的使用方式可以  `man chage`

chage 还可以实现让：使用者在第一次登陆时，强制他们一定要修改密码后才能够使用，可以使用如下方式来处理

```bash
# 范例 2：创建一个名为 agetest 账户，该账户第一次登陆使用默认密码，但必须要修改密码后，使用新的密码才能够登陆系统使用 bash 环境

[root@study mrcode]# useradd agetest
# 修改账户和密码为同一个
[root@study mrcode]# echo "agetest" | passwd --stdin agetest
Changing password for user agetest.
passwd: all authentication tokens updated successfully.
# 修改最近修改密码时间为 0 ，这里
[root@study mrcode]# chage -d 0 agetest
[root@study mrcode]# chage -l agetest | head -n 3
Last password change					: password must be changed
Password expires					: password must be changed
Password inactive					: password must be changed
[root@study mrcode]# grep 'agetest' /etc/shadow
agetest:$6$9MX2dbGl$hyI3sKNt5fgSmi1n8xE/PXK6uiC9G7BeUMbluMil7Z9KVWKHO2aIdbCApLCWsLBPgqmiQAeUy48oPoq96Z/5z.:0:0:99999:7:::

# 
[root@study mrcode]# passwd -S agetest 
agetest PS 1970-01-01 0 99999 7 -1 (Password set, SHA512 crypt.)
# 可以看到最近修改密码设置为 0 的话，通过 passwd 会看到是 1970-01-01 ，所以会有问题
```

```bash
# 范例 3：尝试以 agetest 登陆
WARNING! The remote SSH server rejected X11 forwarding request.
You are required to change your password immediately (root enforced)
Last login: Mon Feb 24 11:30:57 2020
WARNING: Your password has expired.
You must change your password now and login again!
更改用户 agetest 的密码 。
为 agetest 更改 STRESS 密码。
（当前）UNIX 密码：			# 第一次登陆需要强制修改密码
新的 密码：
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。

# 修改完成之后，再看密码参数信息，就发现正常了
[root@study mrcode]# chage -l agetest
Last password change					: Feb 24, 2020
Password expires					: never
Password inactive					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 99999
Number of days of warning before password expires	: 7
[root@study mrcode]# passwd -S agetest 
agetest PS 2020-02-24 0 99999 7 -1 (Password set, SHA512 crypt.)
```



### usermod

账户创建好之后，还可以修改选项的，可以直接修改 `/etc/passwd 或 /etc/shadow` 文件，也可以使用该指令来修改

```bash
usermod [-cdefgGlsuLU] username
```

选项与参数：

- `-c`：后面接账户说明， passwd 第 5 字段，账户说明
- `-d`： 后面接账户的家的目录，passwd 第 6 字段
- `-e`：后面接日期，格式为 YYYY-MM-DD，passwd 第 8 字段，失效日期
- `-f`：后面接天数，shadow 第 7 字段
- `-g`：后面接初始群组，passwd 第 4 字段，GID 字段
- `-G`：后面接次要群组，修改的是 /etc/group 内容
- `-a`：与 -G 合用，可 增加次要群组的支持，而非设置
- `-l`：后面接账户名称，也就是修改账户名，passwd 第 1 字段
- `-s`：后面接 Shell 的实际文件，例如 /bin/bash 或 /bin/csh 等
- `-u`：后面就 UID 数字，passwd 第 3 字段
- `-L`：暂时将用户的密码冻结，shadow 密码字段
- `-U`：解冻用户密码

仔细对比，会发现 usermod 选项与 useradd 很类似，他们都是用来微调选项参数的。对于 usermod 的 `-L 和` -U` 参数也不是所有的 distribution 中都有的

```bash
# 范例 1：修改 mrcode2 的说明栏
[root@study mrcode]# usermod -c "mrcode test" mrcode2
[root@study mrcode]# grep mrcode2 /etc/passwd
mrcode2:x:1500:100:mrcode test:/home/mrcode2:/bin/bash
```

```bash
# 范例 2：修改 mrcode2 在 2020/02/25 失效
[root@study mrcode]# usermod -e "2020-02-25" mrcode2
# 可以看到有过期日期，如果直接查看文件内容的话，之前说过了，文件里面存储的是天数，不容易直观看出来是哪一天
[root@study mrcode]# chage -l mrcode2 | grep 'Account expires'
Account expires						: Feb 25, 2020
```

```bash
# 范例 3：当时创建 mrcode3 系统账户时，没有给家的目录，给它创建家的目录
[root@study mrcode]# grep mrcode3 /etc/passwd
mrcode3:x:988:982::/home/mrcode3:/bin/bash
# 虽然有目录指向，但是该目录并不存在
[root@study mrcode]# ll -d /home/mrcode3
ls: cannot access /home/mrcode3: No such file or directory

# copy 参考目录
[root@study mrcode]# cp -a /etc/skel/ /home/mrcode3
# -R 连该目录下的所有文件都一起修改所属用户/群组
[root@study mrcode]# chown -R mrcode3:mrcode3 /home/mrcode3
[root@study mrcode]# ll -d /home/mrcode3/
drwxr-xr-x. 3 mrcode3 mrcode3 78 Jan 17 14:32 /home/mrcode3/
# 这里不使用 -R，因为只要修改目录的权限
[root@study mrcode]# chmod 700 /home/mrcode3
[root@study mrcode]# ll -a ~mrcode3
total 12
drwx------. 3 mrcode3 mrcode3  78 Jan 17 14:32 .
drwxr-xr-x. 7 root    root     80 Feb 24 13:10 ..
-rw-r--r--. 1 mrcode3 mrcode3  18 Aug  8  2019 .bash_logout
-rw-r--r--. 1 mrcode3 mrcode3 193 Aug  8  2019 .bash_profile
-rw-r--r--. 1 mrcode3 mrcode3 231 Aug  8  2019 .bashrc
drwxr-xr-x. 4 mrcode3 mrcode3  39 Jan 17 14:30 .mozilla

```



### userdel

删除用户的相关数据，使用起来很简单了，用户数据有：

- 用户账户、密码相关参数：`/etc/passwd 、/etc/shadow`
- 使用者群组相关参数：`/etc/group、/etc/gshadow`
- 用户个人文件数据：`/home/username、/var/spool/mail/username ...`

```bash
userdel [-r] username  

-r：连同用户的家目录也一起删除
```

```bash
# 范例 1： 删除 mrcode2 用户，连家目录也一起删掉
[root@study mrcode]# userdel -r mrcode2
userdel: user mrcode2 is currently used by process 4472		
# 上面提示有进程在使用该账户，所以没有删除成功
[root@study mrcode]# grep mrcode /etc/passwd
mrcode:x:1000:1000:mrcode:/home/mrcode:/bin/bash
mrcode1:x:1001:1001::/home/mrcode1:/bin/bash
mrcode2:x:1500:100:mrcode test:/home/mrcode2:/bin/bash
mrcode3:x:988:982::/home/mrcode3:/bin/bash
# 退出登录 mrcode2 的中断，再次尝试删除成功。passwd 中也没有了
[root@study mrcode]# userdel -r mrcode2
[root@study mrcode]# grep mrcode /etc/passwd
mrcode:x:1000:1000:mrcode:/home/mrcode:/bin/bash
mrcode1:x:1001:1001::/home/mrcode1:/bin/bash
mrcode3:x:988:982::/home/mrcode3:/bin/bash
```

但是需要注意的是：如果想要删除该用户相关的所有文件等数据，在该指令下达之前，使用 `find / -user username` 找出整个系统内属于 username 的文件，再加以删除。这是因为当一个用户使用过一段时间之后，有他自己产生的数据等文件，比如他的邮件信箱或者是例行工作排程（crontab 后续第十五章讲解）

## 用户功能

useradd、usermod、userdel 指令都是系统管理员所能够使用的指令，一般用户除了 passwd 更改密码之外，还有以下几个常用的账户数据变更与查询的指令

### id

该指令可以查询某人或自己的相关 UID、GID 等信息，参数很多，但是不需要额外记忆，全部列出来就行

```bash
# 范例 1： 查询 root 自己的相关 ID 信息
[root@study mrcode]# id
uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
# context是 SELinux 的内容，暂时不要理会

# 范例 2： 查询 mrcode 1
[root@study mrcode]# id mrcode1
uid=1001(mrcode1) gid=1001(mrcode1) groups=1001(mrcode1)

# 输入一个不存在的账户，得到 no such user 的信息，也可以用来判定该系统上是否有某个账户
[root@study mrcode]# id mrcode00
id: mrcode00: no such user

```

### finger

中文字面意思是：手指或者指纹的意思，它可以查询很多用户相关的信息，其实大部分都在 /etc/passwd 文件里面的信息。由于该指令有点危险，所以新版本中默认不安装该软件；

由于无网络，这里还是使用 [挂载光盘方式](../07/03.md#挂载-cd-或-dvd-光盘) 来安装

```bash
# 先确定是否有挂载光驱到 /mnt 目录下
[root@study mrcode]# df -hT /mnt/
Filesystem                    Type  Size  Used Avail Use% Mounted on
/dev/mapper/centos_study-root xfs    35G  4.4G   31G  13% /				# 这里为空，标识没有
# 找到你的光驱所在位置，这里 Centos 7 在 /dev/sr0
[root@study mrcode]# blkid
/dev/sr0: UUID="2019-09-11-18-50-31-00" LABEL="CentOS 7 x86_64" TYPE="iso9660" PTTYPE="dos" 
/dev/sda1: UUID="e9d54afb-2afe-42de-87fe-9f55d747fcd9" TYPE="xfs" 
/dev/sda2: UUID="CNUXwS-J3Lh-0nDA-TssW-l1vT-90us-MHYnT1" TYPE="LVM2_member" 
/dev/mapper/centos_study-root: UUID="d7e09bb4-2f04-4ed4-b377-91a22fe85ce7" TYPE="xfs" 
/dev/mapper/centos_study-swap: UUID="684eebc0-3f70-4fc1-9a5d-d683f6a07cd0" TYPE="swap" 
# 挂载光盘到 /mnt
[root@study mrcode]# mount /dev/sr0 /mnt/
mount: /dev/sr0 is write-protected, mounting read-only
[root@study mrcode]# df -hT /mnt/
Filesystem     Type     Size  Used Avail Use% Mounted on
/dev/sr0       iso9660  4.4G  4.4G     0 100% /mnt		# 现在有了

[root@study mrcode]# rpm -ivh /mnt/Packages/fin
findutils-4.5.11-6.el7.x86_64.rpm     finger-0.17-52.el7.x86_64.rpm         finger-server-0.17-52.el7.x86_64.rpm  
[root@study mrcode]# rpm -ivh /mnt/Packages/finger-[0-9]*
warning: /mnt/Packages/finger-0.17-52.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY
Preparing...                          ################################# [100%]
Updating / installing...
   1:finger-0.17-52.el7               ################################# [100%]
[root@study mrcode]# ll /mnt/Packages/finger-[0-9]*
-rw-rw-r--. 1 root root 26100 Aug 29  2014 /mnt/Packages/finger-0.17-52.el7.x86_64.rpm
```

安装好之后，进行使用

```bash
finger [-s] username

选项与参数：
	-s：仅列出用户的账户、全名、终端机代号与登录时间
	-m：列出与后面接的账户相同者，而不是利用部分比对（包括全名部分）
```

```bash
# 范例 1：观察 mrcode1 的用户相关账户属性
[root@study mrcode]# finger mrcode1
Login: mrcode1        			Name: 
Directory: /home/mrcode1            	Shell: /bin/bash
Never logged in.
No mail.
No Plan.
```

由于 finger 类似指纹功能，会将用户先关属性列出来，其实他列出的几乎都是 /etc/passwd 文件里面的信息。列出的信息如下含义：

- Login：使用者账户。 /etc/passwd 第 1 字段
- Name：全名，/etc/passwd 第 5 字段，或称为批注信息
- Directory：家目录
- Shell： shell 文件
- Never logged in.：figner 还会调查用户登录主机情况
- No mail：调查 /var/spool/mail 中的信箱资料
- No Plan：调查 `/~mrcode1/.plan` 文件，并将该文件取出来说明

不过否能查询到 Mail 与 Plan 则与全新有关了，因为 Mail/Plan 都是与使用者自己的权限设置有关系。比如 root 能够查询到这些信息，但是不见得 mrcode3 能查询到 mrcode1 的这些信息。

此外，我们可以建立自己想要执行的预定计划，当然，最多是给自己看的，可以这样做

```bash
# 范例 2：利用 mrcode1 建立自己的计划文件
[mrcode1@study ~]$ echo "I will study Linux during this year." > ~/.plan
[mrcode1@study ~]$ finger mrcode1
Login: mrcode1        			Name: 
Directory: /home/mrcode1            	Shell: /bin/bash
On since 一 2月 24 13:48 (CST) on pts/2 from 192.168.4.170
   2 seconds idle
No mail.
Plan:
I will study Linux during this year.			# 可以看到计划了

```

```bash
# 范例 3：找出目前在系统上面登录的用户与登录时间
[mrcode1@study ~]$ finger 
Login     Name       Tty      Idle  Login Time   Office     Office Phone   Host
mrcode    mrcode     pts/0    2:24  Feb 21 14:51                           (192.168.4.170)
mrcode    mrcode     pts/1       2  Feb 21 16:21                           (192.168.4.170)
mrcode1              pts/2          Feb 24 13:48                           (192.168.4.170)

```

可以看到 mrcode 登录了两个 tty 终端。还列出了其他的 Office     Office Phone，那么这两个可以通过 chfn 指令来配置

### chfn

chfn 类似 change finger 的意思，方法如下

```bash
chfn [-foph] [账户名]

选项与参数：
	-f：后面接完整的大名
	-o：您办公室的房间号码
	-p：办公室的电话号码
	-h：家里的电话号码
```

```bash
# 范例 1：mrcode 自己更改自己的相关信息
[mrcode1@study ~]$ chfn
Changing finger information for mrcode1.
名称 []: Mrcode1 test
办公 []: DIV^H in kSU	 # 这里输入了退格键，导致无效，下面重新输入的
chfn: control characters are not allowed
办公 []: 06-123456
办公电话 []: 06-456789
住宅电话 []: 06-789000

密码：				# 这里需要输入自己的密码，用来确认身份
Finger information changed.

# 上面忘记修改终端机语言了，下面重来下
# 会发现已经配置过的会有提示
[mrcode1@study ~]$ chfn
Changing finger information for mrcode1.
Name [Mrcode1 test]: Mrcode1 test
Office [06-123456]: 06-123456
Office Phone [06-456789]: 06-456789
Home Phone [06-789000]: 06-789000

Password: 
Finger information changed.


# 最后查看信息，发现一家有了
[mrcode1@study ~]$ finger mrcode1
Login: mrcode1        			Name: Mrcode1 test
Directory: /home/mrcode1            	Shell: /bin/bash
Office: 06-123456, 06-456789		Home Phone: 06-789000
On since Mon Feb 24 13:48 (CST) on pts/2 from 192.168.4.170
   5 seconds idle
No mail.
Plan:
I will study Linux during this year.

# 这些信息其实是存在 第 5 个字段中的，用逗号隔开了
[mrcode1@study ~]$ grep mrcode1 /etc/passwd
mrcode1:x:1001:1001:Mrcode1 test,06-123456,06-456789,06-789000:/home/mrcode1:/bin/bash
```

该指令一般来说不使用的，除非你有很多用户。他类似论坛里面个人资料属性维护一样的意思

### chsh

change shell 的简写

```bash
chsh [-ls]

选项与参数：
	-l：列出目前系统上可用的 shell。其实就是 /etc/shells 中的内容
	-s：设置修改自己的 shell
```

```bash
# 范例 1：用 mrcode1 身份列出系统上所有合法的 shell，并且制定 chs 为自己的 shell
[mrcode1@study ~]$ chsh -l
/bin/sh
/bin/bash
/usr/bin/sh
/usr/bin/bash
/bin/tcsh
/bin/csh
# 我这里和书上对比少了/sbin/nologin /usr/sbin/nologin ，就是那个合法不可登录的 shell

[mrcode1@study ~]$ chsh -s /bin/csh; grep mrcode1 /etc/passwd
Changing shell for mrcode1.
Password: 
Shell changed.
mrcode1:x:1001:1001:Mrcode1 test,06-123456,06-456789,06-789000:/home/mrcode1:/bin/csh

# 可用看到已经修改成 csh 了，记得再修改回来
[mrcode1@study ~]$ chsh -s /bin/bash 
Changing shell for mrcode1.
Password: 
Shell changed.
```

不论是 chfn 与 chsh 都是能够让一般用户修改 /etc/passwd 这个系统文件的，所以这两个指令文件的权限是什么？

```bash
[mrcode1@study ~]$ ll $(which chsh)
-rws--x--x. 1 root root 23880 Aug  9  2019 /usr/bin/chsh
```

之前讲到过的 [SUID 权限](../06/04.md#文件特殊权限-suid、sgid、sbit)，S 出现在了文件拥有者的权限位置上。

## 新增与移除群组

基本能够群组的内容都与这两个文件有关：`/etc/group`、`/etc/gshadow` ，比较简单，对上面两个文件的新增、修改与移除，如果还加上有效群组的概念，那么 newgrp 与 gpasswd 则需要了解

### groupadd

```bash
group add [-g gid] [-r] 组名

选项与参数：
	-g：后面接某个特定的GID，用来指定 GID
	-r：建立系统群组。与 /etc/login.defs 内的 GID_MIN 有关
```

```bash
# 范例 1：新建一个群组，名称为 group1
[root@study mrcode]# groupadd group1
[root@study mrcode]# grep group1 /etc/group  /etc/gshadow
/etc/group:group1:x:1502:
/etc/gshadow:group1:!::
# 一般组的 GID 默认是从 1000 以上的，这里出现了 1502，是 /etc/group 中最大 GID+1 决定的
```

### groupmod

与 groupadd 类似，修改 group 相关参数

```bash
groupmod [-g gid] [-n group_name] 群组名

选项与参数：
	-g：修改现有的 GID 数字
	-n：修改现有的组名
```

```bash
# 范例 1：将上个范例创建的 group1 名称修改为 mygroup s,GID 为 201
[root@study mrcode]# groupmod -g 201 -n mygroup group1
[root@study mrcode]# grep group1 /etc/group  /etc/gshadow; grep mygroup /etc/group /etc/gshadow
/etc/group:mygroup:x:201:
/etc/gshadow:mygroup:!::
```

温馨提示：不要随意修改 GID，容易造成系统资源的错乱

### groupdel

删除群组

```bash
groupdel [groupname]
```

```bash
# 范例 1： 将刚刚的 mygroup 删除
[root@study mrcode]# groupdel mygroup 

# 范例 2：删除 mrcode1 这个群组
[root@study mrcode]# groupdel mrcode1
groupdel: cannot remove the primary group of user 'mrcode1'
```

会发现，mrcode1 群组无法删除，原因就是有用户在使用该群组

```bash
[root@study mrcode]# grep mrcode1 /etc/group
mrcode1:x:1001:
[root@study mrcode]# grep 1001 /etc/passwd
mrcode1:x:1001:1001:Mrcode1 test,06-123456,06-456789,06-789000:/home/mrcode1:/bin/bash
# 可以看到 mrcode1 在的初始群组就是该群组，因此无法删除，否则会导致 mrcode1 登录系统会找不到 GID,造成困扰
```

那么如果非要删除呢？只能群人该组没有人使用的时候才可以删除，你可以这样做

- 修改 mrcode1 的 GID
- 删除 mrcode1 的使用者

上述方法实际上还是在删除规则中的方法。没有强制删除一说，同样会导致引用该组的文件，查询不到相关组的情况

### gpasswd 群组管理员功能

如果系统管理员太忙了，就可以创建群组管理员来管理哪些账户可以加入/移除该群组

```bash
# 关于系统管理员 root 做的操作
gpasswd groupname
gpasswd [-A user1,...][-M user3,...] groupname
gpasswd [-rR] groupname

选项与参数：
	若没有任何参数时，标识给予 groupname 一个密码 （/etc/gshadow）
	-A：将 groupname 的主控制权交由后面的使用者管理，也就是该组的管理员
	-M：将某些账户加入这个群组中
	-r：将 groupname 的密码移除
	-R：让 groupname 的密码栏失效
	
# 关于群组管理员 Group administrator 做的操作
gpasswd [-ad] user groupname

选项与参数：
	-a：将某位使用者加入到该组
	-d：将某位使用者移除该组
```

实践练习

```bash
# 范例 1：建立一个新群组，名称为 testgroup 且群组交由 mrcode1 管理
[root@study mrcode]# groupadd testgroup		# 创建群组
[root@study mrcode]# gpasswd testgroup		# 设置一个密码
Changing the password for group testgroup
New Password: 
Re-enter new password: 

# 添加 mrcode1 为管理员
[root@study mrcode]# gpasswd -A mrcode1 testgroup
[root@study mrcode]# grep testgroup /etc/group /etc/gshadow
/etc/group:testgroup:x:1502:
/etc/gshadow:testgroup:$6$7mtnL/qNA97Cyxx$xGkPMKtlRucwCBFpsfYGoBM4BLQvYmoTYOvwvBzOMpJyFz1YTBTV7nZvGDvOyG8jhtQ0WGDdl1xhgq959xJ4s/:mrcode1:
```

```bash
# 范例 2：以 mrcode1 登录系统，并且让他加入 mrcode1 mrcode3 称为 testgroup 的成员
[mrcode1@study ~]$ gpasswd -a mrcode1  testgroup
Adding user mrcode1 to group testgroup
[mrcode1@study ~]$ gpasswd -a mrcode3  testgroup
Adding user mrcode3 to group testgroup

[root@study mrcode]# grep testgroup /etc/group /etc/gshadow
/etc/group:testgroup:x:1502:mrcode1,mrcode3
/etc/gshadow:testgroup:$6$7mtnL/qNA97Cyxx$xGkPMKtlRucwCBFpsfYGoBM4BLQvYmoTYOvwvBzOMpJyFz1YTBTV7nZvGDvOyG8jhtQ0WGDdl1xhgq959xJ4s/:mrcode1:mrcode1,mrcode3
```

## 账户管理实例

账户管理需要考虑使用场景，比如让一台主机上的多个账户协同工作：学校的专题生需要分组，同一组的同学间必须能够互相修改对方的数据文件，同时这些同学又需要保留自己的私密数据，因此直接公开家目录是不合适的。

下面提供几个例子来思考与学习

**任务 1**：单纯的完成任务，假设需要的账户数据如下，该如何操作？



账户名称 | 账户全名 | 次要群组 | 是否可登陆主机 | 密码 
:--|--|--|---|---
myuser1|1st user|mygroup1|可以|password
myuser2|2st user|mygroup2|可以|password
myuser3|3st user|无|不可以|password

```bash
# 先处理账户相关属性
# 由于账户由次要群组，不见得存在，所以要手动创建
[root@study mrcode]# groupadd mygroup1
[root@study mrcode]# useradd -G mygroup1 -c "1st user" myuser1
[root@study mrcode]# useradd -G mygroup1 -c "2st user" myuser2
[root@study mrcode]# useradd -c "3st user" -s /sbin/nologin  myuser3

# 处理密码
[root@study mrcode]# echo "password" | passwd --stdin myuser1
Changing password for user myuser1.
passwd: all authentication tokens updated successfully.
[root@study mrcode]# echo "password" | passwd --stdin myuser2
Changing password for user myuser2.
passwd: all authentication tokens updated successfully.
[root@study mrcode]# echo "password" | passwd --stdin myuser3
Changing password for user myuser3.
passwd: all authentication tokens updated successfully.
```

**任务 2**：使用者 pro1、pro2、pro3 是同一个项目计划的开发人员，想要这三个用户在同一个目录下工作，但这三个用户还是拥有自己的家目录与基本的私有群组。假设该项目计划在 /srv/projecta 目录下开发，如何进行

```bash
# 1.创建这三个用户
# 2.把他们的次要群组添加到 projecta 群组
[root@study mrcode]# groupadd projecta
[root@study mrcode]# useradd -G projecta -c "projecta user"  pro1
[root@study mrcode]# useradd -G projecta -c "projecta user"  pro2
[root@study mrcode]# useradd -G projecta -c "projecta user"  pro3
[root@study mrcode]# echo "password" | passwd --stdin pro1
[root@study mrcode]# echo "password" | passwd --stdin pro2
[root@study mrcode]# echo "password" | passwd --stdin pro3

# 创建 /srv/projecta 目录，并且属于 projecta 群组
[root@study mrcode]# mkdir /srv/projecta
[root@study mrcode]# ll -d /srv/projecta; chgrp projecta /srv/projecta/; ll -d /srv/projecta
drwxr-xr-x. 2 root root 6 Feb 24 15:04 /srv/projecta
drwxr-xr-x. 2 root projecta 6 Feb 24 15:04 /srv/projecta		# 已经更改为 projecta 群组了
# 由于只给这 3 个人使用，所以该目录权限需要设置 SGID （这里不清楚的到第 6 章看 SGID 是含义）
# 2 SGID，770 其他人不可访问，拥有者和群组可访问修改和执行
[root@study mrcode]# chmod 2770 /srv/projecta/
[root@study mrcode]# ll -d /srv/projecta
drwxrws---. 2 root projecta 6 Feb 24 15:04 /srv/projecta
```

但是接下来有一个困扰的问题发生了，假如 任务1 的 myuser1 是 projecta 项目的助理，他需要这个项目的内容，但是 _他不可以修改_ 该目录类的任何数据

- 方案 1：将他加入 projecta 群组，此时他拥有所有权限，不符合要求
- 方案 2：将文件目录权限修改为 2775；非群组人员拥有读和执行的权限，这个也不符合要求

此时发现，无能为力了，但是可由借助外部身份认证系统，针对某个人设置专属的权限

## 使用外部身份认证系统

在谈 ACL 之前，先来谈一个概念性的操作，因为目前没有服务器可供练习

有时候，除了本机的账户之外，可能还会使用到其他外部的身份验证服务器所提供的验证身份的功能，如 windows 下有个 Active Directory （AD）的身份验证系统，还有 Linux 为了提供不同主机使用同一组账户密码，也会使用到 LDAP、NIS 等服务器提供的身份验证等

如果 Linux 主机要使用到上面提供的这些外部身份验证系统时，可能要额外设置，为了简化用户的操作流程，CentOS 提供了一个 authconfig-tui 的指令给我们参考，该指令的执行结果如下：

![image-20200224152159050](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20200224152159050.png)

在画面中使用 tab 按钮切换选项（因为这里没有适用的服务器可以测试，后续谈到服务器章节时可以使用这种方式），不过上图大概支持 MD5 这个早期的密码格式了。此外，不要随便将已经启用的项目（也就是被 * 号标识的项目）取消掉，可能会导致某些账户失效

## 主机的细部权限规划：ACL 的使用

从第 5 章开始，在强调 Linux 的权限概念非常重要，传统的权限仅有三种身份（owner、group、others）搭配三种权限（r、w、x），无法单纯的针对某一个使用者或某一个群组来设置设置特殊的权限需求，那么此时就需要使用 ACl 这个机制了

## 什么是 ACl 与如何支持启动 ACl

ACl （Access Control List），主要目的是提供传统的 owner、group、others 的 read、write、execute 权限之外的特殊权限需求设置。ACL 可以针对单一使用者、单一文件或目录来进行 r、w、x 的权限规范，对于需要特殊权限的使用状况非常有帮助

ACl 主要针对以下方面来控制权限：

- 使用者 user
- 群组 group
- 默认属性 mask：针对在该目录下在建立新文件/目录时，规范新数据的默认权限

简单说，有一个目录，给一堆人使用，每个人或每个群组所需要的权限并不相同，使用传统 Linux 三种身份的三种权限是无法达到的，因此基本上，传统的 Linux 权限只能针对一个用户、一个群组以及非此群组的其他人设置权限。无法针对单一用户或个人来设计权限。

### 如何启动 ACl

原本 ACL 是 unix-like 操作系统额外支持的项目，因为近年来对权限需求日益增大，因此目前 ACl 几乎已经预设加入所有场景的 Linux 文件系统的挂载参数中（ext2\3\4、xfs 等），所以无需任何操作。可以通过如下方式来检测是否支持 ACL

```bash
[root@study mrcode]# dmesg | grep -i acl
# 这里 +ACl
[    1.329361] systemd[1]: systemd 219 running in system mode. (+PAM +AUDIT +SELINUX +IMA -APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 -SECCOMP +BLKID +ELFUTILS +KMOD +IDN)
# 这里 SGI XFS with ACLs
[    2.978756] SGI XFS with ACLs, security attributes, no debug enabled
```

笔者疑问：怎么确定 xfs 支持？难道是因为我自己知道是在 xfs 系统上？

## ACL 的设置技巧：getfacl、setfacl

- getfacl：取得某个文件/目录的 ACL 设置信息
- setfacl：设置某个文件/目录的 ACl

### setfacl 指令用法介绍以及最简单的 `u:账户:权限` 设置

```bash
setfacl [-bkRd] [{-ml -x} acl 参数] 目标文件名

选项与参数：
	-m：设置后续的 acl 参数给文件使用，不可与 -x 合用
	-x：删除后续的 acl 参数，不可与 -m 合用
	-b：移除 所有的 ACL 设置参数
	-k：移除 预设的 ACL 参数；（关于所谓的预设参数后续介绍）
	-R：递归设置 acl，包括此目录也会被设置
	-d：设置 「预设 acl 参数」的意思，只对目录有效，在该目录新建的数据会引用此默认值
```

上面是 acl 的选项功能，下面来介绍一些特殊权限的设置方式：

```bash
# 1. 针对特定使用者的方式
# 设置规范：「u:[使用者账户列表]:[rwx]」
# 例如 针对 mrcode1 的权限设置为 rx
[root@study ~]# touch acl_test1
[root@study ~]# ll acl_test1 
-rw-r--r--. 1 root root 0 2月  24 16:47 acl_test1
[root@study ~]# setfacl -m u:mrcode1:rx acl_test1 
[root@study ~]# ll acl_test1 
-rw-r-xr--+ 1 root root 0 2月  24 16:47 acl_test1
# 权限部分多了一个 +，且与原本的权限 644 看起来差异很大。

[root@study ~]# setfacl -m u::rwx acl_test1 
[root@study ~]# ll acl_test1 
-rwxr-xr--+ 1 root root 0 2月  24 16:47 acl_test1
# 设置 u 后面无使用者列表，代表设置该文件拥有者，所以上线显示 root 的全文为 rwx 了
```

上面是设置，权限部分会多出一个 + 号，传统的 ll 是不知道设置了什么的，可以通过  getfacl 来查阅

### getfacl 指令用法

```bash
getfacl filename

选项与参数：几乎与 setfacl 相同，这里不贴了
```

```bash
# 列出刚刚设置的 acl_test1 的权限内容
[root@study ~]# getfacl acl_test1 
# file: acl_test1			# 文件名
# owner: root				# 拥有者，ls -l 看到的第 3 字段
# group: root				# 该文件所属群组，ls -l 看到的第 4 字段
user::rwx					# 使用者列表栏是空的，标识该权限设置针对的是文件的拥有者
user:mrcode1:r-x			# 针对 mrcode1 的权限设置为 rx，与拥有者不同
group::r--					# 群组的设置
mask::r-x					# 此文件预设的有效权限 mask
other::r--					# 其他人拥有的权限
```

### 特定的单一群组的权限设置：`g:群组名:权限`

```bash
# 2. 针对特定群组的方式
# 设置规范：「g:[群组列表]:[rwx]」
# 针对 mygroup1 的权限设置为 rx
[root@study ~]# setfacl -m g:mygroup1:rx acl_test1 
[root@study ~]# getfacl acl_test1 
# file: acl_test1
# owner: root
# group: root
user::rwx
user:mrcode1:r-x
group::r--
group:mygroup1:r-x				# 多了这个权限设置
mask::r-x
other::r--
```

### 针对有效权限设置：`m:权限`

群组与使用者设置类似，但是那个 mask 有点像是「有效权限」的意思：使用者或群组所设置的权限必须要存在与 mask 的权限设置范围内才会生效，也就是有效权限 effective permission

```bash
# 3. 针对有效全是 mask 的设置方式
# 设置规范：「m:[rwx]」
# 针对刚刚的文件规范仅有 r
[root@study ~]# setfacl -m m:r acl_test1 
[root@study ~]# getfacl acl_test1 
# file: acl_test1
# owner: root
# group: root
user::rwx
user:mrcode1:r-x		#effective:r--		# 有效权限只有 r
group::r--
group:mygroup1:r-x		#effective:r--
mask::r--
other::r--

```

该功能可以通过 mask 来规范最大允许的权限，就能避免不小心开放某些权限给其他使用者或者群组了。不过，通常都是将 mask 设置为 rwx，再分别依据不同的使用者、群组去规范他们的权限

### 例题

```bash
# 范例 1： 将前一小节任务二中 /srv/projecta 目录，让 myuser1 可以进入查阅，但是 myuser1 不具有修改的权限
# 由于 myuser1 是独立的使用者与群组，因此无法使用传统的 Linux 权限设置，此时应该使用 ACL 的设置

# 1. 先测试使用 myuser1 能否进入该目录
[myuser1@study ~]$ cd /srv/projecta/
-bash: cd: /srv/projecta/: Permission denied

# 2. 修改 ACL 权限为读和执行
[root@study ~]# setfacl -m u:myuser1:rx /srv/projecta/
[root@study ~]# getfacl /srv/projecta/
getfacl: Removing leading '/' from absolute path names
# file: srv/projecta/
# owner: root
# group: projecta
# flags: -s-
user::rwx
user:myuser1:r-x		# 设置了权限
group::rwx
mask::rwx
other::---

# 3. 测试是否成功进入
[myuser1@study ~]$ cd /srv/projecta/
[myuser1@study projecta]$ ll -a
total 0
drwxrws---+ 2 root projecta  6 Feb 24 15:04 .
drwxr-xr-x. 3 root root     22 Feb 24 15:04 ..
# 测试写入，缺少不可写入
[myuser1@study projecta]$ touch testing
touch: cannot touch 'testing': Permission denied

```

上面例子完成了之前任务二的后续需求，下面来介绍下默认权限，也就是创建新文件是否能继承 ACl 设置？

```bash
# 使用 root 账户取创建目录可文件，查看是否有继承 acl 设置
[root@study projecta]# touch abc1
[root@study projecta]# mkdir abc2
[root@study projecta]# ll -d abc*;
-rw-r--r--. 1 root projecta 0 Feb 25 09:32 abc1
drwxr-sr-x. 2 root projecta 6 Feb 25 09:32 abc2
```

可以看到权限后面没有 `+` 号出现，标识这个 acl 属性没有被继承

### 使用默认权限设置目录未来文件的 ACL 权限继承 `d:[u|g]:[user|group]:权限`

```bash
# 设置规范：d:[u|g]:[user|group 使用者列表]:[权限 rwx]
# 让 myuser1 在 /srv/projeecta 目录下一直具有 rx 的预设权限
[root@study projecta]# setfacl -m d:myuser1:rx /srv/projecta/
[root@study projecta]# getfacl /srv/projecta
getfacl: Removing leading '/' from absolute path names
# file: srv/projecta
# owner: root
# group: projecta
# flags: -s-
user::rwx
user:myuser1:r-x
group::rwx
mask::rwx
other::---
default:user::rwx
default:user:myuser1:r-x			# 可以看到这里已经被设置上了
default:group::rwx
default:mask::rwx
default:other::---
```

设置之后，还出现了其他针对拥有者的 default 配置。所以这里再次使用 root 账户取创建，也能看到继承效果了

```bash
[root@study projecta]# touch abc1
[root@study projecta]# mkdir abc2
[root@study projecta]# ll -d abc*
-rw-rw----+ 1 root projecta 0 Feb 25 09:40 abc1
drwxrws---+ 2 root projecta 6 Feb 25 09:40 abc2
```

如果需要让 ACL 属性全部消失，可以通过 `setfacl -b 文件名` 达到效果

### 例题练习

#### 第一题

针对 `/srv/projecta` 目录的权限设置中，需要满足以下需求：

1. 取消 myuser1 的设置（包括默认值）
2. 不能让 pro3 这个用户使用该目录，也就是 pro3 在该目录下没有任何权限

```bash
# 1. 取消 myuser1 的设置和默认值
# 先查询到配置了哪些属性
[root@study projecta]# getfacl /srv/projecta/ | grep myuser1
getfacl: Removing leading '/' from absolute path names
user:myuser1:r-x
default:user:myuser1:r-x
# 通过 -x 参数来取消，取消的时候，不需要写权限，直接写前面定位部位
[root@study projecta]# setfacl -x u:myuser1 /srv/projecta/
[root@study projecta]# setfacl -x d:myuser1 /srv/projecta/
[root@study projecta]# getfacl /srv/projecta/ | grep myuser1


# 2.让 pro3 这个用户无法使用该目录
[root@study projecta]# setfacl -m u:pro3:- /srv/projecta/
[root@study projecta]# getfacl /srv/projecta/ | grep pro3   
getfacl: Removing leading '/' from absolute path names
user:pro3:---			# 这样一来就没有任何权限了
```

## 使用者身份切换

身份变化可能有以下几个原因：

- 使用一般账户：系统平时操作的好习惯

  为了安全，一般都会建议尽量以一般身份使用者来操作 Linux 的日常工作。等到需要设置系统环境时，才切换成 root 来管理系统，相对比较安全，避免误操作一些严重的指令，例如 `rm -rf /`

- 用较低权限启动系统服务

  比如：apache 软件，创建一个 apache 用户来启动它，就算该软件被攻破了，至少不至于损坏整个系统；

- 软件本身的限制

  在远古时代的 telnet 程序中，默认是不允许使用 root 身份登录的，若发现是 UID=0 的登录直接拒绝登录；此外 ssh 也可以设置拒绝 root 登录的

由于上述考虑，没有系统设定等的特殊需求下，都是使用的一般账户登录，如果有则可以变换身份，主要有两种方式：

- `su`：以 `su -` 指令直接将身份变成 root

  该指令需要 root 密码，输入验证成功后才可以切换成 root 身份

- `sudo`：以 `sudo 指令` 执行指令串

  由于 sudo 需要实现设置，且 sudo 需要输入用户自己的密码，因此多人共同管理同一部主机时， sudo 要比 su 好，至少 root 密码不会流传出去

## su
最简单的身份切换指令，可以进行任何身份的切换

```bash
su [-lm] [-c 指令] [username]
```

选项与参数：

- `-`：单纯使用 `su -` 表示使用 login-shell 的变量文件读取方式来登录系统，若使用者名称没有加上去，则代表切换为 root 身份
- `-l`：与 `-` 类似，单后面需要加要切换的使用者账户，也是 login-shell 的方式
- `m`：与 `-p` 是一样的，表示：使用目前的环境设置，而不读取新使用者的配置文件
- `-c`：仅进行一次指令，所以 `-c` 后面可以加上指令

前面讲解过 [ login-shell ](10/04.html#login-与-non-login-shell)  是啥，这里有没有加上 `-` 的指令涉及到了 login-shell 与 non-login shell 的变量读取方式，下面以例子说明

```bash
# 范例 1： 假设现在身份是 mrcode , 想要使用 non-login shell 的方式变成 root
[mrcode@study ~]$ su			# 注意提示字符是 mrcode 身份
Password: 
[root@study mrcode]# id	
# id 识别的确是 root 身份
uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

# 查看环境变量中
[root@study mrcode]# env | grep 'mrcode'
HOSTNAME=study.centos.mrcode
USER=mrcode			# 当前用户还是 mrcode
PATH=/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin		# 这个影响最大，只找了 /home/mrcode
MAIL=/var/spool/mail/mrcode		# 信箱也是
PWD=/home/mrcode				# 也并非是 root 的家的目录
LOGNAME=mrcode
XDG_DATA_DIRS=/home/mrcode/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share
# 虽然 UID 已经具有 root 的身份，但是还有一堆变量是原本 mrcode 的身份，所以还是有很多数据无法直接利用

# 离开当前的 su 环境
[root@study mrcode]# exit
exit

```

所以单纯的使用 su 切换成 root 方式，。读取的变量设定方式为 non-login shell 的方式，这种方式很多原本的变量不会被改变，尤其是很重要的 PATH 变量，由于没有改变为 root 环境，因此很多 root 管惯用的指令就只能使用绝对路径来执行。所以执行切换身份时，务必使用以下范例

```bash
# 范例 2：使用 login shell 的方式切换为 root 的身份并观察变量
[mrcode@study ~]$ su -
Password: 					# 输入 root 密码登录
Last login: Tue Feb 25 10:47:26 CST 2020 on pts/1
[root@study ~]# env | grep root
USER=root
MAIL=/var/spool/mail/root
PATH=/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
PWD=/root
HOME=/root
LOGNAME=root
XDG_DATA_DIRS=/root/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share
XAUTHORITY=/root/.xauthL0s7Pj
# 可以看到环境变量都变成 root 的了
[root@study ~]# env | grep mrcode
HOSTNAME=study.centos.mrcode
```

同样可以使用 exit 指令离开 root 身份，如果只是想使用 root 执行一次命令，就恢复原本的身份可以使用 `-c` 选项

```bash
# 范例 3：mrcode 要执行  hread -n 3 /etc/shadow 一次，已知 root 密码
[mrcode@study ~]$ head -n 3  /etc/shadow
head: cannot open '/etc/shadow' for reading: Permission denied
[mrcode@study ~]$ su - -c "head -n 3 /etc/shadow"
Password: 				# 输入 root 密码
root:$6$eC75oi.rU.wJPhgN$C.C.qFXTvmJ64qFnez88TdcsHuuQAqtAYrukgBYBspgSZbCgzvJuv4OVJ9gaEfA2/.T7e68AZW7RoZt6ubeHD0::0:99999:7:::
bin:*:17834:0:99999:7:::
daemon:*:17834:0:99999:7:::
[mrcode@study ~]$ 				# 注意看这里的身份还是 mrcode

```

那么怎么切换为其他账户呢？

```bash
# 范例 4：原本是 mrcode 使用者，想要变换身份为 mrcode1

[mrcode@study ~]$ su -l mrcode1
Password: 				# 输入 mrcode1 的密码
Last login: Mon Feb 24 17:35:35 CST 2020 from 192.168.4.170 on pts/2
[mrcode1@study ~]$ su -			
密码：				# 输入 root 的密码，切换到 root
上一次登录：二 2月 25 10:58:09 CST 2020pts/1 上
[root@study ~]# id sshd			# 查看这个账户，发现有该账户
uid=74(sshd) gid=74(sshd) 组=74(sshd)
[root@study ~]# su -l sshd			
This account is currently not available.  # 提示无法切换到 sshd
[root@study ~]# finger sshd		# 查看他的信息如下
Login: sshd           			Name: Privilege-separated SSH
Directory: /var/empty/sshd          	Shell: /sbin/nologin		# 这里的 nologin 问题
Last login 二 2月 25 11:00 (CST) on pts/1
No mail.
No Plan.
[root@study ~]# exit
登出		# 离开第 2 次的 su
[mrcode1@study ~]$ exit
登出		# 离开第 1 次的 su
[mrcode@study ~]$ 		# 这里又回到了最初的 mrcode  身份

```

### 小结用法

- 若要完整的切换到新使用者的环境，比如要使用 `su - username 或 su -l username`，才会连同 PATH、USER、MAIL 等变量都转成新用户的环境
- 如果仅想要执行一次 root 的指令，可以利用 `su -c "指令串"` 的方式来处理
- 使用 root 切换称为任何使用者时，并不需要输入新用户的密码

## sudo

相对于 su 需要了解切换用户的密码（常常是 root 的密码），而 sudo 的执行仅需要自己的密码，还可以设置不需要密码就可以执行 sudo；由于 sudo 可以让你以其他用户的身份执行指令，（通常是利用 root 身份执行命令），所以并非所有人都能够执行 sudo，而是需要规范到 `/etc/sudoers`内的用户才能够执行 sudo 指令

::: tip
一般用户能够具有 sudo 的使用权，是经过管理员审核通过后，也就是受信任的账户，否则一般用户默认是不能操作 sudo 的
:::

### sudo 的指令用法

由于系统默认仅有 root 可以执行 sudo，因此下面的范例先使用 root 来执行。等谈到 visudo 时，再已一般使用者来讨论其他 sudo 的用法

::: tip
最初情况下是只有 root 能执行 sudo 的，但是在安装 CentOs 时，创建了一个用户，这个用户也具有 sudo 的权限
:::

```bash
sudo [-b][-u 新使用者账户]

选项与参数：
	-b：将后续的指令放到背景中让系统自动执行，而不与目前的 shell 产生影响
	-u：后面可以接要切换的使用者账户，若没此项，则表示切换到 root 身份
```

```bash
# 范例 1：想要以 sshd 的身份在 /tmp 下创建一个名为 myssh 的文件
[root@study ~]# sudo -u sshd touch /tmp/mysshd
您在 /var/spool/mail/root 中有新邮件
[root@study ~]# ll /tmp/mysshd 
-rw-r--r--. 1 sshd sshd 0 2月  25 13:04 /tmp/mysshd
# 可以看到是由 ssh 创建的

# 范例 2：以 mrcode1 的身份创建 ~Vbird1/www 并在其中创建 index.html 文件
[root@study ~]# sudo -u mrcode1 sh -c "mkdir ~mrcode1/www; cd ~mrcode1/www; echo 'This is index.html'  > index.html"
[root@study ~]# ll -a ~mrcode1/www/
总用量 4
drwxr-xr-x. 2 mrcode1 mrcode1  24 2月  25 13:15 .
drwx------. 7 mrcode1 mrcode1 201 2月  25 13:15 ..
-rw-r--r--. 1 mrcode1 mrcode1  19 2月  25 13:15 index.html
# 注意上面 那个 sh -c ""  这一串不是 sudo 的参数，是指令；sh --help 可以看到 sh -c "指令串"，是利用 sh 执行命令
```

范例 2 使用 sh -c 来执行多重指令。

为什么 sudo 预设仅有 root 能使用？是因为 sudo 的执行流程如下：

1. 当用户执行 sudo 时，系统与 `/etc/sudoers` 文件中搜索该使用者是否有执行 sudo 的权限
2. 若使用者具有可执行 sudo 的权限后，便让使用者「输入用户自己的密码」来确认
3. 若密码输入成功，变开始进行 sudo 后续接的指令（root 执行 sudo 时不需要密码）
4. 若要切换的身份与执行者身份相同，也不需要输入密码

所以是否能使用 sudo ，必须要看 `/etc/sudoers` 中是否有配置，这种文件都有自己的规范，所以提供了一个 visudo 指令来帮助管理该文件

### visudo 与 `/etc/sudoers`

使用 visudo 来修改，在结束离开时，会校验 `/etc/sudoers` 的语法，来避免修改错误的语法导致 sudo 无法使用

一般来说，visduo 的设置方式有几种简单的方法，下面介绍几个简单的例子来说明

### 单一用户使用 sudo

单一用户可进行 root 所有指令，与 sudoers 文件语法：

```bash
# 让 mrcode1 账户可以使用 root 的任何指令，基本上有两种方式：
# 1. 直接修改 /etc/sudoers
[root@study ~]# visudo 
:set nu			# 显示行号
    100 root    ALL=(ALL)       ALL
    101 mrcode1 ALL=(ALL)       ALL			# 在 100 行后，添加 mrcode1 的数据
# 然后保存离开
```

其实 visudo 利用 vi 将文件打开修改。

```bash
使用者账户	登陆者的来源主机名=（可切换的身份）	可下达的指令
root    	ALL=(ALL)       				ALL
```

各字段含义如下：

1. 使用者账户：系统中那个账户可以使用 sudo 指令
2. 登陆者的来源主机名：就是信任哪一台网络主机可以联机，这个值可以指定客户端计算机。默认的 ALL 是允许任何一台网络主机
3. 可切换的身份：这个账户可以切换成什么身份来下达后续的指令。默认 root 可以切换成任何人
4. 可下达的指令：可用该身份下达什么指令？**这个指令请务必使用绝对路径**，预设 root 可以切换任何身份且下达任何指令

All 是特殊的关键词，代表任何身份、主机、指令

```bash
# 进行测试
[mrcode1@study ~]$ tail -n 1 /etc/shadow		# 这里是 mrcode1 登录的
# 提示权限不足
tail: cannot open '/etc/shadow' for reading: Permission denied

# 使用 sudo 来执行
[mrcode1@study ~]$ sudo tail -n 1 /etc/shadow

We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.
# 上面只是提示，大概意思是能力越大责任越大，慎重之类的意思
[sudo] password for mrcode1: 				# 然后输入 mrcode1 自己的密码，就可以执行了
pro3:$6$oku6c8Az$GUOVL1SkmFnSnVHvUCKnToNv8l7094dQ17/GOw/R5mdxqiE0THtkFaO4GpzFMxJy30rZbpWgQcNSpMqHN8KWT/:18316:0:99999:7:::

```

利用 wheel 群组以及免密码的功能处理 visudo

### wheel 群组使用 sudo

之前曾建立过 pro1、pro2、pro3  让这 3 个用户也可以使用 sudo，但是通过群组的方式来支持

```bash
# 1. 使用 visudo 设置 whell 群组
visudo

     99 ## Allow root to run any commands anywhere
    100 root    ALL=(ALL)       ALL
    101 mrcode1 ALL=(ALL)       ALL
    102 
    103 ## Allows members of the 'sys' group to run networking, software,
    104 ## service management apps and more.
    105 # %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS
    106 
    107 ## Allows people in group wheel to run all commands
    108 %wheel  ALL=(ALL)       ALL
    
# 在最左边增加 % 表示是一个群组，注意在编辑的时候，当时笔者吧 $wheel 这一行写在 上面 root 后面，报错就报错说有语法错误，不知道是否也有识别，需要写到这个 Allows people in group wheel to run all commands 这一行下面呢？
# 注意： whell 这个配置默认已经配置过了，并且该组也已经存在了。应该是系统初始化就有的

# 2. 将 pro1 添加进 wheel 群组
[root@study ~]# usermod -a -G wheel pro1

# 3. 切换到 pro1 、pro2 并执行 sudo 命令查看
[root@study ~]# su -l pro1
[pro1@study ~]$ sudo tail -n 1 /etc/shadow

We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

[sudo] password for pro1: 
pro3:$6$oku6c8Az$GUOVL1SkmFnSnVHvUCKnToNv8l7094dQ17/GOw/R5mdxqiE0THtkFaO4GpzFMxJy30rZbpWgQcNSpMqHN8KWT/:18316:0:99999:7:::

# 切换到 pro2 
[root@study ~]# su -l pro2
[pro2@study ~]$ export LANG=C
[pro2@study ~]$ sudo tail -n 1 /etc/shadow

We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

[sudo] password for pro2: 
pro2 is not in the sudoers file.  This incident will be reported.
# 提示 pro2 不在 sudoers 文件中
```

那么这里对群组进行了支持，pro2 和 pro3 也要支持 sudo 的话，直接使用 usermod 将他们添加到 wheel 组中即可

前面说安装系统创建的用户，直接设置为了管理员的话，也是可以使用 sudo 指令的，这个操作就是将那个账户添加到了 wheel 组了

```bash
[mrcode@study ~]$ id mrcode 
uid=1000(mrcode) gid=1000(mrcode) groups=1000(mrcode),100(users)
[mrcode@study ~]$ id pro1
uid=1505(pro1) gid=1508(pro1) groups=1508(pro1),10(wheel),1507(projecta)

[mrcode@study ~]$ sudo cat /etc/shadow
[sudo] password for mrcode: 
mrcode is not in the sudoers file.  This incident will be reported.

# 我们这里看到，这里的账户并没有加入 wheel 这个组，实际执行 sudo 的话，也会提示不支持；
# 这就说明当时我并没有选择添加为管理员

```

从 Centos 7 开始， `%wheel` 这行默认存在，并且也有这个组

### 免密使用 sudo

既然管理员都信任这些用户了，是否可以提供：不需要密码就可以使用 sudo 呢？

```bash
[root@study ~]# visudo 
## Allows people in group wheel to run all commands
# %wheel        ALL=(ALL)       ALL


## Same thing without a password
%wheel  ALL=(ALL)       NOPASSWD: ALL
```

找到上述地方，在第三个字段，将 NOPASSWD 哪一行放开，把上面原始的注释掉。也就是在可下达的指令前使用 `NOPASSWD:` 来标识不需要密码

### 有限制的指令操作

上面的配置可以让使用者利用 root 身份进行任何事情，如果要配置只能够允许进行一部分事情的话，比如 myuser1 只能帮 root 修改其他用户的密码，可以如下做

```bash
[root@study ~]# visudo 
## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL
mrcode1 ALL=(ALL)       ALL
myuser1 ALL=(ALL)       /usr/bin/passwd		# 使用绝对路径，来给定使用的指令


# 再使用 myuser1 来测试是否成功
[myuser1@study ~]$ sudo cat /etc/shadow
[sudo] password for myuser1: 
Sorry, user myuser1 is not allowed to execute '/bin/cat /etc/shadow' as root on study.centos.mrcode.
# 可以看到不支持 /bin/cat 指令

# 再使用 sudo passwd ，发现可以执行
[myuser1@study ~]$ sudo passwd myuser3
Changing password for user myuser3.
New password: 
BAD PASSWORD: The password is shorter than 8 characters
Retype new password: 
passwd: all authentication tokens updated successfully.
# 上面修改了 myuser3 的密码

# 这里不加参数，发现可以直接修改 root 的密码，这样就不行了
[myuser1@study ~]$ sudo passwd
Changing password for user root.
New password: 

# 还可以限制指令的参数
myuser1 ALL=(ALL)       !/usr/bin/passwd, !/usr/bin/passwd root, /usr/bin/passwd [A-Za-z]*
# 不可执行的指令添加上了感叹号 !
# 上面直接执行 passwd 和 passwd root 都不允许，后面一个用正则规定了参数，必须使用字母开头的参数

# 测试，就会提示不被允许执行
[myuser1@study ~]$ sudo passwd
Sorry, user myuser1 is not allowed to execute '/bin/passwd' as root on study.centos.mrcode.
```

### 通过别名建立 visudo

比如我有 15 个用户加入刚刚的管理员，那么是否都需要将上述限制命令的代码复制 15 行配置到 visudo 中呢？

可以通过 visudo 的别名功能，可以是：指令别名、账户别名、主机别名等。这里仅介绍账户别名

```bash
# 假设 pro1、pro2、pro3 与 myuser1、myuser2 要加入上述的密码管理员的 sudo 列表中
# 那么可以创建一个账户别名为 ADMPW，然后配置该账户别名

## User Aliases
## These aren't often necessary, as you can use regular groups
## (ie, from files, LDAP, NIS, etc) in this file - just use %groupname
## rather than USERALIAS
# User_Alias ADMINS = jsmith, mikem
User_Alias ADMPW = pro1, pro2, pro3, myuser1, myuser2

## Command Aliases
## These are groups of related commands...
Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, !/usr/bin/passwd root, /usr/bin/passwd [A-Za-z]*

## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL
mrcode1 ALL=(ALL)       ALL
myuser1 ALL=(ALL)       !/usr/bin/passwd, !/usr/bin/passwd root, /usr/bin/passwd [A-Za-z]*
ADMPW   ALL=(ALL)       ADMPWCOM
# 上面定义了 User_Alias 用户别名 和 Cmnd_Alias 命令别名
# 并在之前配置用户的地方使用上了这两个别名
```

别名建议使用大写；后续对用户的维护直接修改别名中的即可

### sudo 的时间间隔问题

如果使用同一个账户在极短时间内重复操作 sudo 来运行指令的话，在第二次执行 sudo 时，并不需要输入自己的密码！也可以正常运行

这是因为有一个机制，sudo 两次操作间隔超过 5 分钟，那么就需要重新输入一次密码。这个机制也是为了安全，比如你输入密码执行过一次 sudo，这个时候去厕所了，超过了 5 分钟还没有回来，防止别人动你的电脑执行 sudo

### sudo 搭配 su 的使用方式

有时候需要大量执行很多 root 的工作，一直使用 sudo 就很麻烦，可以通过下面的方式结合 su，并且还使用用户自己的密码来变成 root

```bash
visudo
User_Alias ADMINS = pro1, pro2, pro3, myuser1
ADMINS  ALL=(root)      /bin/su -

# 创建一个 ADMINS 的用户别名，再限制该用户只能切换到 root，并且只能执行 su -
# 注意使用是：用 sudo 命令来执行 su
[pro2@study ~]$ sudo su -
[sudo] password for pro2: 
Last login: Tue Feb 25 15:09:19 CST 2020 on pts/1
[root@study ~]# 		# 看这里的提示，变成了 root

```

这个方式是这样的：

1. 限制了可切换为 root，那么这些用户只能切换到 root
2. 并且这些用户只能通过 sudo 执行 `su -` 的操作
3. sudo 需要输入用户自己的密码，通过之后相当于是 root 身份了，用 root 身份执行 su -  切换到 root 身份，就不需要 root 密码了（root 使用 su 不需要密码）

通过中方式也能授权管理员账户。

## 用户的特殊 shell 与 PAM 模块

前面讲解的大多是一般身份用户与系统管理员 root 的相关操作，而且大多是关于可登陆系统的账户来说的。

那么想要建立一个 **仅仅能使用 mail server 相关邮件服务的账户，而该账户并不能登陆 Linux 主机**，如果分配密码则

另外 前面说`/etc/login.defs`文件中，关于密码长度默认是 5 个字符串长度，但是该值以及被 PAM 模块所取代了，那么 PAM 是什么？为什么他可以影响我们使用者的登录呢？

## 特殊的 shell：`/sbin/nologin`

在 passwd 文件结构里面有看到过这个 shell 的配置，如果配置了这个 shell 给一个账户，那么该账户试图登录的时候，就会提示如下的信息

```bash
This account is currently not available
```

这里说的无法登录仅表示：这个使用者无法使用 bash 或其他 shell 来登录系统，并不是说无法使用其他系统资源

那么上面的提示内容，仅仅提示该账户目前不可用，其实可以通过 `/etc/nologin.txt` 文件来自定义提示内容

```bash
# 利用纯 mail 账户，例如 myuser3 时，显示自定义内容给登陆者查看

[root@study ~]# vim /etc/nologin.txt
 该账户只用来接收邮件，不提供登录服务。

# 之前创建 myuser3 的时候 shell 就设置的是 /sbin/nologin
[pro2@study ~]$ su -l myuser3
Password: 
该账户只用来接收邮件，不提供登录服务。

# 可以看到提示信息就被自定义了
```

## PAM 模块简介

PAM（Pluggable Authentication Modules 嵌入式模块）可以说是一套应用程序编程接口，提供了许多验证机制，只要使用者将验证阶段的需求告知 PAM 后，PAM 就能返回验证结果成功或失败。

没有用 PAM 之前，需要自己写程序处理账户密码的验证，那么就有人收集了很多验证需求实现后提供了一个验证模块。因此程序都可以引用该模块来进行验证

![image-20200225155547026](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20200225155547026.png)

如图示，PAM 是一个独立的 API，你的程序也可以引入他来进行验证

PAM 用来进行验证的数据成为模块（Modules），每个 PAM 模块功能都不太相同，比如，之前 passwd 指令输入密码，报错提示在字典上面找到的字符串，这是 PAM 的 pam_cracklib.so 模块的功能

## PAM 模块设置语法

这里以  passwd 指令调用的 PAM 来说明：

1. 用户开始执行 `/usr/bin/passwd` 程序，并输入密码
2. passwd 调用 PAM 模块进行验证
3. PAM 模块会到 `/etc/pam.d/` 寻找与指令 passwd 同名的配置文件
4. 根据 `/etc/pam.d/passwd` 内的设置，引用相关的 PAM 模块逐步进行验证分析；

那么从这里就看出来了，他的入口配置是：

1. 配置文件要放到 `/etc/pam.d/` 中，且同名
2. 程序要调用

下面先来看看配置文件的内容。

```bash
[pro2@study ~]$ cat /etc/pam.d/passwd 
#%PAM-1.0		# PAM 版本说明
auth       include	system-auth			# 每一行是一个验证程序
account    include	system-auth
password   substack	system-auth
-password   optional	pam_gnome_keyring.so use_authtok
password   substack	postlogin
验证类别	控制标准	PAM 模块与该模块的参数
```

该文件中，除了第一行声明  PAM 版本外，其他的 `#` 开头的均为批注内容

上面第 2 字段中出现的 include 是标识，调用后面的文件来作为这个类别的验证，所以是调用 `/etc/pam.d/system-auth` 文件来进行验证

1. 验证类别（type）：主要分为 4 种

   - auth：authentication 认证

     主要用来校验使用者的身份验证，这种类别通常是需要密码来校验的，所以后续接的模块是用来校验用户的身份

   - account：account 账户

     大部分是在进行 authorization 授权，这种类别主要检验使用者是否具有正确的权限，比如：使用一个过期的密码来登录，就无法登录了

   - session

     该使用者在此次登录（或使用这个指令）期间，PAM 所给予的环境设置。这个类别通常用在记录用户登录与注销时的信息。

     例如：假如你常常使用 su 或 sudo 指令，那么应该可以在 `/var/log/secure` 里面发现很多关于 pam 的说明，而且记载的数据是`session open、session close` 的信息

   - password 密码

     主要提供验证的修改工作，比如修改密码

   这 4 个验证类型通常是有顺序的（也有例外），有顺序是因为：

   1. 总是要先验证身份（auth）后
   2. 系统才能够获取到用户身份给予适当的授权与权限设置（account）
   3. 登录与注销期间的环境才需要设置，需要记录登录与注销信息 （session）
   4. 修改密码时，使用 password 类别

   根据业务来看，貌似是有必要有顺序的

2. 验证的控制旗标（control flag）

    简单说：是验证通过的标准，主要有 4 种控制方式

   - required

     验证成功则带有 success 标志，失败则 failure 标志，但是都会继续后续的验证流程

   - requisite

     若验证失败立刻返回 failure 标志，并终止后续的验证流程。若验证成功则带有 success 标志，并继续后续的验证流程。

      由于失败就终止，因此失败时所产生的 PAM 信息无法通过后续的模块来记录了

   - sufficient

     若验证成功立刻回传 success 给原程序，并终止后续验证流程；

      若验证失败则带有 failure 标志并继续后续的验证流程。与 requisite 相反

   - optional

     该模块控件大多数是显示信息，并不是用在验证方面

   图示如下：

   ![image-20200225205700001](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20200225205700001.png)

## 常用模块简介

由于常常需要通过各种方式来登录 login 系统，来看看登录所需要的 PAM 流程：

```bash
[mrcode@study ~]$ cat /etc/pam.d/login 
#%PAM-1.0
auth [user_unknown=ignore success=ok ignore=ignore default=bad] pam_securetty.so
auth       substack     system-auth
auth       include      postlogin
account    required     pam_nologin.so
account    include      system-auth
password   include      system-auth
# pam_selinux.so close should be the first session rule
session    required     pam_selinux.so close
session    required     pam_loginuid.so
session    optional     pam_console.so
# pam_selinux.so open should only be followed by sessions to be executed in the user context
session    required     pam_selinux.so open
session    required     pam_namespace.so
session    optional     pam_keyinit.so force revoke
session    include      system-auth
session    include      postlogin
-session   optional     pam_ck_connector.so

# 这里看到最多的应该是有引用了 system-auth，来观察下
[mrcode@study ~]$ cat /etc/pam.d/system-auth
#%PAM-1.0
# This file is auto-generated.
# User changes will be destroyed the next time authconfig is run.
auth        required      pam_env.so
auth        required      pam_faildelay.so delay=2000000
auth        sufficient    pam_fprintd.so
auth        sufficient    pam_unix.so nullok try_first_pass
auth        requisite     pam_succeed_if.so uid >= 1000 quiet_success
auth        required      pam_deny.so

account     required      pam_unix.so
account     sufficient    pam_localuser.so
account     sufficient    pam_succeed_if.so uid < 1000 quiet
account     required      pam_permit.so

password    requisite     pam_pwquality.so try_first_pass local_users_only retry=3 authtok_type=
password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok
password    required      pam_deny.so

session     optional      pam_keyinit.so revoke
session     required      pam_limits.so
-session     optional      pam_systemd.so
session     [success=1 default=ignore] pam_succeed_if.so service in crond quiet use_uid
session     required      pam_unix.so

```

system-auth 用到了非常多的 PAM 模块，每个模块的功能都不太相同，详细的模块数据可以在以下位置找到：

- `/etc/pam.d/*`：每个程序个别的 PAM 配置文件
- `/lib64/security/*`：PAM 模块文件的实际放置目录
- `/etc/security/*`：其他 PAM 环境的配置文件
- `/usr/share/doc/pam-*`：详细的 PAM 说明文件

```bash
[root@study ~]# find / -name *.pam_nologin
/usr/share/doc/pam-1.1.8/txts/README.pam_nologin
比如 pam_nologin.so 的说明文件，就在以上路径，可以阅读下
```

下面介绍几个常用的模块，详细的信息需要自己去查阅资料

- pam_securetty.so：限制系统管理员 root 只能怪从安全的 secure 终端机登录

  例如 tty1、tty2 就是传统的终端机装置名称。安全的终端机设置在 `/etc/securetty` 文件中，里面列出了终端机名称，查看下就知道为什么 root 可以从 tty1~tt2 登录，而不能通过 telnet 登录了

- pam_nologin.so：可以限制一般用户是否能够登录主机

  当 `/etc/nologin` 文件存在时，则所有一般使用者均无法再登录系统了，并在他们的终端机上会将该文件内容显示出来；

  正常情况下，该文件是不能存在系统中的，该模块对 root 以及已经登录系统中的一般账户没有影响。注意：该文件与 `/etc/nologin.txt` 不是同一个

- pam_selinux.so：SELinux 是个针对程序来进行细部管理权限的功能

  在后续的第 16 章中再来讨论 SELinux。由于 SELinux 会影响到用户执行程序的权限，因此利用 PAM 模块，将 SELinux 暂时关闭，等到验证通过后，在启动

- pam_console.so：

  当系统出现某些问题，或则是需要使用特殊的终端接口（如 RS232 之类的终端机联机设备）登录主机时，该模块可以帮助处理一些文件权限问题，让使用者可以通过特殊终端接口 console 顺利登录系统

- pam_loginuid.so：

  系统账户与一般账户的 UID 不同的，一般账户 UID 均大于 1000 才合理。可以用该模块来验证使用者的 UID 是否符合要求
  
- pam_unix.so：

  很复杂的且重要的模块，可以用在验证阶段的认证功能，可以用在授权阶段的账户许可证管理，可以用在会议（session）阶段的登录文件记录，甚至可以用在密码更新阶段的校验。该模块在早期用的较多

- pam_pwquality.so：

  可以用来校验密码强度，包括是否在字典中、密码输入几次都失败就断掉此次联机等功能。

  最早使用的是 pam_cracklib.so 模块，后来改成 pam_pwquality.so 模块，pam_pwquality.so 兼容 pam_cracklib.so 模块，同时提供了 `/etc/security/pwquality.conf` 文件可以额外指定默认值，比较容易处理修改

- pam_limits.so

  在第 10 章中讲解的 ulimit，就是该模块提供的能力，更多信息可以查看 `/etc/security/limits.conf` 

了解了模块大致功能后，这里讨论下 login 的 PAM 验证机制流程：

1. 验证阶段 auth：
   1. 经过 pam_securetty.so ，如果使用者是 root 时，会参考 /etc/securetty 的设置
   2. 经过 pam_env.so 设置额外的环境变量
   3. 经过 pam_unix.so 校验密码，若通过则回报 login 程序
   4. 若未通过，则继续往下以 pam_succeed_if.so 判断 UID 是大于 1000，若小于 1000 则回报失败
   5. 若大于 1000 则以 pam_deny.so 拒绝联机
2. 授权阶段 account：
   1. 以 pam_nologin.so 判断 /etc/nologin 是否存在，若存在则不允许一般使用者登录
   2. 接下来以 pam_unix.so 及 pam_localuser.so 进行账户管理
   3. 再以 pam_succeed_if.so 判断 UID 是否小于 1000，若小于 1000 则不记录登录信息
   4. 最后已 pam_permit.so 允许该账户登录
3. 密码阶段 password：
   1. 以 pam_pwauality.so 设置密码仅能尝试错误 3 次
   2. 接下来以 pam_unix.so 通过 sha512 shadow 等功能进行密码校验，若通过则回报 login 程序
   3. 若不通过则以 pam_deny.so 聚焦登录
4. 会议阶段 session：
   1. 以 pam_selinux.so 暂时关闭 SELinux
   2. 使用 pam_limits.so 设置好用户能够操作的系统资源
   3. 登录成功后开始记录相关信息在登录文件中
   4. 以 pam_loginuid.so 规范不同的 UID 权限
   5. 开启 pam_selinux.so 功能

这小节感觉太难了，笔者没有看懂也联想不到，只知道 /etc/nologin 文件存在的话，一般使用者都不能登录，远程联机有可能无法使用 root 登录，这些都是 PAM 模块提供的功能

## 其他相关文件

前面讲到：

- `/etc/securetty` 会影响到 root 可登录的安全终端机
- `/etc/nologin` 会影响到一般使用者是否能够登录
- `/etc/pam.d` 是 PAM 相关配置文件所在目录
- `/usr/share/doc/pam-(版本)` 是 PAM 说明文件所在目录
- `/lib64/security` 是 PAM 模块程序文件所在目录

主要的 PAM 文件都在 `/etc/security` 目录中，下面介绍几个可能会用到的配置文件

### limits.conf

[ 第 10 章讲到的 ulimit 功能 ](./10/02.md#与文件系统及程序的限制关系：ulimit)，除了修改使用者的 `~/.bashrc` 配置文件外，系统管理员可以通过 PAM 来管理，就是 `/etc/security/limits.conf` 这个文件。这里做个简单介绍

```bash
# 范例 1：mrcode1 这个用户只能建立 100MB 的文件，且大于 90MB 会警告

[root@study ~]# vim /etc/security/limits.conf 
#<domain>      <type>  <item>         <value>
#
mrcode1 soft    fsize   90000
mrcode1 hard    fsize   100000
# 账户	限制类型	限制项目	限制值
1 字段：账户或群组，若为群组则前面需要加上 @，例如 @projecta
2 字段：类型，是严格 hard，还是仅警告 soft
3 字段：此例中是文件容量
4 字段：为限制值，在此列中单位为 KB

# 使用 mrcode1 登录后执行以下操作
[mrcode1@study ~]$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) 90000		# 查看到这里限制变成了 90000

#尝试创建大于 90MB 的文件
[mrcode1@study ~]$ dd if=/dev/zero of=test bs=1M count=110
File size limit exceeded (core dumped)
[mrcode1@study ~]$ ll --block-size=K test
-rw-rw-r--. 1 mrcode1 mrcode1 90000K Feb 25 22:07 test
# 发现该文件最多只有 90MB

```

```bash
# 范例 2： 限制 pro1 这个群组，每次仅能有一个用户登录系统 maxlogins
[root@study ~]# vim /etc/security/limits.conf
@pro1   hard    maxlogins 1

# 群组功能限制，似乎只对初始群组才有效果限制
# 如果尝试多个 pro1 的登录时，第二个以后就无法登录了
# 并且会在 /var/secure 文件中还会出现如下的信息
pam_limits(login:session): Too many logins (max 1) for pro1
```

该文件设置完就生效了。由于 PAM 是在程序调用时才设置，对于已经登录过的系统是没有效果的。再次登录时才会生效

### `/var/log/secure、/var/log/messages`

如果发生任何无法登录或则是产生一些你无法预期的错误时，由于 PAM 模块都会将数据记载到 `/etc/log/secure` 中，所以发生了问题，务必到该文件查看下日志信息。

举例来说：在 `limits.conf` 介绍的范例 2 中，多重登录错误可以到 `/var/log/secure` 内查询


## Linux 主机上的用户信息传递

如何针对系统上的用户进行查询？如果在 Linux 上操作时，有其他用户也登录主机，如何与它谈话？想知道某个账户的相关信息，如何查阅？

## 查询使用者：w、who、last、lastlog

之前提到过的 id、finger 等指令可以查询一个用户的相关信息。而 last 可以知道使用者合适登录的系统，前面第 10 章节 bash 中讲解过的

可以通过 w 或 who 来查询当前已登录系统的用户，也就是相当于在线用户列表

```bash
[root@study ~]# w
# 当前时间、开机(up)多久、几个用户在线
 22:20:50 up  1:37,  2 users,  load average: 0.18, 0.14, 0.17
# 一个表格说明，每一行表示一个使用者
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
mrcode   pts/0    192.168.0.105    21:11    2.00s  0.19s  3.27s sshd: mrcode [priv]
mrcode   pts/1    192.168.0.105    21:11    1:09m  8.52s  8.50s top

[root@study ~]# who
mrcode   pts/0        2020-02-25 21:11 (192.168.0.105)
mrcode   pts/1        2020-02-25 21:11 (192.168.0.105)
```

通过 lastlog 获得每个账户的最近登录时间，lastlog 会读取 `/var/log/lastlog` 文件

```bash
[root@study ~]# lastlog
# 用户名           端口     来自             最后登陆时间
Username         Port     From             Latest
root             pts/0                     二 2月 25 21:23:43 +0800 2020
bin                                        **从未登录过**
daemon                                     **从未登录过**
adm                                        **从未登录过**
lp                                         **从未登录过**
mrcode           pts/1    192.168.0.105    二 2月 25 21:11:00 +0800 2020
mrcode1          pts/0                     二 2月 25 22:05:37 +0800 2020

```

## 使用者谈话：write、mesg、wall

### write 对话

与系统上在线用户进行谈话，通过 write 将信息传给接收者

```bash
write 使用者账户 [用户所在终端接口]
```

```bash
[root@study ~]# who
mrcode   pts/0        2020-02-25 22:28 (192.168.0.105)
mrcode   pts/1        2020-02-25 22:28 (192.168.0.105)
root     pts/4        2020-02-25 22:28 (192.168.0.105)
root     pts/5        2020-02-25 22:28 (192.168.0.105)
# 笔者使用的是 ssh 软件链接的。类似 xshell 软件，所以可能显示的不是 tty 接口把
# 开启了两个链接，并且使用 su 切换的账户，是通过这个 who 看不出来的
# 只会显示最初登录系统的账户信息
# 笔者这里开启了两个窗口，一个登录 mrcode 账户，一个登录 root 账户

[root@study ~]# write mrcode pts/0
Hello,there:
Please dont't do anything wrong...
# 在 root 窗口上，对 mrcode pts/0 的终端接口写信息
# 上面两行是 root 传递的文字信息
# 要结束传递的话，需要通过组合键 ctrl + d 结束


# 在 mrcode 这边就会看到传递过来的信息了
[mrcode@study ~]$
Message from root@study.centos.mrcode on pts/2 at 22:33 ...
Hello,there:
Please dont't do anything wrong...
EOF

这两个交互式这样的，当 root 敲入 write mrcode pts/0 指令时，mrcode 这边就相当于进入了一个聊天窗口，输入一行按下回车键，信息就会显示到对方那边去。所以他们两个就可以谈话了
```

### mesg 启用或关闭对话功能

因为这种方式是及时聊天，如果 mrcode 此时正在查询资料，那么就会打断他原本的工作，如果 mrode 不想接受任何人的信息，可以下达该指令

```bash
[mrcode@study ~]$ mesg n	# 关闭信息
[mrcode@study ~]$ mesg
is n
```

不过该指令对 root 传来的信息是无效的，那么我们关闭 root 的，使用 mrcode 对 root 发送

```bash
# 当然要先打开 mesg 的功能，才能对别人发送信息
[mrcode@study ~]$ mesg y	# 打开
[mrcode@study ~]$ write root pts/2
write: root has messages disabled on pts/2
# 发现无法对 root 发送信息
```

### wall 广播信息

还可以通过 wall 对所有在线用户广播信息

```bash
[mrcode@study ~]$ wall "I will shutdown my linux server..."
[mrcode@study ~]$
Broadcast message from mrcode@study.centos.mrcode (pts/0) (Tue Feb 25 22:45:41 2020):

I will shutdown my linux server...

# 所有在线用户都能收到，包括 root，当然前提是对方 mesg y 打开时
```

## 使用者信箱：mail

wall、write 需要用户在线才能够使用交谈，可以使用 mail 寄信给用户，每个用户都具有一个 mailbox，可以寄、收 mailbox 内的信件。一般来说 mailbox 会放置在 `/var/spool/mail` 中，一个账号一个 mailbox 文件。比如 mrcode1 就具有 `/var/spool/mail/mrcode1` 这个 mailbox

### 寄信

```bash
mail -s "邮件标题" username@localhost
```

```bash
# root 用户给 mrcode 寄信
# 指令下达之后会进入写做模式，不过该模式下无法使用退格键，只能想好再写
[root@study ~]# mail -s "nice to meet you" mrcode
Hello,D.m tsai
Nice to meet you in the network.
You are so nice. bybye!
.					# 最后一行输入小数点，再次回车会完成寄信操作
EOT		
[root@study ~]#
```

会发现 mail 中的编辑器不好用，所以可以使用流来完成内容的导入

```bash
[root@study ~]# mail -s "nice to meet you" mrcode  < filename
# 先把信息写在文件中，然后使用 < 传输
```

```bash
# 范例 ：将你的家目录下的环境变量文件 ~/.bashrc 寄给自己
mail -s "bashrc file content" mrcode < ~/.bashrc
# 范例 ：通过管线命令将 `ls -al ~` 内容传给 root 自己
ls -al ~ | mail -s "myfile" root
```

## 收信

收信也是使用 mail 指令，如上面寄给了 mrcode

```bash
[mrcode@study ~]$ mail
Heirloom Mail version 12.5 7/5/10.  Type ? for help.
"/var/spool/mail/mrcode": 1 message 1 new
>N  1 root                  Tue Feb 25 22:52  19/700   "nice to meet you"
& 		# 这里可以输入很多指令，可以通过输入 ？ 查询

# > ：是表示目前处理的信件是哪一封
# N ：表示该信件还未读过

# 尝试输入 ? 会出现以下的提示
& ?
               mail commands
type <message list>             type messages
next                            goto and type next message
from <message list>             give head lines of messages
headers                         print out active message headers
delete <message list>           delete messages
undelete <message list>         undelete messages
save <message list> folder      append messages to folder and mark as saved
copy <message list> folder      append messages to folder without marking them
write <message list> file       append message texts to file, save attachments
preserve <message list>         keep incoming messages in mailbox even if saved
Reply <message list>            reply to message senders
reply <message list>            reply to message senders and all recipients
mail addresses                  mail to specific recipients
file folder                     change to another folder
quit                            quit and apply changes to folder
xit                             quit and discard changes made to folder
!                               shell escape
cd <directory>                  chdir to directory or home if none given
list                            list names of all available commands

A <message list> consists of integers, ranges of same, or other criteria
separated by spaces.  If omitted, mail uses the last message typed.
&
```

上面信息中的 「message list」是表示每封邮件左边那个数据序号

指令 | 含义
-----|-----------------------------------------------------------------------------------------
h    | 列出信件比奥拓；如查询 40 封左右的信件，则输入 `h 40`
d    | 删除后续接的信件号码，删除单封是 `d10`，范围删除是 `d10-20`，该动作生效需要配合 q 指令
s    | 将信件存储成文件。比如将第 5 封的内容存储到文件 `~/mail.file` 可以使用 `s 5 ~/mail.file`
x    | 只离开，不生效；或者输入 exit 也可以；比如刚刚用 h 删除了信件，使用 x 离开，就会撤销删除
q    | 生效并离开；尤其是删除

对于 h 操作来说，只有 5 封邮件的时候，使用 h 6 会报错，使用 h 2，同样会显示所有的，不知道是咋回事

## CentOS 7 环境下大量建立账户的方法

系统上如果有一堆账户，怎么判定某些账户是否存在一些问题？如何创建或删除大量账户？

这个肯定是需要用到 shell script 脚本的，下面一一介绍

## 一些账户相关的检查工具

### pwck

该指令会检查 `/etc/passwd` 账户配置文件内的信息，与实际的家目录是否存在，等信息、还可以比对 `/etc/passwd` 与 `/etc/shadow` 的信息是否一致、如果 `/etc/passwd` 内的数据字段错误时，会提示使用者。

一般来说，作者只是利用这个指令来检查输入是否正确

```bash
[root@study ~]# pwck
user 'ftp': directory '/var/ftp' does not exist
user 'saslauth': directory '/run/saslauthd' does not exist
user 'gluster': directory '/run/gluster' does not exist
user 'pulse': directory '/var/run/pulse' does not exist
user 'gnome-initial-setup': directory '/run/gnome-initial-setup/' does not exist
pwck: no changes
```

上面告知了这些账户没有家目录；仔细看由于大部分都是系统账户（的确不需要家目录）

```bash
# 对应的群组检查
[root@study ~]# grpck
```

### pwconv

该指令主要目的是将 `/etc/passwd` 账户与密码移动到 `/etc/shadow` 中。（早起的 Unix 中没有 shadow 文件，在 passwd 的第 2 字段）

使用 pwdconv 后：

- 比对 `/etc/passwd` 和 `/etc/shadow` 

  若 passwd 存在的账户并没有对应的 shadow 密码时，则 pwconv 会去 `/etc/login.defs` 获取相关的密码数据，并建立该账户的 shadow 数据

- 若 `/etc/passwd` 内存在加密后的密码数据时，则 pwconv 会将该密码栏移动到 `/etc/shadow` 中，并将原来的密码栏内容变更为 x

所以该工具只是为了迁移早期的数据而存在的，对于现在几乎上没有啥用处了

### pwunconv

该指令是将 `/etc/shadow` 内的密码栏数据写回 `/etc/passwd` 中，并且删除 `/etc/shadow` 文件

### chpasswd

读取未加密前的密码，加密并将加密后的密码写入 `/etc/shadow`

该指令可以用在大量建立账户的场景中，可以由  Standard input 读入数据，数据格式为 `username:password`。

```bash
# 比如：更新 mrcode3 账户的密码
[root@study ~]# echo "mrcode3:123" | chpasswd
[root@study ~]# grep mrcode3 /etc/shadow
mrcode3:$6$v4wtD/HDxmMD.F$tkpuAZ3Onx14Oa2YYqpD3CfZrexV0D18nolGGfl7cIcXG/57r2S2S2oQzHjuiN4efmFYCOpHS.cK/.cVDk6zi/:18318::::::
[root@study ~]# echo "mrcode3:123abv" | chpasswd
[root@study ~]# grep mrcode3 /etc/shadow
mrcode3:$6$kqggs/OgGqR0ftc$zHF9FbcJqd0fWHNx4hGwWXcQgrjPosDcpDed7iH7/LYb0tAOBerMvUzodNrX.K4UW5AUYs9S/DGaetJBD3xu6.:18318::::::
# 观察下密码栏的加密字符串，发现的确是被更新过了
```

它预设使用 `SHA512` 进行加密，想要更改就需要使用 `-c 和 -e` 选项来指定。不过从 CentOS 5.x 之后，passwd 指令已经添加了 `--stdin` 选项，可以说是替代了这里的功能

## 大量建立账户模板（适用 passwd --stdin 选项）

下面是一个新站用户功能的脚本

```bash
vim accountadd.sh

#!/bin/bash
# This shell script will create amount of linux login accounts for you.
# 1. check the "accountadd.txt" file exist？ you must create that file manually
#	one account name one line in the "accountadd.txt" file
# 2. use openssl to create users password
# 3. User must change his password in his first login
#
# 此命令行命令脚本将为您创建大量 Linux 登录。
# 1.检查 "accountadd.txt" 文件是否存在？您必须手动创建该文件，一个账户一行
# 2.使用 openssl 创建用户密码
# 3.用户必须在首次登录时更改密码
export PATH=/bin:/sbin:/usr/bin:/usr/sbin

# 0. userinput
usergroup=""		# 如果你的账户需要次要组，在这里定义
pwmech="openssl"	# 如果是 openssl(生成随机数) 则使用 openssl 指令生成 base64 的 6 位数随机密码
homeperm="no"		# 如果修改为 yes，则将该账户家目录权限修改为 711

# 1. 检查 accountadd.txt 文件
action="${1}"			# create 使用 useradd 指令、delete 使用 userdel 指令
if [ ! -f accountadd.txt ]; then
	echo "accountadd.txt 文件不存在！"
	exit 1
fi

# 如果有群组，则建立系统群组
[ "${usergroup}" != "" ] && groupadd -r ${usergroup}
rm -f outputpw.txt
usernames=$(cat accountadd.txt)

for username in ${usernames} 
do
	case ${action} in
		"create")
			# 存在组则拼接选项 -G 是为该用户添加次要群组
			[ "${usergroup}" != "" ] && usegrp=" -G ${usergroup} " || usegrp=""
			useradd ${usegrp} ${username}	# 新增账户
			# 如果没有值则使用用户名作为密码
			[ "${pwmech}" == "openssl" ] && usepw=$(openssl rand -base64 6) || usepw=${username}
			echo ${usepw} | passwd --stdin ${username}  # 创建密码
			chage -d 0 ${username}		# 配置首次登陆必须修改密码
			[ "${homeperm}" == "yes" ] && chmod 711 /home/${username}
			echo "username=${username},password=${usepw}" >> outputpw.txt
		;;
		"delete")
			echo "删除用户 ${username}"
			userdel -r ${username}			# -r 将用户家目录也删除
		;;
		*)
			echo "请使用：$0 [create|dellete]"
		;;
	esac
done
```

脚本写好了，接下来进行测试

```bash
vim accountadd.txt

std01
std02
std03
std04
std05
```

```bash
sh accountadd.sh create
[root@study ~]# sh accountadd.sh create
更改用户 std01 的密码 。
passwd：所有的身份验证令牌已经成功更新。
更改用户 std02 的密码 。
passwd：所有的身份验证令牌已经成功更新。
更改用户 std03 的密码 。
passwd：所有的身份验证令牌已经成功更新。
更改用户 std04 的密码 。
passwd：所有的身份验证令牌已经成功更新。
更改用户 std05 的密码 。
passwd：所有的身份验证令牌已经成功更新。

[root@study ~]# cat outputpw.txt 
username=std01,password=s4j4jdwr
username=std02,password=G4iW/O6M
username=std03,password=HGO0rvI8
username=std04,password=17NAhvgS
username=std05,password=Q2CftODm

# 可以看到输出的账户和密码信息，你可以打印出来，一行一条裁剪，然后发给使用者
```

## 重点回顾

- Linux 操作系统上，关于账户与群组，其实记录的是 UID/GID 的数字
- 使用者的账户/群组与 UID/GID 对应，参考 `/etc/passwd` 及 `/etc/group` 文件
- `/etc/passwd` 文件结构以冒号隔开为 7 个字段，分别是：账户名称、密码、UID、GID、全名、家目录、shell
- UID 只有 0 与非 0 两种，不为 0 则一般账户。一般账户又分为系统账户 （-999），及可登陆这账户（大于 1000）
- 账户的密码已经移动到 `/etc/shadow` 文件中，该文件权限仅为 root 可修改。分为 9 个字段，分别是：账户名称、加密密码、密码变更日期、密码最小可修改日期、密码最大修改日期、密码过期前警告日数、密码失效天数、账户失效日、保留未使用
- 使用者可以支持多个群组，其中在新建文件时会影响新文件群组者为有效群组。而写入 `/etc/passwd` 的第 4 个字段称为初始群组
- 与使用者创建、更改参数、删除有关的指令为：useradd、usermod、userdel 等，passwd 是创建密码
- 与群组创建、修改、删除的有关指令为：groupadd、groupmod、groupdel 等
- 群组的观察与有效群组的切换为：groups 、newgrp
- useradd 指令作用参考的文件有 `/etc/default/useradd`、`/etc/login.defs`、`/etc/skel` 等
- 观察用户详细的密码参数，可以使用 `chage -l 账户` 来处理
- 用户自行修改参数的指令有：chsh、chfn 等，观察指令有：id、finger 等
- ACL 的功能需要文件系统支持，CentOS 7 预设 XFS 支持 ACL 功能
- ACl 可进行单个使用者或群组的权限管理，但 ACL 的启动需要有文件系统的支持
- ACL 的设置可使用 setfacl，查阅可使用 getfacl
- 身份切换可使用 su 或 sudo，但使用 sudo 必须先以 visudo 设置可使用的指令
- PAM 模块可进行某些程序的校验，与 PAM 模块有关的配置文件在 `/etc/pam.d/*`、`/etc/security/*`
- 系统上账户登录情况查询可使用 w、who、last、lastlog 等
- 在线与使用者交谈可使用 write、wall。脱机状态下可使用 mail 传递邮件 


## 本章练习

## 情景模拟题 1

将本服务的账户分开管理，

- 分为单纯邮件使用者：将该账户加入名为 mail 的初始群组，且此账户不可使用 bash 等 shell 登陆系统。
- 可登陆系统账户：将该账户加入 youcan 的次要群组

练习期望：

- 目标：了解 `/sib/nologin` 的用途
- 前提：可自行观察使用者是否已经建立等问题
- 需求：需了解 useradd、groupadd 等指令的用法

```bash
# 1. 检查两个群组是否存在，不存在则建立
grep mail /etc/group
grep youcan /etc/group
groupadd youcan

# 2. 创建邮件账户，可以准备脚本来处理
vim popuser.sh
#!/bin/bash
for username in pop1 pop2 pop3
do
	# -g 初始群组； -s 指定 bash； -M 不要创建家目录
	useradd -g mail -s /sbin/nologin -M $username
	echo $username | passwd --stdin $username		# 将密码设置为账户相同
done

sh popuser.sh

# 3. 建立一般账户，同样适用脚本创建
vim loginuser.sh
#!/bin/bash
for username in pop1 pop2 pop3
do
	# -g 初始群组； -s 指定 bash； -M 不要创建家目录
	useradd -G youcan -s /bin/login $username
	echo $username | passwd --stdin $username		# 将密码设置为账户相同
done

sh loginuser.sh
```

## 简答题部分

- root 的 UID 与 GID 是多少？基于这个理由，让 test 这个账户具有 root 权限，怎么做？

  都为 0，可以直接修改 `/etc/passwd` 中 test 账户的 UID 和 GID 字段变成 0

- 如何将一个账户暂时停掉？让该账户无法登录？

  由于是暂时失效，不能使用 userdel 来删除，有以下几种方式

  - 将 `/etc/passwd` 的 shell 字段修改为 `/sbin/nologin`
  - 将 `/ec/shadow` 的密码字段，内容前增加一个 !，让密码失效
  - 将 `/etc/shadow` 第 8 字段关于账户失效日期，设置为小于目前的日期数字
  
- 使用 useradd 时，新增账户里面的 UID、GID 还有其他相关的密码控制是哪几个文件配置的?

  `/etc/login.defs` `/etc/default/useradd`

- 在使用 useradd 时，预设情况中，他们家目录就含有一个名称为 www 的子目录，该怎么操作？

  会以 `/etc/skel` 作为参考目录，可以在该目录下创建一个  www 的目录

- 简单说明系统账户与一般账户的差别？

  一般而言，为了让系统能够顺利以较小的权限运行，系统会有很多账户，例如 mail、bin、adm 等。为了确保这些账户能够在系统上面具有独一无二的的权限，一般来说 Linux 会保留一些 UID 给系统使用，在 CentOS 5.x 上，小于 500 以下的 UID 即是所谓的系统账户

- 简单说明，为何 CentOS 建立使用者时，会主动创建一个与账户同名的群组，而不是使用 `/etc/default/useradd` 的设置？

  不同的 distribution 对于使用者 group 的建立机制不同，主要机制分为两种：

  - public group schemes：给予一个公用的群组，一般来说是 users；以 SUSe server9 为代表
  - private group schemes：创建一个与账户同名的群组，以 CentOS 7.x 为例

- 如何创建一个使用者 alex，所属群组为 alexgroup，预计使用 csh，他的全名为 “Alex Tsai”，还需要加入 users 群组中

  ```bash
  groupadd alexgroup
  # -g 初始组， -G 次要组，-m 建立家目录
  useradd -c "Alex Tsai" -g alexgroup -G users -m alex
  # 务必先建立群组，才能够建立账户
  ```

- 由于种种因素，导致你的用户家目录以后都需要放置到 `/account` 目录下，该如何配置，让 useradd 时，默认的家目录指向 `/account`？

  最简单的办法是编辑 `/etc/default/useradd`，将 `HOME=/home 改为 /account`

- 要让 dmtsai 使用者，加入 mrcode1、mrcode2、mrcode3 三个群组，且不影响 dmtsai 原本已经支持的次要群组时，需要怎么操作？

  ```bash
  # -a 增加，-G 次要群组，合用就是增加次要群组
  usermod -a -G mrcode1,mrcode2,mrcode3
  ```

## 参考数据与延伸阅读

- 最完整与详细的密码文件说明，可参考各个 distribution 内部的 man page，以 CentOS 7.x 的 `man 5 passwd 与 man 5 shadow` 是表示查看 passwd 的第 5 章节
- 加密机制的详细解释可查看维基百科：
  - MD5：http://zh.wikipedia.org/wiki/MD5
  - DES：http://en.wikipedia.org/wiki/Data_Encryption_Standard
  - SHA 家族：https://en.wikipedia.org/wiki/Secure_Hash_Algorithm  