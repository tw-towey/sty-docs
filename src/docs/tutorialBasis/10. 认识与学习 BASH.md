# 认识与学习 BASH

在 Linux 环境下，如果你不懂 bash 是什么，那么其他的东西就不用学习了，所以 bash 非常重要

bash 的东西非常多：变量的设置与使用、bash 操作环境的建立、数据流重导向功能、管线命令 等

本章几乎是所有指令模式（commadn line）与未来主机维护与管理的重要基础。

## 认识 BASH 这个 Sehll

在第一章讲到：管理整个计算机硬件的其实是操作系统的核心（kernel），一般使用者只能通过 shell 来与核心沟通。那么有系统有多少 shell 可用呢？以及为什么要使用 bash？本章告诉你答案

## 硬件、核心与 Shell

什么是 Shell？几乎上都听听到过，因为只要有操作通，那么就离不开 Shell 这个东西。在讨论 Shell之前，先来了解一下计算机的运作状况。举个例子：当你要计算机传输出来「音乐」的时候，你的计算机需要什么东西呢？

1. 硬件：有「声卡芯片」设备，才能发声
2. 核心管理：操作系统支持这个芯片组，以及提供芯片的驱动程序
3. 应用程序：需要使用者（就是你）输入发生声音的指令

这就是基本的一个输出声音所需要的步骤，可以用如下图示来说明：

![image-20191109225002702](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20191109225002702.png)

在第 0 章的操作系统章节曾提到过：操作系统其实是一组软件，控制整个硬件与管理系统的活动检测，如果这组软件能被用户随意的操作，若使用者应用不当，将会使得整个系统崩溃！所以不能随便被一些没有管理能力的终端用户随意使用

但是可以考虑使用程序来指挥核心，在第 0 章所提供的操作系统图示中，可以发现应用程序其实是在最外层，就如同鸡蛋的外壳一样，因此也就被称呼为壳程序（Shell）

其实壳程序的功能只是提供用户操作系统的一个接口，因此整个壳程序需要可以呼叫其他软件的功能，如前面提到过的很多指令，包括 man、chmod、chown、vi、fdisk、mkfs 等指令，这些指令都是独立的应用程序，但是可以通过壳程序（指令行模式）来操作这些应用程序

也就是说，只要能够操作应用程序的接口都能够成为壳程序。狭义的壳程序指的是指令方面的软件，包括本章要介绍的 bash 等。广义的壳程序包括图形界面软件。

## 为何要学习文字接口的 shell？

文字接口的 shell 不好学，但是学了之后好处多多，因此需要克服这个困难

## # 文件接口的 shell：大家都一样

为什么要学习 shell？x window 下的 ui 工具点一点就可以达到目的，比如 Webmin 是真的好用，他可以帮我很建议的设置我们的主机，甚至是一些很进阶的设置都可以帮我们搞定

但是这里还是需要再强调下：x window 与 web 接口的工具，它虽然功能强大，只是把所有利用到的软件整合到一起的一组程序而已，并非一个完整的套件，所以某些当你升级或则是使用其他套件管理模块（如 tarball 而非 npm 文件等）时，就会造成设置的困扰了。甚至不同的 distribution 所设计的 x window 接口也都不相同，这样也造成学习方面的困扰

而几乎各家 distribution 使用的 bash 都是一样的，如此一来几乎上能够轻轻松松的转换不同的 distribution

### 远程管理：文字接口就是比较快

Linux 的管理常常需要通过远程联机，而联机时文字接口的传输速度一定比较快，而且不容易出现断线或则是信息外流的问题，因此 shell 真的是得学习的一项工具，而且会让你更深入 Linux。

### Linux 的任督二脉：shell

所谓技多不压身，书到用时方恨少。此外，如果你真的有心要将你的主机管理好，那么良好的 shell 程序编写是一定需要的！

例如作者的经验来说，管理的主机不到十台，但是如果每台书籍都要花上几十分钟来查询他的登录文件信息以及相关的信息，可能会疯掉，太没有效率。但是通过 shell 提供的数据流重导向以及管线命令，分析登录信息只要花费不到十分钟就可以看完所有的主机的重要信息了

由于学习 shell 的好处真的多多，想要管理好系统的话，shell 就像是打通任督二脉一样，任何武功都能随你应用

## 系统的合法 shell 与 /etc/shells 工能

由于早年 Unix 年代，发展众多，所以 shell 依据发展者的不同就有许多版本，例如 Bourne SHell（sh）、在 Sun 里头预设的 CSHell、商业上常用的 K Shell、TCSH 等，每一种 Shell 都各有其特点。而 Linux 使用的这一种版本就称为「Bourne Again SHell（简称 bash），是 Bourne Shell 的增强版，也是基于 GNU 的架构下发展出来的

### shell 简单历史

第一个流行的 shell 是由 Steven Bourne 发展出来的，所以称为 Bourne shell（简称 sh）。后来另一个广泛流传的 shell 是由柏克莱大学的 Bill Joy 设计依附于 BSD 版的 Unix 系统中的 shell，该 shell 语法类似 c 语言，所以才得名为 C shell（简称 csh）。 Sun 主要是 BSD 的分支之一，而且 Sun 主机势力庞大，所以 csh 流传广泛

### 目前 Linux 可以使用的 shells

以 CentOS 7 为例，有多少我们可以使用的 shells 可以通过检查 /etc/shells 文件，至少有以下几个

- /bin/sh：已被 /bin/bash 所取代
- /bin/bash：Linux 预设的 shell
- /bin/tcsh：整合 C Shell 提供更多的功能
- /bin/csh：已被 /bin/tcsh 取代

虽然各家 shell 的功能都差不多，但是在某些语法下达方面则所有不同，因此建议需要选择一种 shell 来熟悉。Linux 预设就是使用的 bash，因此最初学会它就非常了不起了。

为什么系统上合法的 shell 要写入 /etc/shells 这个文件？因为系统某些服务在运行过程中，回去检查使用者能够使用的 shells

举例来说：某些 FTP 网站回去检查使用者的可用 shell，而如果你不想让这些用户使用 FTP 以外的主机资源时，可能会给予该使用者一些怪怪的 shell，让使用者无法以其他服务登录主机。这个时候，你就可以将那些怪怪的 shell 写到 /etc/shells 中。举例来说， CentOS 7 的 /etc/shells 里头就有个 /sbin/nologin 文件的存在，这个就是我们说的怪怪的 shell

我这个使用者上面时候可以取得 shell 来工作呢？还有预设会取得哪一个 shell 呢？在登录终端的时候，系统就会给一个 shell 进行工作，而这个登录取得的 shell 就记录在 /etc/passwd 文件内

```bash
[mrcode@study ~]$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
...
```

如上所示，每一行的最后一个数据，就是你登录后可以取得的预设 shell，系统账户 bin 与 daemon 等就是使用哪个怪怪的 /sbin/nologin ，关于使用者这部分的内容，在后续 第十三章的账户管理中讲解

## Bash shell 的功能

Linux 预设的 /bin/bash  是 GNU 计划中重要的工具软件之一，目前也是 Linux distribution 的标准 shell，主要兼容于 sh，并且依据一些使用者需求加强的 shell 版本。主要有点有如下几个

### 命令编修能力（history）

能记录使用过的指令，只要在指令列按「上下键」可以浏览历史记录，默认的指令记忆条数可达 1000 个。

指令记录在你的家目录内的 `.bash_history` ，该文件记录的是前一次登录以前所执行过的指令，而当前这一次的指令被暂存在内存中，当你成功注销系统后，指令记录才会存入该文件中

这种工作机制的优点：最大好处可以查询曾经做过的举动，如此可以知道你的执行步骤，那么就可以追踪你曾经下达过的指令，以作为除错的重要流程，但是如果被黑客入侵，只要翻阅你曾经执行过的指令，刚好你的指令又与系统有关（比如登录 mysql 的密码在指令列上），那么很容易数据库密码就被泄露了

那么该功能和历史记录数是好是坏？只能是仁者见仁智者见智了

### 命令与文件补全功能（tab 按键的好处）

在 bash 中常常使用 tab 补全功能，可以让你效率提升，并且减少输入时数据错误的几率，

- 命令补全：tab 接在一串指令的第一个字的后面
- 文件补全：tab 接在一串指令的第二个字以后时
- 若安装 bash-completion 软件，则在某些指令后面使用 tab 按键时，可以进行「选项/参数的补齐」功能

### 命令别名设置功能（alias）

假如我需要知道这个目录下的所有文件（包含隐藏文件）以及所有的文件属性，那么必须下达 `ls -al`这样的指令，可以通过 alias 来自定义命令取代上面的命令

```bash
alias lm='ls -al'
# 这里使用 lm 取代了 ls -al
```

### 工作控制、前景背景控制（job control、foreground、background）

这部分在 第十六章 Linux 过程控制中详细讲解。使用前、背景可以让工作进行得更为顺利，而工作控制（jobs）用途则更广，可以让我们随时将工作丢到背景中执行，而不怕不小心使用了 ctrl + c 来停掉该程序。此外，可以在单一登录的环境中，达到多任务的目的

### 程序化脚本（shell scripts）

在 DOS 年代将一堆指令写在一起的批处理文件，在 Linux 下的 shell scripts 则发挥更强大的功能，可以将你平时管理系统常需要下达的连续指令写成一个文件，该文件并且可以通过对谈交互式的方式来进行主机的侦测工作。也可以借由 shell 提供的环境变量及相关指令来进行设计，以前在 DOS 下需要程序语言才能写的东西，在 Linux 下使用简单的 shell scripts 就可以实现，这部分在 第十二章 讲解

### 通配符（wildcard）

举例来说：想要知道 /usr/bin 下有多少以 X 开头的文件，使用`ls -l /usr/bin/X*` 就可以知道，此外还有其他可用的通配符

## 查询指令是否为 Bash shell 的内置命令：type

可以通过 man bash 查看联机帮助文档，内容很多，让你看几天几夜也无法看完，不过该 bash 的 man page 中，还有其他文件的说明，比如 cd 指令也在该 man page 内。在输入 man cd 时，最上方也出现一堆的指令介绍，这是由于方便 shell 的操作内置了这些指令

可以通过 type 指令来观察某个指令是否是内置指令

```bash
type [-tpa] name

- 不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令
- t：type 会将 name 以下面这些字眼显示出他的意义
	file：表示为外部指令
	alias：为别名
	builtin：bash 内置指令
- p：如果后面接的 name 为外部指令时，才会显示完整文件名
- a：根据 PATH 变量定义的路径中，将含有 name 的指令都列出来，包含 alias
```

实践练习

```bash
# 查询 ls 这个指令是否为 bash 内置
# 未加任何参数，列出 ls 的最主要使用情况
[mrcode@study ~]$ type ls
ls is aliased to `ls --color=auto'
# 仅列出执行时的依据
[mrcode@study ~]$ type -t ls
alias
[mrcode@study ~]$ type -a ls
ls is aliased to `ls --color=auto'	# 最先使用 aliased
ls is /usr/bin/ls		# 还找到外部指令在 /bin/ls

# 查看 cd 的情况
[mrcode@study ~]$ type cd
cd is a shell builtin			# cd 是 shell 内置指令
```

## 指令的下达与快速编辑按钮

[前面讲过怎么下达指令](../04/)，这里仅以反斜杠来说明下指令下达方式

```bash
# 如果指令串太长的话，如何使用两行来输出
[mrcode@study ~]$ cp /var/spool/mail/root /etc/crontab \
> /etc/fstab /root
```

使用 `\` 来跳脱回车键，前面的 `>` 是跳脱模式下的标识符，还有组合按键帮助我们快速实现功能

|         组合键         | 功能与示范                                               |
| :--------------------: | -------------------------------------------------------- |
| `ctrl + u`、`ctrl + k` | 快速删除：分别是从光标处向前删除指令串，及向后删除指令串 |
| `ctrl + a、`ctrl + e`  | 快速移动：分别是让光标移动到整个指令串的最前面和最后面   |

总之，当我们顺利的在终端机 tty 上面登录后，Linux 就会依据 /etc/passwd 文件的设置给我一个 shell（预设是 bash），可以通过 man 来查询指令的使用方式，根据上面下达指令的方式来操作 shell


# Shell 的变量功能

变量是 bash 环境中非常重要的一个概念，

## 什么是变量

简单说，某一个特定字符串代表不固定的内容；比如：`y = ax+b` 等号左边的是变量，右边的是变量的内容，使用简单的变量来取代另一个比较复杂或则是容易变动的数据，这样做的好处就是方便！

### 变数的可变性与方便性

举例来说，我们每个账户的邮件信箱预设是以 MAIL 这个变量来进行存取的，当不同的账户登录取得的变量内容如下所示

```bash
dmtsai 的 MAIL = /var/spool/mail/dmtsai 
root 的 MAIL = /var/spool/mail/root
mrcode 的 MAIL = /var/spool/mail/mrcode
```

好处是则是邮件处理程序读取 MAIL 变量就能为对应的账户处理了

### 影响 bash 环境操作的变量

某些特定变量会影响到 bash 的环境，例如前面多次提到的 PATH 变量，它会影响指令是否能找到。

为了区别与自定义变量的不同，环境变量通常以大写字符来表示

### 脚本程序设计（shell script）的好帮手

写过程序的都知道，变量在程序中的重要性，比如在 shell script 中，前面几行定义变量，后面的大量逻辑处理使用变量，那么修改变量的内容，就能让后续的处理逻辑改变，达到非常方便的效果

## 变量的取用与设置：echo 、变量设置规则、unset

### 变量的取用：echo

```bash
echo $variable
echo $PATH
echo ${PATH}			# 作者推荐使用这种方式取用
```

关于 echo 的功能也较多，自行 man echo，这只是用来显示变量内容

```bash
# 在屏幕上显示你的环境变量 HOME 与 MAIL
[mrcode@study ~]$ echo $HOME
/home/mrcode
[mrcode@study ~]$ echo ${MAIL}
/var/spool/mail/mrcode
```

变量的修改使用等号赋值

```bash
[mrcode@study ~]$ echo ${myname}
											# 这里没有任何数据，该变量不存在或未设置
[mrcode@study ~]$ myname=mrcode
[mrcode@study ~]$ echo ${myname}
mrcode

# 在 bash 中，当一个变量名称未被设置时，预设内容就是 空
```

需要注意的是：每一种 shell 的语法都不相同，在 bash 中 echo 一个不存在的变量不会保存，并显示空，其他的可能就会报错了

### 变量的设置规则

- 变量与变量内容以一个「=」来连接

  ```bash
  myname=Mrcode
  ```

- 等号两边不能直接接空格符号

  ```bash
  myname = Mrcode		# java 语法格式强迫症不要这样写
  ```

- 变量名称只能是英文字母与数字

- 变量内容若有空格可以使用双引号或单引号限定，但是以下除外

  - 「$」在双引号中可以保留原本的特性

    ```bash
    var="lang is $LANG"
    则使用 echo $var 则得到输出信息为：lang is utf8 等的字样
    ```

  - 「‘」在单引号内的特殊字符仅为一般字符

    ```bash
    var='lang is $LANG'
    则输出信息为：lang is $LANG
    ```

- 可用跳脱字符「\」把特殊字符变成一般字符

  ```bash
  # 就是转义符
  myname=mrcode\ Tsai  # 这里将空格转义成普通字符了
  ```

- 在一串指令的执行中，还需要使用其他额外的指令所提供的信息时，可以使用反单引号「`指令`」或「$(指令)」

  ```bash
  # 取得核心版本的设置
  [mrcode@study ~]$ echo  $version
  
  [mrcode@study ~]$ version=$(uname -r); echo $version
  3.10.0-1062.el7.x86_64
  ```

- 若该变量为扩增变量内容时，则可使用如下方式累加变量

  ```bash
  PATH="$PATH:/home/bin"
  PATH=${PATH}:/home/bin
  ```

- 若该变量需要再其他子程序执行，则需要以 export 来使变量变成环境变量

  ```bash
  export PATH
  ```

- 通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断（纯粹按个人风格决定）

- 取消变量使用 unset

  ```bash
  # 如取消 myname 的设置
  unset myname
  ```

实践练习

```bash
# 练习 1：设置变量 name，内容为Mrcode
[mrcode@study ~]$ 12name=mrcode			# 变量命名语法问题
bash: 12name=mrcode: command not found...
[mrcode@study ~]$ name = Mrcode
bash: name: command not found...		# 变量命名语法问题
[mrcode@study ~]$ name=Mrcode			# 成功

# 练习 2：接上面，把内容修改为 Mrcode's name，就是内容中含有特殊字符
[mrcode@study ~]$ name=Mrcode's name
> c^C
# 单引号与双引号必须要成对出现，上面只有一个单引号，按下回车键时，还可以继续输入内容
# 不能达到题目要求，记得使用 ctrl + c 结束
[mrcode@study ~]$ name="Mrcode's name"
# 在双引号中，单引号变为一般字符
[mrcode@study ~]$ name=Mrcode\'s\ name
#使用转义符转义特殊字符

# 练习 3： 在 PATH 变量中累加 /home/dmtsai/bin 这个目录
PATH=$PATH:/home/dmtsai/bin
PATH="$PATH":/home/dmtsai/bin
PATH=${PATH}:/home/dmtsai/bin
# 上面三种格式都可以，但是下面的例子就不见得了

# 练习 4：将 name 的内容多出 yes
[mrcode@study ~]$ echo $name
Mrcode's name
[mrcode@study ~]$ name=$nameyes
[mrcode@study ~]$ echo $name

[mrcode@study ~]$ 
# 如没有双引号或则 {} 则完全变成了一个变量 nameyes
# 正确的如下
name="$name"yes
name=${name}yes

# 练习 5：如何让我刚刚设置的 name=Mrcode 可以用在下个 shell 程序？
[mrcode@study ~]$ name=Mrcode
[mrcode@study ~]$ bash				# 进入所谓的子程序
[mrcode@study ~]$ echo $name
		# 这里并没有获取到刚刚设置的值
[mrcode@study ~]$ exit			# 退出子程序
exit
[mrcode@study ~]$ echo $name
Mrcode
[mrcode@study ~]$ export name		# 导出变量
[mrcode@study ~]$ bash
[mrcode@study ~]$ echo $name		# 在子程序中找到了
Mrcode
[mrcode@study ~]$ exit
exit
```

什么是子程序？像上面那样，在当前这个 shell 下，去启用另一个新的 shell，新的哪个 shell 就是子程序了。在一般的状态下，父程序的自定义变量是无法在子程序内使用的。可以通过 export 将变量变成环境变量，就可以在子程序中使用了。

至于子程序相关概念，在第十六章程序管理中讲解。

```bash
# 练习 6：如何进入到你目前核心的模块目录？
cd /lib/modules/3.10.0-1062.el7.x86_64/kernel/
# 由于每个 linux 能够拥有多个核心版本，且几乎 distribution 的核心版本都不相同
# 所以上面的指令无法通用，这个时候可以使用其他额外指令语法来达成
cd /lib/modules/`uname -r`/kernel
cd /lib/modules/$(uname -r)/kernel
```

其实上面的指令可以说是做了两次动作：

1. 先进行反单引号内的动作「uname -r」，并得到核心版本 3.10.0-1062.el7.x86_64
2. 在上述结果带入原指令，得到 `cd /lib/modules/3.10.0-1062.el7.x86_64/kernel/`

::: tip
为啥推荐` ${}` 方式？方便识别 在复杂的变量引用中，没有分割符来分割非常的不方便识别
:::

```bash
# 练习 7：取消刚刚设置的 name 变量内容
[mrcode@study kernel]$ unset name
[mrcode@study kernel]$ echo $name

[mrcode@study kernel]$ 

# 练习 8：输出 locate crontab 所找到的相关文件的权限
# locate 可以查找文件，并同时查看他们的文件权限
[mrcode@study kernel]$ locate crontab
/etc/anacrontab
/etc/crontab
/usr/bin/crontab
/usr/share/doc/man-pages-overrides-7.7.3/crontabs
/usr/share/doc/man-pages-overrides-7.7.3/crontabs/COPYING
/usr/share/man/man1/crontab.1.gz
/usr/share/man/man1p/crontab.1p.gz
/usr/share/man/man4/crontabs.4.gz
/usr/share/man/man5/anacrontab.5.gz
/usr/share/man/man5/crontab.5.gz
/usr/share/vim/vim74/syntax/crontab.vim

[mrcode@study kernel]$ ls -ld `locate crontab`
-rw-------. 1 root root   541 Aug  9 07:07 /etc/anacrontab
-rw-r--r--. 2 root root   451 Jun 10  2014 /etc/crontab
-rwsr-xr-x. 1 root root 57656 Aug  9 07:07 /usr/bin/crontab
# 这个是个目录，上面使用 -d 参数的效果就是，不输出该目录下的明细，只输出目录信息
drwxr-xr-x. 2 root root    21 Oct  4 18:25 /usr/share/doc/man-pages-overrides-7.7.3/crontabs
-rw-r--r--. 1 root root 17738 Aug  9 08:47 /usr/share/doc/man-pages-overrides-7.7.3/crontabs/COPYING
-rw-r--r--. 1 root root  2626 Aug  9 07:07 /usr/share/man/man1/crontab.1.gz
-rw-r--r--. 1 root root  4229 Jun 10  2014 /usr/share/man/man1p/crontab.1p.gz
-rw-r--r--. 1 root root  1121 Jun 10  2014 /usr/share/man/man4/crontabs.4.gz
-rw-r--r--. 1 root root  1658 Aug  9 07:07 /usr/share/man/man5/anacrontab.5.gz
-rw-r--r--. 1 root root  4980 Aug  9 07:07 /usr/share/man/man5/crontab.5.gz
-rw-r--r--. 1 root root  2566 Aug  9 11:17 /usr/share/vim/vim74/syntax/crontab.vim

# 练习 9：如何简化一条命令
# cd /cluster/server/work/taiwan_2015/003 假设这条命令是经常用到的，但是特别长，如何简化？
work="/cluster/server/work/taiwan_2015/003"
cd work
# 使用变量方式，来达成效果
# 该变量可以记录在 bash 的配置文件 「~/.bashrc」中，那么以后可随时使用 cd $work 进入该目录
```

## 环境变量的功能

环境变量可以帮我打到很多功能，如：家的目录变换、提示字符的显示、执行文件搜寻的路径等，可以使用 env 与 export 来查询当前 shell 环境中有多少默认的环境变量

### 用 env 观察环境变量与常见环境变量说明

```bash
[mrcode@study kernel]$ env
XDG_SESSION_ID=5			
HOSTNAME=study.centos.mrcode		# 主机名
SELINUX_ROLE_REQUESTED=
TERM=xterm											# 终端机使用的环境是什么类型
SHELL=/bin/bash									# 目前这个环境下，使用的 Shell 是哪一个程序？
HISTSIZE=1000										# 历史指令记录数量
SSH_CLIENT=192.168.0.105 53699 22
SELINUX_USE_CURRENT_RANGE=
QTDIR=/usr/lib64/qt-3.3
OLDPWD=/home/mrcode							# 上一个工作目录所在
QTINC=/usr/lib64/qt-3.3/include
SSH_TTY=/dev/pts/0
QT_GRAPHICSSYSTEM_CHECKED=1
USER=mrcode											# 使用者名称
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;...		# 颜色显示
MAIL=/var/spool/mail/mrcode
PATH=/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin:/home/dmtsai/bin
PWD=/lib/modules/3.10.0-1062.el7.x86_64/kernel #该用户目前所在的工作目录,使用 pwd 取出
LANG=en_US.UTF-8								# 语系设置
KDEDIRS=/usr
SELINUX_LEVEL_REQUESTED=
HISTCONTROL=ignoredups
SHLVL=1
HOME=/home/mrcode								# 登录用户家的目录
LOGNAME=mrcode									# 登录者登录的账户名称
QTLIB=/usr/lib64/qt-3.3/lib
XDG_DATA_DIRS=/home/mrcode/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share
SSH_CONNECTION=192.168.0.105 53699 192.168.0.128 22
LESSOPEN=||/usr/bin/lesspipe.sh %s
XDG_RUNTIME_DIR=/run/user/1000
QT_PLUGIN_PATH=/usr/lib64/kde4/plugins:/usr/lib/kde4/plugins
_=/usr/bin/env								# 上一次使用的指令最后一个参数（或指令本身）

```

env 是 environment 环境 的简写，上面列出来所有的环境变量，使用 export 也是一样的内容，只不过 export 还有其他额外的功能，上面这些变量的作用如下

- HOME

  代表用户的家目录。使用 `cd 或 cd ~` 也能回到自己的家，这个就是取用的 HOME 变量

- SHELL

  目前这个环境使用的 SHELL 是哪个程序，Linux 预设使用 /bin/bash

- HISTSIZE：历史命令可记录的总数量

- MAIL：使用 mail 指令收信时，系统会读取的邮件信箱文件（mailbox）

- PATH

  执行文件搜索的路径，目录与目录中间以冒号「:」分割，由于文件搜索是按 PATH 变量内的目录查询的，所以目录的顺序也很重要

- LANG

  语系信息，很多程序都会用到。比如，启动某些 perl 的程序语言文件，会主动分析语系数据文件，如果发现有他无法解析的编码语系，可能会产生错误

- RANDOM

  随机树生成器的变量，目前大多数 distribution 都会有随机数生成器，就是 /dev/random 文件。可以通过该随机数文件相关的变量（$RANDOM）来获取随机数值。

  在 BASH 环境下，该变量范围为 0~32767 之前

  ```bash
  [mrcode@study kernel]$ echo $RANDOM
  9229
  # 想要 0 ~ 9 怎么办？
  # 使用 declare 指令来让字符串转成计算公式 6593*10/32768 然后就能得到数值了
  [mrcode@study kernel]$ declare -i number=$RANDOM*10/32768 ; echo $number
  6
  
  ```

### 用 set 观察所有变量（含环境变量与自定义变量）

bash 不只有环境变量，还有一些与操作接口有关的变量，以及用户自己定义的变量存在。

```bash
# 使用 set，除了环境变量之外，还会将其他咋 bash 内的变量都显示出来
# 下面只是其中一部分重要的，内容太多
[mrcode@study kernel]$ set
BASH=/bin/bash		# bash 的主程序放置路径
# bash 的版本
BASH_VERSINFO=([0]="4" [1]="2" [2]="46" [3]="2" [4]="release" [5]="x86_64-redhat-linux-gnu")
BASH_VERSION='4.2.46(2)-release'
COLUMNS=126				# 在目前终端机环境下，使用的字段有几个字符长度
HISTFILE=/home/mrcode/.bash_history # 历史命令记录文件
HISTFILESIZE=1000		# 上面那个文件能存储历史命令的数量
HISTFILE=1000			# 在目前环境中，内存中能记录的历史命令最大数量
IFS=$' \t\n'		# 预设的分隔符
LINES=20				# 目前的终端机下的最大行数
MACHTYPE=x86_64-redhat-linux-gnu	# 安装的机器类型
OSTYPE=linux-gnu		# 操作系统的类型
PS1=’[\u@\h \W]\$ ‘	# PS1 就厉害了，是命令提示字符，也就是我们常见的 [root@www ~]#、 [mrcode ~]$ 的设置，可以修改的
PS2=’> ‘		# 使用跳脱符号 \，在第二行开始显示的提示字符
$		# 目前这个 shell 使用的 PID
?		# 刚刚执行完指令的回传值
...
其他的请自行查阅

```

一般来说，无论是否为环境变量，只要跟我们这个 shell 的操作接口有关的变量，通常都会被设置为大写字符。也就是说，基本上，在 Linux 预设的情况中，使用`{大写的字母}`来设置的变量一般为系统内定需要的变量。上面的变量中有如下几个比较重要

#### PS1 提示字符的设置

命令提示字符，当我们每次按下 Enter 键去执行某个指令后，最后要再次出现提示字符时，就会主动去读取这个变数值了。相关设置可以通过 man bash 查询 PS1 的相关说明，下面列出一些符号含义：

- `\d`：可显示出「星期、月、日」的日期格式，如：「Mon Feb 2」
- `\H`：完整的主机名。如：本次练习机名称「study.centos.mrcode」.
- `\h`：仅取主机名第一个小数点之前的名字，如上面的则取「study」
- `\t`：显示时间，24 小时格式的 HH:MM:SS
- `\T`：显示时间，12 小时格式
- `\A`：显示时间，24 小时格式 HH:MM
- `\@`：显示时间，12 小时格式 am/pm 格式
- `\u`：目前使用者的账户名称，如 mrcode
- `\v`：BASH 的版本信息，如 4.2.46(1)-release 仅取「4.2」
- `\w`：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代
- `\W`：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名
- `\#`：下达的第几个指令
- `\$`：提示字符，如果是 root 时，则为 `#` ,否则就是 `$`

预设内容为 `[\u@\h \W]\$`，对照上表来看，`[mrcode@study ~]$ ` 这个为啥会显示成这样了

假设我们需要有类似如下的提示符号时，可以通过以下方式设置

```bash
# [mrcode@study /home/mrcode 16:50 #12]
[mrcode@study ~]$ cd /home/
[mrcode@study home]$  PS1='[\u@\h \w \A #\#]\$ '
[mrcode@study /home 02:26 #6]$ 
# 后面的 #6 信息，更新频率为 1 秒一次，输入一次命令算一次

```

#### `$` 关于本 shell 的 PID

该符号本身就是个变量，代表的是「目前这个 Shell 的线程代号」也就是 PID（Process ID）。更多概念后续讲解

```bash
[mrcode@study /home 02:29 #11]$ echo $$
28948
```

#### `?`关于上个执行指令的回传值

在 bash 中该变量非常重要，表示「**上一个**执行的指令所**回传**的值」，当我们执行某些指令时，这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令，则会回传一个 0 值，如果执行过程中发生错误，则会回传「错误代码」。简单说：非 0 则执行有错误

```bash
[mrcode@study /home 02:31 #13]$ echo $SHELL
/bin/bash				# 执行成功
[mrcode@study /home 02:31 #14]$ echo $?
0								# 显示 0
[mrcode@study /home 02:32 #15]$ 12name=mrcode
bash: 12name=mrcode: command not found...				# 执行失败
[mrcode@study /home 02:32 #16]$ echo $?
127							# 显示非 0
[mrcode@study /home 02:32 #17]$ echo $?
0								# 显示 0，? 只取代上一个命令的执行返回代码，不会累积，只能被使用一次

```

#### `OSTYPE、HOSTTYPE、MACHTYPE`主机硬件与核心的等级

在第 0 章中谈到过 CPU 等级，个人主机的 CPU 主要分为 32/64 位，其中 32 位又分为 i386、i586、i686 ，而 64 位则称为 x86_64。由于不同等级的 CPU 指令集不太相同，因此你的软件可能会针对某些 CPU 进行优化，以取得更佳的软件性能。所以软件就有 i386 、x86_64 之分了。

要留意的是，较高阶的硬件通常会向下兼容旧的软件，但较高阶的软件可能无法在旧机器上面安装

#### `export` 自定义变量转成环境变量

evn 与 set 表示环境变量与自定义变量，他们的差异在于「该变量是否会被子程序所继续引用」。

当你登录 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，这个程序的识别使用的是一个称为程序标识符（PID）。接下来你再这个 bash 下下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子程序了。

![image-20191115222142649](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20191115222142649.png)

如上，在原本的 bash 下执行另一个 bash，结果操作的环境接口会跑到第二个 bash 去（就是子程序），原本的 bash 就 sleep 了。整个指令运作的环境是实线的部分！若要回到原本的 bash 去，只有将第二个 bash 结束掉（exit 或 logout）才行。更多的程序概念后续讲解

因为**子程序仅会继承**父程序的**环境变量**，子程序**不会继承**父程序的**自定义变量**；这里就会出现在这种父子切换中可能一不小心就会出现找不到变量等的情况发生

可以使用 export 将自定义变量变成环境变量，那么子程序就会继承了。

```bash
export 变量名称
# 如果 export 后面不带任何值，则会显示所有的环境变量
```

## 影响显示结果的语系变量 locale

笔者在使用 man 命令等指令时，mrcode 和 root 账户一个显示英文，一个显示中文，使用 locale 查询如下

```bash
[mrcode@study /home 02:59 #20]$ locale
LANG=en_US.UTF-8
LC_CTYPE="en_US.UTF-8"
LC_NUMERIC="en_US.UTF-8"
LC_TIME="en_US.UTF-8"
LC_COLLATE="en_US.UTF-8"
LC_MONETARY="en_US.UTF-8"
LC_MESSAGES="en_US.UTF-8"
LC_PAPER="en_US.UTF-8"
LC_NAME="en_US.UTF-8"
LC_ADDRESS="en_US.UTF-8"
LC_TELEPHONE="en_US.UTF-8"
LC_MEASUREMENT="en_US.UTF-8"
LC_IDENTIFICATION="en_US.UTF-8"
LC_ALL=
[mrcode@study /home 02:59 #21]$ su -
Password: 
Last login: Tue Oct 29 20:45:07 CST 2019 on pts/0
[root@study ~]# man bash
[root@study ~]# locale
LANG=zh_CN.UTF-8							# 主语言环境
LC_CTYPE="zh_CN.UTF-8"				# 字符（文字）编码
LC_NUMERIC="zh_CN.UTF-8"			# 数字系统
LC_TIME="zh_CN.UTF-8"					# 时间系统
LC_COLLATE="zh_CN.UTF-8"			# 字符串的比较与排序
LC_MONETARY="zh_CN.UTF-8"			# 货币显示
LC_MESSAGES="zh_CN.UTF-8"			# 信息显示内容，如菜单、错误信息等
LC_PAPER="zh_CN.UTF-8"
LC_NAME="zh_CN.UTF-8"
LC_ADDRESS="zh_CN.UTF-8"
LC_TELEPHONE="zh_CN.UTF-8"
LC_MEASUREMENT="zh_CN.UTF-8"
LC_IDENTIFICATION="zh_CN.UTF-8"
LC_ALL=											# 整体语系
[root@study ~]# 
# locale -a 可以显示 linux 主机内有的语系文件，文件放置在 /usr/lib/locale 
```

发现一个账号是 en_US.UTF-8 一个是 zh_CN.UTF-8 ，以上可单独设置的变量有好多个，但是有 LANG 和 LC_ALL 是全局的，当其他都没有设置的时候，就会以这两个的语系为准

默认的语系配置文件在下面文件中

```bash
[root@study ~]# cat /etc/locale.conf 
LANG="zh_CN.UTF-8"

```

如果只是暂时在 tty 中显示指定的语系，而不是持久化的更改时，直接使用环境变量赋值方式

```bash
[mrcode@study /home 03:09 #22]$ LANG="zh_CN.UTF-8"
# 作者说在 Centos7 中可能需要使用如下的方式才可以
# 从 zh_TW.UTF-8 修改为 en_US.UTF8;
LANG=en_US.UTF8;
export LC_ALL=en_US.UTF8

```

## 变量的有效范围

在 export 指令中就提到了这个概念，如：父子变量不会被继承，需要使用 export 导出为环境变量。

某些书籍中会谈到全局变量（global variable）与局部变量（local variable），在本章：

- 环境变量 = 全局变量
- 自定义变量=局部变量

为啥环境变量的数据可以被子程序所引用呢？是因为内存配置的关系，理论上是这样的：

- 当启动一个 shell，操作系统会分配一块内存给 shell 使用，此内存变量可让子程序取用
- 若在父程序中利用 export 功能，可以让自定义变量的内容写到上述的区块中（环境变量）
- 当加载另一个 shell 时，子 shell 可以将父 shell 的环境变量所在的区块导入自己的环境变量区块中

但是需要注意的是：这里的环境变量与「bash 的操作环境」不太一样，如 PS1 并不是环境变量，可以看成是对 bash 程序的配置

## 变量键盘读取、数组与宣告：read、array、declare

上述的变量都是由指令直接设置的，可以让用户使用键盘输入，如某些程序执行过程中，会等待使用者输入 yes/no 之类的信息。

### read

交互式指令，阻塞等待用户输入信息。该指令在 shell script 中经常用到。关于 script 在 第十三章介绍

```bash
read [-pt] variable

选项与参数

-p：后面可以接提示符
-t：后面可以接等待的秒数

```

实践练习

```bash
# 范例 1：让用户由键盘输入一个内容，将该内容变成名为 atest 的变量
[mrcode@study ~]$ read atest
this is a test				# 光标闪烁，等待你的输入
[mrcode@study ~]$ echo ${atest}		# 这里打印刚刚用户输入的信息
this is a test

# 范例 2：提示使用者 30 秒内输入自己的大名，将该输入字符串作为名为 named 的变量内容
[mrcode@study ~]$ read -p "Please keyin your name: " -t 30 named
Please keyin your name: mrcode		# -p 的提示信息
[mrcode@study ~]$ echo ${named}
mrcode

# -t 30 ，如果 30 秒之后没有输入，则自动略过
```

### declare 、 typeset

declare 或 typeset 都是声明变量的类型。如果使用 declare 后面并没有接任何参数，那么 bash 会主动将所有变量名称与内容显示出来，就好像使用 set 一样。语法如下

```bash
declare [-aixr] variable

选项与参数

-a：将后面的 variable 的变量定义为数组 array 类型
-i：定义为整数数字 integer 类型
-x：用法与 export 一样，将后面的 variable 变成环境变量
+x：将环境变量变成普通的自定义变量
-r：将变量设置为 readonly 类型，该变量不可被更改内容，也不能 unset
-p：显示变量的定义和类型
```

实践与练习

```bash
# 范例 1 ：让变量 sum 进行 100 + 300 + 50 的加总结果
[mrcode@study ~]$ sum=100+300+50
[mrcode@study ~]$ echo ${sum}
100+300+50			# 发现没有生效，变成了字符串
# 使用 declare 声明后，成功
[mrcode@study ~]$ declare -i sum=100+300+50
[mrcode@study ~]$ echo ${sum}
450
```

在默认的情况下， bash 对于变量有几个基本的定义：

- 变量类型默认为字符串
- bash 环境中的数值运算，预设最多仅能达到整数形态，所以 1/3 结果是 0

```bash
# 范例 2：将 sum 变成环境变量
[mrcode@study ~]$ declare -x sum
[mrcode@study ~]$ export | grep sum    # 这里是在 export 指令的信息下搜索 sum
declare -ix sum="450"			# 看到使用了 declare -ix 来声明

# 范例 3：将 sum 变成只读属性，不可更动
[mrcode@study ~]$ declare -r sum
[mrcode@study ~]$ sum=123
-bash: sum: readonly variable

# 范例 4：将 sum 变成非环境变量的自定义变量
[mrcode@study ~]$ declare +x sum			# 将 - 变成 + 就是去掉环境变量
[mrcode@study ~]$ declare -p sum			# -p 显示某个变量的定义和类型
declare -ir sum="450"

```

declare 功能很有用，在 shell script 中经常使用。如果不小心将变量设置为「只读」，通常需要注销再登录才能复原该变量的类型

###  array

废话不多说，笔者是个程序员，就不记录那么低级的概念

```bash
# 语法
var[index]=countent
```

实践与练习

```bash
# 范例：设置 var[1] ~ var[3] 的变量
[mrcode@study ~]$ var[1]="small min"
[mrcode@study ~]$ var[2]="big min"
[mrcode@study ~]$ var[3]="nice min"
[mrcode@study ~]$ echo "${var[1]},${var[2]},${var[3]}"
small min,big min,nice min

```

## 与文件系统及程序的限制关系：ulimit

想象一个状况：Linux 主机同时登陆了 10 个人，同时开启了 100 个文件，每个文件约 10MBytes，那么需要的内存则是 `10*100*10=100000MBytes=10GBytes`，耗费太多内存，系统很容易崩溃；为了预防这种情况，bash 可以「限制用户的某些系统资源」，包括可以开启的文件数量、CPU 可以使用的时间、可用内存总量等。

```bash
ulimit [-SHacdfltu] [配额]
```
选项与参数：

- H：hard limit，严格的设定，必定不能超过这个设定的数值

- S：soft limit，警告的设定，可以超过该设定值，超过则出现警告信息

  在设置上，通常 soft 会比 hard 小。比如：soft=80，hard=100，那么你可以使用到 90（因为没有超过 100）， 但是介于 80 ~ 100 之间，系统会有警告信息通知你

- a：后面不接任何选项与参数，可列出所有的限制额度

- c：限制每个核心文件的最大容量

  当某些程序发生错误时，系统可能会将该程序再内存中的信息写成文件（排除用），这种文件被称为核心文件（core file）。
  
- f：此 shell 可以建立的最大文件容量（一般可能设置为 2GB）单位为 Kbytes

- d：程序可使用最大断裂内存（segment）容量

- l：可用于锁定（lock）的内存量

- t：可使用最大 CPU 时（单位为妙）

- u：单一用户可以使用的最大程序（process）数量

实践与练习

```bash
# 范例 1：列出你目前身份（假设为一般账户）的所有限制数据值

[mrcode@study ~]$ ulimit -a
core file size          (blocks, -c) 0				# 只要为 0 则表示没有限制
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited		# 可建立的单一文件的大小
pending signals                 (-i) 4519
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024					# 同时可开启的文件数量
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 4096
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited

# 范例 2：限制用户仅能建立 10MBytes 以下的容量文件
[mrcode@study ~]$ ulimit -f  10240
[mrcode@study ~]$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) 10240		# 已经修改为 10 MBytes
# 尝试创建大于 10MBytes 的文件，报错
[mrcode@study ~]$ dd if=/dev/zero of=123 bs=1M count=11
File size limit exceeded (core dumped)
# 记得删除 123 这个文件，同时需要注销再次登录才能让 10M 的限制消失
# 这里为什么需要删除？错误是报了，但是文件是生成了的，只是文件大小只有限制的 10M 大小
```

在第七章 Linux 磁盘文件系统中提到过，单一 filesystem 能够支持单一文件大小与 block 的大小有关系。但是文件系统的限制容量都允许太大了，可以使用 ulimit -f 来限制使用者建立的文件不要太大。

::: tip
此外，ulimit 除了重新登录账户外，还可以重新设置 ulimit，但是普通用户只能降低，而不能增加文件容量，

若想要管控使用者的 ulimit 限值，可以参考第十三章的 pam 介绍
:::

## 变量内容的删除、取代与替换（Optional）

除了可以设置修改原本的内容外，还可以对变量进行微调，如删除、取代、替换

### 变量内容的删除

下面的范例以此进行，比较能理解到这里想表达的意思

```bash
# 范例 1：让小写的 path 自定义变量设置与 PATH 内容相同
[mrcode@study ~]$ path=${PATH}
[mrcode@study ~]$ echo ${path}
/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin

# 范例 2：假设不喜欢 local/bin，所以将前一个目录删除掉(/usr/local/bin:)
# 这里的语法其实就是：将 符合 /*local/bin:(含) 之前的目录都删掉
[mrcode@study ~]$ echo ${path#/*local/bin:}
/usr/bin:/usr/local/sbin:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin
```

上面的语法示意解析如下

```bash
${变量#/*local/bin;}   

- ${} ：这种华括弧必须在，这种删除模式只有括弧起来才能识别
- 变量：原本的变量名称
- # ：代表从变量内容的最前面开始向右删除，且仅删除最短的那个
- /*local/bin：代表要删除的部分，由于 # 代表由前面开始删除，所以这里便由开始的 / 写起
	需要注意的是：还可以通过通配符 * 来取代 0 到无穷多个任意字符
```

```bash
# 范例 3：想要删除前面所有的目录，仅保留最后一个目录
[mrcode@study ~]$ echo ${path#/*:}
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin
# # 表示删除前面最短的那一个，这里通配符了前面的一个路径，也就是那个 /usr/lib64/qt-3.3/bin: 被删除了

[mrcode@study ~]$ echo ${path##/*:}
/home/mrcode/bin
# 多增加了一个 # 字符，则只剩下最后一个路径了
```

在 PATH 变量中的内容都是以冒号「:」隔开的，所以要从头删除掉目录就是介于「/」到「:」之间，但是 PATH 中不止一个冒号，所以需要以 # 与 ## 分表表示

- `#`：符合取代文字的「最短的」那一个
- `##`：符合取代文字的「最长的」那一个

`#` 是由后面往前删除内容，`%`则是由前往后删除内容

```bash
# 范例 4：假设你的 MAIL 变量是 /var/spool/mail/mrcode，只想要 mrcode 这个字符串，也就是前面的目录都不要了
[mrcode@study ~]$ echo ${MAIL}
/var/spool/mail/mrcode
[mrcode@study ~]$ echo ${MAIL##/*/}
mrcode

# 要删除目录，只要前面的
[mrcode@study ~]$ echo ${MAIL%/*}
/var/spool/mail

# 下面再来看看这两个到底是什么意思，前面的演示，笔者自己觉得没有明白是什么意思
# # 是从头开始匹配，下面演示是什么意思
[mrcode@study ~]$ echo ${MAIL};echo ${MAIL#/*}
/var/spool/mail/mrcode
var/spool/mail/mrcode			# 匹配到的是 /,并且只匹配最短的那一个，那么最短的就是最前面的 /
[mrcode@study ~]$ echo ${MAIL};echo ${MAIL##/*}
/var/spool/mail/mrcode	 
												# 被完全删掉了，/* 最常的就是整个字符串
[mrcode@study ~]$ echo ${MAIL};echo ${MAIL##/*/}
/var/spool/mail/mrcode
mrcode									# 匹配到的是 /var/spool/mail/ 因为是匹配最常的结果，mrcode 后面没有没有 / 所以不会被匹配
[mrcode@study ~]$ echo ${MAIL};echo ${MAIL##/*spool/}
/var/spool/mail/mrcode
mail/mrcode			# 匹配到的是 /var/spool/ ,按最常的匹配，这里唯一能匹配上的就是整个了

# 那么相反的是：% 是从尾部开始匹配
[mrcode@study ~]$ echo ${MAIL};echo ${MAIL%/*}
/var/spool/mail/mrcode
/var/spool/mail			# 「%/*」匹配到的是 /mrcode ，并且是最短的这一个
[mrcode@study ~]$ echo ${MAIL};echo ${MAIL%%/*}
/var/spool/mail/mrcode
										# 匹配了整个路径
[mrcode@study ~]$ echo ${MAIL};echo ${MAIL%%/*/}
/var/spool/mail/mrcode
/var/spool/mail/mrcode			# 注意看这里，`%%/*/` /*/ 没有匹配上，是因为从 mrcode 开始匹配，然而 mrcode 后面没有 / 所以从开始就匹配不上了，所以没有删除成功
[mrcode@study ~]$ echo ${MAIL};echo ${MAIL%%/spool*}
/var/spool/mail/mrcode
/var				# 「%%/spool*」 * 代表了 /mail/mrcode 这一串，所以能匹配上

```

- `#`：从字符串头部往后匹配，匹配上则删除这一串，按最短匹配原则
- `##`：同上，按最长匹配原则
- `%`：从字符串尾部往前匹配，匹配上则删除这一串，按最短匹配原则
- `%%`：同上，按最常匹配原则

### 变量内容的替换

```bash
# 范例 1：将 path 的变量内容内的 sbin 替换成大写的 SBIN
[mrcode@study ~]$ echo ${path}; echo ${path/sbin/SBIN}
/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin
/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/SBIN:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin
[mrcode@study ~]$ echo ${path}; echo ${path/"local/sbin"/SBIN}
/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin
/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/SBIN:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin
# 看下上面的替换前和替换后的对比，这个就很好理解了

# 如果是两条斜线，则替换所有的
[mrcode@study ~]$ echo ${path}; echo ${path//sbin/SBIN}
/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin
/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/SBIN:/usr/SBIN:/home/mrcode/.local/bin:/home/mrcode/bin

```

- `\`：替换首次出现的字符串为指定字符串; `${path\关键字\替换成目标字符串}`
- `\\`：替换所有匹配的字符串为指定字符串

### 变量的测试与内容替换

```bash
# 范例 1： 测试 username 变量，若不存在则给定默认内容为 root
[mrcode@study ~]$ echo ${username}
						# 可以看到没有内容输出
[mrcode@study ~]$ username=${username-root};			# 使用短横线设置默认值
[mrcode@study ~]$ echo ${username}
root
[mrcode@study ~]$ echo ${username-root2}
root					# 可以看到，当有值的时候，给定的默认值不会生效

# 范例 2：当内容为空串时，会出现什么？
[mrcode@study ~]$ username=""
[mrcode@study ~]$ username=${username-root}
[mrcode@study ~]$ echo ${username}
								# 可以看到，当内容为空串时，变量其实已经定义了，只是内存为空串
[mrcode@study ~]$ username=${username:-root}
[mrcode@study ~]$ echo ${username}
root						# 这里使用 : 来识别空串
```

除了以上的是否为空判定之外，还有其他的功能，总结如下

| 变量设置方式       | str 不存在         | str 为空字符串     | str 已存在且不为空字符串 |
| ------------------ | ------------------ | ------------------ | ------------------------ |
| `var=${str-expr}`  | var=expr           | var=               | var=$str                 |
| `var=${str:-expr}` | var=expr           | var=expr           | var=$str                 |
| `var=${str+expr}`  | var=               | var=expr           | var=expr                 |
| `var=${str:+expr}` | var=               | var=               | var=expr                 |
| `var=${str=expr}`  | str=expr; var=expr | str 不变；var=     | str 不变；var=$str       |
| `var=${str:=expr}` | str=expr; var=expr | str=expr; var=expr | str 不变；var=$str       |
| `var=${str?expr}`  | expr 输出至 stderr | var=               | var=$str                 |
| `var=${str:?expr}` | expr 输出至 stderr | expr 输出至 stderr | var=$str                 |

总结：`:` 冒号都是把空字符串识别为不存在，其他的按功能如下：

- `-`：不存在则给默认值，存在则使用原始值
- `+`：存在则给默认值，不存在不给值
- `=`：不存在则**改变变量值**，会影响原始变量的值；存在则使用原始值
- `?`：不存在则**报错**，存在则使用原始值

实践练习：

```bash
# 测试：- ，str 不存在
[mrcode@study ~]$ unset str; var=${str-newvar};
[mrcode@study ~]$ echo "var=${var}, str=${str}"
var=newvar, str=				# 因为 str 不存在，所以 var 被赋值了

# 测试：- ，str 存在
[mrcode@study ~]$ str="oldvar"; var=${str-newvar}; 
[mrcode@study ~]$ echo "var=${var}, str=${str}"
var=oldvar, str=oldvar	# 因为 str 存在，所以不赋值

# 测试：= 
[mrcode@study ~]$ unset str; var=${str?newvar};
-bash: str: newvar				# 不存在，直接报错
[mrcode@study ~]$ str="oldstr"; var=${str?newvar};
[mrcode@study ~]$ echo "var=${var}, str=${str}"
var=oldstr, str=oldstr		# 存在则使用存在的值，所以这个变量没有用
```

这里其实还是稍微有点难以理解，没有 if else 这样看的明白，追求极致代码简洁的情况下可以使用这种方式。

# 命令别名与历史命令

## 命令别名设置：alias、unalias

命令别名就是你可以把一长串指令指定一个简短的名称，在键入指令的时候使用简短的名称来达到调用一长串指令的目的。例如：`ls -al|more` 查看隐藏文档并且翻页查看，觉得这串指令太长了，可以通过下面的指令来设置别名

```bash
[mrcode@study ~]$ alias lm='ls -al | more'
[mrcode@study ~]$ lm
total 68
drwx------. 18 mrcode mrcode  4096 Nov 11 10:20 .
drwxr-xr-x.  4 root   root      42 Oct  8 23:01 ..
-rw-------.  1 mrcode mrcode 10279 Nov 11 14:12 .bash_history
-rw-r--r--.  1 mrcode mrcode    18 Aug  8 20:06 .bash_logout
-rw-r--r--.  1 mrcode mrcode   193 Aug  8 20:06 .bash_profile
```

别名的定义规则与[变量定义规则](./02.md#变量的设置规则)几乎相同，另外可以取代已经存在的变量名

```bash
alias rm='rm -i'
```

root 可以移除（rm）任何数据，所以当使用 rm 的时候需要小心，可以使用上面的别名指令覆盖掉原始的 rm 指令，执行的时候就是执行 rm -i 指令了

```bash
[mrcode@study ~]$ alias
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias lm='ls -al | more'
alias ls='ls --color=auto'
alias rm='rm -i'
alias vi='vim'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
```

在 root 用户下是没有 `vi='vim'` 的，一般用户会默认添加该别名

想取消别名可以使用 unalias 指令

```bash
unalias lm
```

例题：DOS 年代，列出目录与文件用 dir，清除屏幕用 cls，在 linux 如何达到这个效果？

```bash
[mrcode@study ~]$ alias cls='clear'
[mrcode@study ~]$ alias dir='ls -l'
```

## 历史命令：history

前面提过 bash 有提供指令历史的服务，可以使用 history 来查询曾经下达过的指令

```bash
history [n]
history [-c]
history [-raw] histfiles
```

选项与参数：

- n：数字，列出最近 n 条命令
- c：将目前的 shell 中的所有 history 内容全部消除
- a：将目前新增的 history 指令新增如 histfiles 中，若没有加 histfiles 则预设写入 `~/.bash_history`
- r：将 histfiles 的内容读到目前这个 shell 的 history 记忆中
- w：将目前的 history 记忆内容写入 histfiles 中

实践与练习

```bash
# 范例 1：列出目前内存内的所有 history 记忆
[mrcode@study ~]$ history
    1  cd /root/
    2  sudo
    3  sudo cd /root/
    .... 中间省略
  666  alias 
  667  alias cls='clear'
  668  alias dir='ls -l'
  669  dir
  670  history

# 范例 2：列出们目前最近的 3 条指令
[mrcode@study ~]$ history 3
  669  dir
  670  history
  671  history 3

# 范例 3：like将目前的资料写入 histfile 中
[mrcode@study ~]$ history -w
# 默认情况会将记录记录写入 ~/.bash_history 中
[mrcode@study ~]$ echo ${HISTSIZE}
1000		# 这里不是现实文件中有多少条，而是最大可存储多少条

```

正常情况下历史命令的读取记录是这样的：

- 当以 bash 登录 Linux 主机后，系统会主动的由家目录的 `~/.bash_history` 读取
- 假设这次登录后，共下达过 100 次命令，等你注销时，系统就会将 101~1100 总共 1000 条记录**更新**到 `~/.bash_history` 中，因为和能存储最大条数 HISTSIZE 有关系，前面的序号会增加，但是总存储条数只有 HISTSIZE 条
- 也可以使用 history -w 强制写入

history 指令不只是提供了查询历史记录而已，还可以利用相关命令来执行指令，如下

```bash
# 执行第几条命令，这里 number 是数值序号
[mrcode@study ~]$ !number
# 由最近的指令向前搜索指令开头为 command 的哪个指令，并执行
[mrcode@study ~]$ !command
# 执行上一个指令（相当于按 ↑ 后，再按 Enter）
[mrcode@study ~]$ !!

# 使用范例
[mrcode@study ~]$ history 4
  681  man rm
  682  alias
  683  man history
  684  history 4
[mrcode@study ~]$  !681		  # 执行第 681 条指令
 man rm			# 这里会显示具体执行的指令是什么
[mrcode@study ~]$ !!				# 执行上一个指令
 man rm
[mrcode@study ~]$ !al				# 从最新的历史指令开始搜索 al 开头的指令并执行他
alias

```

虽然好用，但是需要小心安全问题，尤其是 root 的历史记录，这是黑客的最爱。另外使用 history 配合 `!` 曾经使用过的指令下达是很有效率的一个指令下达方式

### 同一账户同时多次登录的 history 写入问题

常常会同时开几个 bash 窗口，这些 bash 的身份都是 root。这样会有 `~/.bash_history`的写入问题吗？

自动写入的条件是注销 bash 时，自动写入，那么最后一个被注销的 bash 窗口中的历史记录会存下来，如果记录大于了 1000 的话，后注销的会覆盖前面先注销的（会有同时注销的情况导致错乱的吗？书上没有说）

由于多重登录有这样的问题，很多朋友都习惯单一 bash 登录，再用后续要讲解的 「工作控制 job control 来切换不同的工作」，这样才能将所有曾经下达过的指令记录下来，也方便未来系统管理员进行指令的 debug

### 无法记录时间

history 有一个问题就是无法记录指令下达时间。按序号记录的，但是没有记录时间。如果有兴趣，其实可以通过 `~/.bash_logout` 来进行 history 的记录，并加上 date 来增加时间参数（后续的情景模拟题中会讲到怎么做）

::: tip

有一种情况就是，想不要别人翻阅你的历史记录的话，可以使用 history -c;history -w 强迫清除并立即写入文件来清空历史记录
:::


# Bash Shell 的操作环境

在我们登陆主机的时候，屏幕上会有一些说明文字，告知我们的 Linux 版本之类的信息，还可以显示一些欢迎等信息。此外，我们习惯的环境变量、命令别名等，是否可以在登录后就主动帮我设置好？

这些设置又分为系统全局配置和个人账户级配置，仅是文件放置位置不同

## 路径与指令搜寻顺序

前面讲到过使用 alias 可以建立别名，比如创建了一个 ls 的别名，其实 ls 有少的指令，那么到底是哪一个会被选中执行呢？基本上，指令运行顺序可以这样看：

1. 以相对、绝对路径执行命令，例如 `/bin/ls` 或 `./ls`
2. 由 alias 找到该指令来执行
3. 由 bash 内置的指令来执行
4. 通过 $PATH 这个变量的顺序搜索到第一个指令执行

举例来说：

- `/bin/ls`：该指令运行后，没有颜色
- `ls`：该指令运行后输出的内容有颜色，因为是使用别名 `alias ls=‘ls --color=auto’`

也可以使用 type -a ls 来查询指令搜寻的顺序

```bash
# 范例：设置 echo 的命令别名为 echo -n，然后观察 echo 执行的顺序
[mrcode@study ~]$ alias echo='echo -n'
[mrcode@study ~]$ type -a echo
echo is aliased to `echo -n'
echo is a shell builtin
echo is /usr/bin/echo
```

可以看到上面的顺序与本节总结的执行顺序一致

## bash 的进站与欢迎信息：/etc/issue、/etc/motd

### 进站信息 /etc/issue

在 tty1~tty6 登录时，会有几行提示字符，这个就是进站画面，该字符串在 /etc/issue 中配置的

```bash
[mrcode@study ~]$ cat /etc/issue
\S
Kernel \r on an \m

```

如上的变量引用使用的是反斜杠，变量可以通过 man issue 中查看到 agetty ，再 man agetty 得到如下的信息，代码变量信息如下

- `\d`：本地端时间的日期
- `\l`：显示第几个终端机接口
- `\m`：显示硬件的等级（i386、i486、i586...）
- `\n`：显示主机的网络名称
- `\O`：显示 domain name
- `\r`：操作系统的版本（相当于 uname -r）
- `\t`：显示本地端时间的时间
- `\S`：操作系统的名称
- `\v`：操作系统的版本

```bash
# 练习：如果想在 tty3 的进站画面看到如下显示，该如何设置才能达到效果？

CentOS Linux 7 (Core)(terminal：tty3)
Date:2019-12-01 18:00:00
Kernel 3.10.0-229.e17.x86_64 on an x86_64
Welcome!

使用 root 身份参考上面的变量说明修改 /etc/issue 文件达成效果

vim /etc/issue

\S (terminal: \l)
Date: \d \t
Kernel \r on an \m
Welcome!

```

[怎么登录 tty 和切换 tty 请参考之前的章节](./04/#gnome-的操作与注销)，记得，进站画面是切换到 tty 时顶部显示的信息，而不是登录后显示的信息。

该文件中的规则就是使用反斜杠引用上面的变量，其他的你可以随意操作，比如写个字符画等，搞得个性一点

当使用 telnet 登录主机时，是不会显示 `/etc/issue` 中的配置，而是显示 `/etc/issue.net` 中的配置

### 欢迎信息 /etc/motd

想要使用者登录后，取得一些信息，例如使用注意事项信息，就可以修改 /etc/motd 文件

```bash
[root@study ~]# vi /etc/motd 
Hello everyone,
这是欢迎信息中文测试

# 重新登录后会看到如下的信息
Last login: Sun Dec  1 17:37:58 2019 from 192.168.0.105
Hello everyone,
这是欢迎信息中文测试
[mrcode@study ~]$ 

```

## bash 的环境配置文件

我们一进入 bash 就取得了一堆有用的变量，这是因为系统有一些环境配置文件的存在，让 bash 在启动时直接读取这些配置文件，以规划好 bash 的操作环境。而这些配置文件分为全局系统配置和用户个人偏好配置

### login 与 non-login shell

在介绍 bash 的配置文件前，一定要先知道 login shell 与 non-login shell ，重点就在于有没有登录（login）

- login shell：取得 bash 时需要完整的登录流程，就称为 login shell

  举例来说，你要由 tty1~tty6 登录，需要输入用户的账户与密码，此时取得的 bash 就称为「login shell」

- non-login shell：取得 bash 接口的方法不需要重复登录的举动

  比如：你以 x window 登录 linux 后，再以 X 的图形化接口启动终端机，此时该终端机并没有再次输入账户与密码，那么该 bash 的环境就称为 non-login shell

  再比如：你再原本的 bash 环境下再次下达 bash 这个指令，同样也没有输入账户密码，那第二个 bash（子程序）也是 non-login shell

上面两种情况取得的 bash 配置文件不一致。由于我们需要登录系统，所以先谈谈 login shell 会读取哪些配置文件？一般来说，login shell 其实只会读取这两个配置文件

1. /etc/profile：系统整体配置，最好不要修改这个文件
2. `~/.bash_profile` 或 `~/.bash_login` 或 `~/.profile`：属于使用者个人设置

### /etc/profile （login shell 才会读）

该文件相对于现在我们来看，可能还不太能看得懂，里面是利用使用者的标识符（UID）来决定很多重要的变量数据，这也是 **每个使用者登录取得 bash 时一定会读取的配置文件** ，也就是系统级全局配置，主要变量如下：

- PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录
- MAIL：依据账户设置好使用者的 mailbox 到 /var/spool/mail/账号名
- USER：根据用户的账户设置该变量类容
- HOSTANME：依据主机的 hostname 指令决定此变量内容
- HISTSIZE：历史命令记录数量。CentOS 7.x 设置为 1000
- umask：包括 root 默认为 022 而一般用户为 002 等

/etc/profile 可不止会做这些事情，还会呼叫外部的设置数据，在 CentOS 7.x 默认情况下，下面的数据会依序被呼叫进来：

#### /etc/profile.d/*.sh

通配符方式，加载该目录内所有的 sh 文件，另外，使用者需要具有 r 的权限，那么该文件就会被 /etc/profile 调用。

在 CentOS 7.x 中，该目录下的文件规范了 bash 操作窗口的颜色、语系、ll 与 ls 指令的命令别名、vi 的命令别名、which 的命令别名等。如果你需要帮所有使用者设置一些共享的命令别名时，可以在该目录下自行建立后缀为 .sh 的文件，并将所需要的数据加入即可

#### /etc/local.conf

该文件是由 `/etc/profile.d/lang.sh` 呼叫进来的，这也是我们决定 bash 预设使用何种语系的重要配置文件！文件里最重要的就是 LANG、LC_ALL 这些变量的设置，前面讨论过

#### /usr/share/bash-completion/completions/*

tab 键补全，除了命令补齐、文档名补齐外，还可以进行指令的选项、参数补齐功能。就是从这个目录里面找到对应的指令来处理的。

该目录下的内容是由 /etc/profile.d/bash_completion.sh 文件载入的

### `~/.bash_profile` （login shell 才会读）

bash 在读完了整体环境设置的 /etc/profile ，并借此加载其他配置文件后，接下来则是会读取使用者的个人配置文件。在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有 3 个，依序分别是：

1. `~/.bash_profile`
2. `~/bash_login`
3. `~/,profile`

其实 bash 的 login shell 设置只会读取上面三个文件中的一个，而读取的顺序则是依照上面的顺序。

什么意思呢？是当第一个文件不存在时，读取第二个，那么当第一个文件存在时，后面的都不读取了

为什么会有这么多的文件？是因为其他 shell 转换过来的使用者习惯不同，而做的兼容。

```bash
# 看看 mrcode 的 .bash_profile 的内容
# 具体路径为 /home/mrcode/.bash_profile 
[mrcode@study ~]$ cat ~/.bash_profile 
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then			# 判断并读取 ~/.bashrc
        . ~/.bashrc
fi

# User specific environment and startup programs
# 下面再处理个人化设置
PATH=$PATH:$HOME/.local/bin:$HOME/bin	

export PATH

```

该文件设置了 PATH，并使用 export 将 PATh 变成环境变量，看配置是通过累加方式将用户家目录下的 ~/bin/ 目录添加进 PATH 了，这就意味着，你可以将可执行文件放到 ~/bin/ 下，执行时，就不需要写全路径了

上面的文件内容中有一段 if...then... 代码，该代码后续再 shell sript 中讲解，这里判断 ~/.bashrc 文件是否存在，存在则加载。

bash 配置文件的读入方式是通过 source 指令来读取的。这个后续讲解，最后来看看整个 login shell 的读取流程

![image-20191201181925883](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20191201181925883.png)

实线的方向是主线流程，虚线的方向则是被加载的配置文件。从上图来看，CentOS 的 login shell 环境下，最终被读取的配置文件是 `~/.bashrc` 文件，所以可以将自己的偏好设置写入该文件即可。

下面还要讨论 source 与 `~/.bashrc`

### source : 读取环境配置文件的指令

由于 `/etc/profile` 与 `~/.bash_profile` 都是在取得 login shell 的时候才会读取的配置文件，所以将自己的偏好设置写入上述文件后，通常都是需要注销后再登录，才会生效。可以使用 source 指令达到立即生效

```bash
source 配置文件名
```

```bash
# 范例：将 家目录的 ~/.bashrc 的设置读入目前的 bash 环境中
[mrcode@study ~]$ source ~/.bashrc 
[mrcode@study ~]$ . ~/.bashrc 
# 使用 source 或则 小数点的语法 都能将内容读取到当前的 shell 环境中
```

source 还可以用于不同环境配置文件的场景中，比如，我的工作环境分为 3 个，那么需要分别编写属于 3 个项目的环境变量配置文件，当需要该环境时，直接使用 source 加载进来

### `~/.bashrc` （non-login shell 会读）

在非登录情况下取得 bash 环境配置文件时，仅会读取 `~/.bashrc` 文件

```bash
[mrcode@study ~]$ cat ~/.bashrc 
# .bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi

# Uncomment the following line if you don't like systemctl's auto-paging feature:
# export SYSTEMD_PAGER=

# User specific aliases and functions
```

注意看，不同身份账户不同，这也解释了个人偏好配置文件是什么

```bash
[root@study ~]# cat ~/.bashrc 
# .bashrc

# User specific aliases and functions
# 使用者的个人设置
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions
# 整体环境的设置
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
```

CentOS 7.x 中为什么会主动加载 /etc/bashrc 文件呢？是因为 /etc/bashrc 帮我们的 bash 定义出下面的数据：

1. 依据不同的 UID 规范出 umask 的值
2. 依据不同的 UID 规范出提示字符（就是 PS1 变量）
3. 加载 /etc/profile.d/*.sh 的设置

需要注意的是，/etc/bashrc 是 CentOS 特有的（Red Hat 系统），其他的 distribution 可能不是该名称。由于 `~/.bashrc`会加载 `/etc/bashrc` 和 `/etc/profile.d/*.sh` 所以，当你不小心删除了 `~/.bashrc` 那么这些都不能读取了，你的 bash 提示字符可能就变成下面这个样子了

```bash
-bash-4.2$
```

原因是，没有加载 /etc/bashrc 来规范 PS1 d的变量，这种情况也不会影响你的 bash 使用。可以复制 /etc/skel/.bashrc 文件复制到 ~/.bashrc ，恢复回来

## 其他相关配置文件

事实上还有一些配置文件可能会影响到你的 bash 操作

### /etc/man_db.conf

该文件对于系统管理员来说，是一个很重要的文件，它规范了使用 man 时， man page 的路径到哪里去寻找。

如果你是以 tarball 的方式来安装你的数据库，那么你的 man page 可能会放置在 /usr/local/softpackage/man 中，softpackage 是套件的名称，这个时候就需要手动将该路径加到 /etc/man_db.conf 中。否则 man 就会找不到相关的说明文档

### `~/bash_history`

在讲解「历史命令」时提到过该文件，预设情况下，历史命令就记录在该文件中。每次登陆 bash 后，bash 会先读取这个文件，将所有的历史指令读入内存，因此，当我们登陆 bash 后就可以查知上次使用过哪些指令

### `~/.bash_logout`

该文件则记录了：当我注销 bash 后，系统再帮我做完师门动作后才离开的意思。你可以读取下该文件的内容，预设情况下，注销时，bash 只是帮我们清掉屏幕的信息而已。

不过，你也可以将一些备份或则是其他你认为重要的工作写在这个文件中（如：清空暂存盘）

## 终端机的环境设置：stty、set

前面讲解过可以在 tty1~tty6 这 6 个文字终端机（terminal）环境中登录，登录的时候可以取得一些字符设置的功能。比如

- 使用退格键（删除键）来删除命令行上的字符
- ctrl + c 来强制终止一个指令的执行
- 当时呼入错误时，会有声音跑出来警告

以上功能都是在登录终端机时，自动获取终端机的输入环境设置实现的

事实上，目前我们使用的 Linux distributions 都帮我们制作了最棒的使用者环境了，但是在某些 Unix like 机器中，还是可能需要手动修改配置

```bash
# setting tty  
stty [-a]
参数 a：将目前所有的 stty 参数列出来
```

```bash
# 范例 1 ：列出所有的按键与按键内容
[root@study ~]# stty -a
speed 38400 baud; rows 19; columns 126; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S;
susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;
-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8
opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke
# 以上特殊字符 ^ 表示 Ctrl，^C 表示 ctrl + c
```

下面是几个重要的含义：

- intr：送出一个 interrupt 中断信号给目前正在 run 的程序
- quit：送出一个 quit 信号给目前正在 run 的程序
- erase：向后删除字符
- kill：删除在目前指令列上的所有文字
- eof：End of file 的意思，代表「结束输入」
- start：在某个程序停止后，重新启动它的 output
- stop：停止目前屏幕的输出
- susp：送出一个 terminal stop 的喜好给正在 run 的程序

比如要设置 ctrl + h 来进行字符的删除

```bash
stty erase ^h
# 默认可以看到使用 ^? 但是实际测试的时候，改不回去了
```

```bash
错误操作问题：在 windows 下 ctrl + s 是保存功能，在 Linux 使用 vim 时，使用 ctrl + s 整个画面死锁，不能动了，是什么原因？

通过 stty -a 可以看到 ctrl + s 是 stop 功能，停止目前屏幕的输出了，恢复输出的话就是 start，ctrl + q
```

除了 stty 之外，bash 还有自己的一些终端机设置

```bash
set [-uvCHhmBx]
```

选项与参数：

- u：预设不启用。若启用后，当使用未设置变量时，会显示错误信息
- v：预设不启用。若启用后，在信息被输出前，会先显示信息的原始内容
- x：预设不启用。若启用后，在指令被执行前，会显示指令内容（前面有 ++ 符号）
- h：预设启用。与历史命令有关
- H：预设启用。与历史命令有关
- m：预设启用。与工作管理有关
- B：预设启用。与括号`[]` 的作用有关
- C：预设不启用。若使用 > 等，则若文件存在时，该文件不会被覆盖

```bash
# 范例 1： 显示目前所有的 set 设置
[mrcode@study ~]$ echo $-
himBH

# 范例 2：若使用未定义变量时，则显示错误信息
[mrcode@study ~]$ set -u  
[mrcode@study ~]$ echo $mrcode   
-bash: mrcode: unbound variable
[mrcode@study ~]$ set +u		# 关闭该功能使用 + 号
[mrcode@study ~]$ echo $mrcode

[mrcode@study ~]$ 

# 范例 3：执行前，显示该指令内容
[mrcode@study ~]$ set -x
++ printf '\033]0;%s@%s:%s\007' mrcode study '~'
[mrcode@study ~]$ echo ${HOME}
+ echo /home/mrcode
/home/mrcode
++ printf '\033]0;%s@%s:%s\007' mrcode study '~'

#要输出的指令都会被先打印到屏幕上，前面会多出 + 号
```

另外，还有其他的按键设置功能，前一小节提到的 /etc/inputrc 这个文件里面设置。还有例如 `/etc/DIR_COLORS* 与 /usr/share/terminfo/*` 等，也都是与终端机有关的环境配置文件。但是这里不建议修改 tty 的环境，因为 bash 的环境以及设置的很亲和了。

bash 默认的组合键汇总如下

| 组合按键 | 功能                                |
| -------- | ----------------------------------- |
| ctrl + c | 终止目前的命令                      |
| ctrl + D | 输入结束（EOF），例如邮件结束的时候 |
| ctrl + M | Enter                               |
| ctrl + S | 暂停屏幕的输出                      |
| ctrl + Q | 恢复屏幕的输出                      |
| ctrl + U | 在提示字符下，将整列命令删除        |
| ctrl + Z | 暂停 目前的命令                     |

## 通配符与特殊符号

在 bash 操作环境中，通配符（wildcard）是非常有用的，利用 bash 处理数据就更方便了。下面是一些常用的通配符：

| 符号  | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| `*`   | 代表「0 个到无穷多个」任意字符                               |
| `?`   | 代表「一定有一个」任意字符                                   |
| `[]`  | 代表「一定由一个在括号内」的字符（非任意字符）。例如` [abcd]` 则表示一定由一个字符，可能是 a、b、c、d 中的任意一个 |
| `[-]` | 若有减号在括号中时，表示「在编码顺序内的所有字符」。例如`[0-9]`，表示 0~9 之前所有数字 |
| `[^]` | 若括号中的第一个字符为指数符号 ^，表示反向旋转，例如` [^abc]`，表示不包含 a、b、c |

实践练习

```bash
# 范例 1：找出 /etc 下一 cron 开头的文件名
[mrcode@study ~]$ ll -d /etc/cron*    # -d 仅显示目录
drwxr-xr-x. 2 root root  54 Oct  4 18:25 /etc/cron.d
drwxr-xr-x. 2 root root  57 Oct  4 18:25 /etc/cron.daily

# 范例 2：找出 etc 下刚好是 5 个字母的目录名
[mrcode@study ~]$ ll -d /etc/?????
drwxr-x---. 3 root root   83 Oct  4 18:38 /etc/audit
drwxr-xr-x. 4 root root   71 Oct  4 18:25 /etc/avahi

# 范例 3：找出 etc 下目录名含有数字的目录
[mrcode@study ~]$ ll -d /etc/*[0-9]*    # 记得通过 ** 来模糊匹配
drwxr-xr-x. 4 root root   78 Oct  4 18:22 /etc/dbus-1
-rw-r--r--. 1 root root 5725 Aug  6 21:44 /etc/DIR_COLORS.256color

# 范例 4：找出 etc 下，目录名开头不是小写的目录
[mrcode@study ~]$ ll -d /etc/[^a-z]*
ls: cannot access /etc/[^a-z]*: No such file or directory
# 看到没有找到不是小写的目录，换成非大写的，出来结果了
[mrcode@study ~]$ ll -d /etc/[^A-Z]*
drwxr-xr-x. 3 root root   101 Oct  4 18:23 /etc/abrt
-rw-r--r--. 1 root root    16 Oct  4 18:31 /etc/adjtime

# 范例 5：将范例 4 中找到的文件复制到 /tmp/upper 中
[mrcode@study ~]$ mkdir /tmp/upper; cp -a /etc/[^a-z]* /tmp/upper

```

除了通配符外，bash 环境中的特殊符号还有以下项，这里进行整理：

| 符号 | 含义 |
| ---- | ---- |
| `#`  | 批注、注释符号 |
| `\`  | 跳脱符号、转义符号 |
| `|`  | 管线 pipe：分割两个管线命令的节点（后续介绍） |
| `;`  | 连续指令下达分隔符：连续性命令的节点。与管线命令不相同 |
| `~`  | 用户的家目录 |
| `$`  | 取用变量前导符 |
| `&`  | 工作控制（job control）：将指令变成背景下工作 |
| `!`  | 逻辑运算意义上的「非」not 的意思 |
| `/`  | 目录符号：路径分割的符号 |
| `>`、`>>`  | 数据流重导向：输出导向，分别是「覆盖」和「追加」 |
| `<`、`<<`  | 数据流重导想：输入导向（下个章节讲解） |
| `''`  | 单引号，不具有变量替换功能，$ 变为纯文本 |
| `""`  | 双引号，具有变量替换功能，$ 可保留相关功能 |
| ``  | 两个 「\`」中间为可以先执行的指令，也可以使用 `$()` |
| `()`  | 在中间为 子 shell 的起始与结束 |
| `{}`  | 在中间为命令区块的组合 |

以上是 bash 环境中常见的特殊符号整理，理论上，文件名尽量不要使用上述字符


# 数据流重导向

数据流重导向（redirect），将数据传导到其他地方去，将某个指令执行后应该要出现在屏幕上的数据，给传输到其他的地方。

例如文件或则是装置（打印机之类的），数据流重导向在 Linux 的文本模式下很重要，尤其是想要将某些数据存储下来时，就更有用了

## 什么是数据流重导向？

![image-20191202220559186](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20191202220559186.png)

执行一个指令时，这个指令可能会由文件读入资料，经过处理之后，再将数据输出到屏幕上。

- standard output：标准输出 STDOUT
- standard error output：标准错误输出 STDERR

### standard output 与 standard error output

可以简单理解为：

- 标准输出：指令执行所回传的正确的信息
- 标准错误输出：指令执行失败后，所回传的错误信息

比如，我们的系统默认有 /etc/crontab 但无 /etc/mrcode ，此时若下达 `cat /etc/crontab /etc/mrcode` 指令时，cat 会执行：

* 标准输出：读取 /etc/crontab 后，将该文件内容显示到屏幕上
* 标准错误输出：因为无法找到 /etc/mrcode ，因此在屏幕上显示错误信息

可见不管正确或错误信息都输出到屏幕上，那么可以通过数据流重导向将 stdout 与 stderr 分别传送到其他文件或装置去，就达到了分别输出的目的，语法如下：

- 标准输入（stdin 简写）：代码为 0，使用 `<` 或 `<<`
- 标准输出（stdout）：代码为 1，使用 `>` 或 `>>`
- 标准错误输出（stderr）：代码为 2，使用 `2>` 或 `2>>`

为了理解 stdout 与 stderr，下面进行练习

```bash
# 范例 1：观察你的系统根目录 / 下各目录的文件名、权限与属性，并记录下来
[mrcode@study ~]$ ll / 			# 会把结果输出到屏幕
[mrcode@study ~]$ ll / > ~/rootfile		# 会吧结果输出到指定的 rootfile 文件中
[mrcode@study ~]$ ll ~/rootfile
-rw-rw-r--. 1 mrcode mrcode 1078 Dec  1 22:53 /home/mrcode/rootfile

```

上面的指令流程：

1. 该文件若不存在，系统会自动创建文件
2. 该文件若存在，那么会清空内容，再写入数据

标准输出和标准错误输出，单个符号**是覆盖**数据，2 个符号的是**追加**数据；

```bash
# 范例 2：利用一般身份账户查找 /home 下是否有 .bashrc 的文件存在
# 为了这个练习有效果，我在 abc 目录下用 root 身份创建了 .bashrc 空文件
# 并且，把 abc 目录的权限都改为只有 root 才能读取
[mrcode@study home]$ ll
total 4
drwx------.  2 root   root     32 Dec  1 23:01 abc
drwx------. 18 mrcode mrcode 4096 Dec  1 22:53 mrcode
[mrcode@study home]$ find /home/ -name .bashrc 			
/home/mrcode/.bashrc												# 标准输出
find: ‘/home/abc’: Permission denied				# 标准错误输出

# 使用数据流重导向指令，发现标准输出不显示在屏幕了
# 但是标准错误输出还显示在屏幕上
[mrcode@study home]$ find /home/ -name .bashrc > list
-bash: list: Permission denied			# 这里报错了，是因为 home 目录是普通用户是无法写数据的
# 写在 mrcode 自己的目录下
[mrcode@study home]$ find /home/ -name .bashrc > ./mrcode/list
find: ‘/home/abc’: Permission denied

# 范例 3： 使用标准输出 和 标准错误输出都输出到文件中
[mrcode@study home]$ find /home/ -name .bashrc > ./mrcode/list 2> ./mrcode/listerr
```

### /dev/null 垃圾桶黑洞装置的特殊写法

就是可以将任何信息吃掉的黑洞装置

```bash
# 范例 4：将错误的数据丢弃，屏幕上显示正确的数据
[mrcode@study ~]$ find /home/ -name .bashrc 2> /dev/null
/home/mrcode/.bashrc
```

那么能否将正确和错误的数据都写到同一个文件呢？需要特殊的写法才行

```bash
# 范例 5：将指令的数据全部写入 list 文件中

# 错误的写法，可能会交叉写入该文件，数据错乱
[mrcode@study ~]$ find /home/ -name .bashrc > list 2> list

# 正确的写法
[mrcode@study ~]$ find /home/ -name .bashrc > list 2>&1
# 正确的写法
[mrcode@study ~]$ find /home/ -name .bashrc &> list
```

### standard input ：`<` 与`<<`

简单来说：将原本需要由键盘输入的数据，该由文件内容来代替。

```bash
# 范例 6：利用 cat 指令来建立一个文件的简单流程
[mrcode@study ~]$ cat > catfile
testing
cat file test
# 这里使用快捷键 ctrl + d 来离开
```

上面使用 `cat > catfile` ，使用了数据流重导向，catfile 文件会被建立，内容是需要键盘输入，也就是上面的两行内容。这里可以使用标准输入来取代键盘的敲击 

```bash
# 范例 7：用 stdin 代替键盘输入，建立新文件的简单流程
[mrcode@study ~]$ cat > catfile < ~/.bashrc
[mrcode@study ~]$ ll catfile ~/.bashrc
-rw-rw-r--. 1 mrcode mrcode 231 Dec  1 23:28 catfile
-rw-r--r--. 1 mrcode mrcode 231 Aug  8 20:06 /home/mrcode/.bashrc
# 大小一模一样，几乎像是用 cp 来复制一样
```

而 `<<` 表示接受的输入字符。比如：我要用 cat 直接将输入的信息输出到 catfile 中，且当由键盘输入 eof 时，该次输入就结束

```
[mrcode@study ~]$ cat > catfile << 'eof'
> This is a test
> Ok new stop
> eof
[mrcode@study ~]$ cat catfile
This is a test
Ok new stop
# 只有两行数据，不会存在关键词一行
# 这里就有点类似判定结束标准输入的功能
```

`<<`可以代替快捷键 ctrl + d，来终止输入，那为什么要使用命令输出重导向呢？

- 屏幕输出的信息很重要，而且我们需要将它存下来的时候
- 背景执行的程序，不希望他干扰屏幕正常的输出结果的时候
- 一些系统的例行命令（例如在 /etc/crontab 中的文件）的执行结果，希望他可以存下来时
- 一些执行命令可能已知错误信息时，想以`2>/dev/null`丢弃时
- 错误信息与正确信息需要分别输出时

当然还有其他的使用场景，最简单的就是网友们经常问到：为何我的 root 都会受到系统 crontab 寄来的错误信息呢？这个是场景的错误，而如果我们已经知道这个错误信息是可以忽略的时，`2> errorfile` 这个功能就很重要了吧

```bash
# 问：假设要将 echo `error message` 以 standard error output 的格式来输出，怎么做？
答：既然有 2>&1 来将 2> 转到 1> 去，
   那么就应该有 1>&2，可以这样做

[mrcode@study ~]$ echo 'error message' 1>&2
error message
[mrcode@study ~]$ echo 'error message' 2> /dev/null 1>&2

```

## 命令执行的判断依据：`;`、`&&`、`||`

很多指令想要一次输入去执行，而不想分此执行，基本上有两种方法：

- 第十二章要介绍的 shell script 脚本执行
- 通过本章的知识点来完成

###  `cmd;cmd` 不考虑指令相关性的连续指令下达

比如子关机的时候希望可以执行两次 sync 同步写入磁盘后，再 shutdown 计算机

```bash
sync; sync; shutdown -h now
```

这个是两个指令之前没有关系的执行，前一个执行完成后，就执行后一个；如果是这样的情况：在某个目录下创建文件，如果目录存在，则创建文件，如果不存在则不做任何操作，该指令就无法完成了

### `$?`(指令回传值)与 `&&` 和 `||`

前面章节讲到过指令回传值：若前一个指令执行的结果为正确，在 Linux 下会回传一个 `$?=0` 的值。可以通过判断这个值来是否执行后面的指令

逻辑操作符这里就不过多解释了

- `&&`：前一个执行正确，后面才会执行
- `||`：前一个执行正确，后面的不会执行

```bash
# 范例 1：使用 ls 查阅 目录 /tmp/abc 是否存在，若存在则用 touch 建立 /tmp/abc/hehe
[mrcode@study ~]$ ls /tmp/abc && touch /tmp/abc/hehe
ls: cannot access /tmp/abc: No such file or directory
# 只有 ls 报错了，后续的指令没有报错，说明没有被执行

[mrcode@study ~]$ mkdir /tmp/abc
[mrcode@study ~]$ ls /tmp/abc && touch /tmp/abc/hehe
[mrcode@study ~]$ ll /tmp/abc/
total 0
-rw-rw-r--. 1 mrcode mrcode 0 Dec  2 00:22 hehe

# 范例 2：测试 /tmp/abc 是否存在，若不存在则建立该目录，若存在则不做操作
[mrcode@study ~]$ rm -r /tmp/abc/

[mrcode@study ~]$ ls /tmp/abc || mkdir /tmp/abc
ls: cannot access /tmp/abc: No such file or directory
# 报错没有找到目录，后面没有报错，但是查看缺创建了，证明执行了

[mrcode@study ~]$ ll -d /tmp/abc/
drwxrwxr-x. 2 mrcode mrcode 6 Dec  2 00:24 /tmp/abc/

# 而下面这个没有报错，后面也没有报错，说明只执行了前面的指令
[mrcode@study ~]$ ls /tmp/abc || mkdir /tmp/abc


# 范例 3：我不清楚 /tmp/abc 是否存在，但就是要建立 /tmp/abc/hehe 文件
[mrcode@study ~]$ ls /tmp/abc || mkdir /tmp/abc/ && touch /tmp/abc/hehe

```

范例三，对于的表达式对于 java 或则 js 来说，理解不太一样，如下分析：

- 第一种情况：/tmp/abc 不存在
  1. ls /tmp/abc 回传 `$?≠0`，结果为 false
  2. 则执行创建操作，由于会成功，故 `$?=0`，结果为 true
  3. 则执行创建 hehe 文件
- 第二种情况：/tmp/abc 存在
  	1. ls /tmp/abc 回传 `$?=0`，结果为 true
   	2. `||` 遇到 true 后面的不会执行，**但是** 结果会往后传递
   	3. 前一个结果为 true，那么久执行创建

![image-20191204230542102](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20191204230542102.png)

只要注意：linux 指令是从左往右执行的，只有相邻的指令会被特殊符号阻断

```bash
## 例题：以 ls 测试 /tmp/mrcode 是否存在，存在则显示 exist, 不存在则显示 not exist
[mrcode@study ~]$ ls /tmp/mrcode && echo 'exist' || echo 'not exist'
ls: cannot access /tmp/mrcode: No such file or directory
not exist

[mrcode@study ~]$ mkdir /tmp/mrcode
[mrcode@study ~]$ ls /tmp/mrcode && echo 'exist' || echo 'not exist'
exist
# 可以看到的确只有相邻的两个指令会被阻断

# 如果搞不清楚他们的逻辑的话，就会出现下面这种情况
[mrcode@study ~]$ ls /tmp/mrcode || echo 'exist' && echo 'not exist'
ls: cannot access /tmp/mrcode: No such file or directory
exist
not exist
# 两种都出现了，不存在，则执行 exist，后面并且关系，再次执行
[mrcode@study ~]$ mkdir /tmp/mrcode
[mrcode@study ~]$ ls /tmp/mrcode || echo 'exist' && echo 'not exist'
not exist
# 存在，则不执行 exit，true 往后传递，则执行 not exist
```

# 管线命令（pipe）

bash 命令执行的时候有输出数据，如果这群数据必须经过几道手续之后才能得到我们想要的格式，这就可以使用管线命令（pipe）来完成了

假设我们想知道 `/etc/` 下有多少文件，可以使用 `ls /etc/` 来查询，不过因为文件太多了，输出占满整个屏幕，导致最开始是什么文件看不到了，这就可以通过管线命令结合 less 指令来达成

```bash
[mrcode@study ~]$ ls -al | less
```

如此一来， `ls -al` 指令输出后的内容，能够被 less 读取，并且利用 less 的功能，可以前后翻动相关信息

管线命令**仅能处理**由前一个指令传来的**正确信息**（standard output），对于 standard error 没有直接处理的能力，整体管线命令可以使用下图表示

![image-20191204232521041](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20191204232521041.png)

在每个管线后面接的第一个数据必定是「指令」，而且这个指令必须能接受 standard input 的数据才可以，这样的指令则是「管线命令」，例如 less、more、head、tail 等都是可以接受 standard input 的管线命令。而 ls、cp、mv 等就不是管线命令了，因为他们不不会接受来自 stdin 的数据。管线命令主要有两个比较需要注意的地方：

- 管线命令仅会处理 standard output ，对于 standard error output 会忽略
- 管线命令必须要能接受来自前一个指令的数据成为 standard input 继续处理才行

如果硬要 standard error 可以被管线命令所使用可以使用如下方式

```bash
2>&1   让标准错误输出转成标准输出
```

那么下面来玩一些管线命令，以下知识点对系统管理费用有用

## 截取命令 cut、grep

简单说：将一段时间经过分析后，取出我们想要的。或则是经过由分析关键词，取得我们所想要的那一行。一般来说，截取信息通常是针对一行一行来分析的。

### cut

```bash
cut -d '分割字符' -f fields  # 用于有特定分割字符
cut -c 字符区间							 # 用于排列整齐的信息
```

选项与参数：

- d：后面接分割字符。与 `-f` 一起使用
- f：依据 -d 的分割字符将一段信息分区成数段，用 -f 取出第几段的意思
- c：以字符（characters）的单位取出固定字符区间

```bash
# 范例 1：将 PATH 变量取出，我要找出第 5 个路径
[mrcode@study ~]$ echo ${PATH}
/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin
# 数量是从 1 开始，不是从 0 哟
[mrcode@study ~]$ echo ${PATH} | cut -d ':' -f 5
/usr/sbin

# 取出第 5 个和第 6 个
[mrcode@study ~]$ echo ${PATH} | cut -d ':' -f 5,6
/usr/sbin:/home/mrcode/.local/bin


# 范例 2 ：将 export 输出的信息，取得第 12 字符以后的所有字符串
[mrcode@study ~]$ export
declare -x HISTCONTROL="ignoredups"
declare -x HISTSIZE="1000"
declare -x HOME="/home/mrcode"
declare -x HOSTNAME="study.centos.mrcode"
...

# 以上数据每个都是排列整齐的，有着 declare -x 前缀
# 那么想要把前缀去掉，就可以这样做
[mrcode@study ~]$ export | cut -c 12-
HISTCONTROL="ignoredups"
HISTSIZE="1000"
HOME="/home/mrcode"
# 使用 12-15 则是截取出这个区间的字符
# 使用 12 则只截取 12 这个字符

# 范例 3 ：用 last 将显示的登陆者信息，仅留下用户名
[mrcode@study ~]$ last
# 账户 		终端机					登录 IP					日期时间						
mrcode   pts/1        192.168.0.105    Mon Dec  2 01:25   still logged in   
mrcode   pts/0        192.168.0.105    Mon Dec  2 01:25   still logged in   
mrcode   pts/1        192.168.0.105    Mon Dec  2 00:21 - 01:12  (00:51)  
# 用空格分隔的数据，那么可以这样做
[mrcode@study ~]$ last | cut -d ' ' -f 1
mrcode
mrcode
mrcode
# 其实 账户和终端机之间的空格有好几个，并不是一个所以使用下面的命令并不能把 终端机一列也提取出来
last | cut -d ' ' -f 1,2
```

cut 主要的用途：将同一行里面的数据进行分解

常使用在分析一些数据或文字数据的时候，因为有时候会以某些字符当做分区的参数，然后将数据切割，以取得我们所需要的数据，作者常常在分析 log 文件的时候，但是 cut 在处理多空格相连的数据时，就比较麻烦，所以某些常见可能需要使用下一章节要讲解的 awk 来取代

### grep

cut 是将一行信息中，取出某部分我们想要的数据，而 grep 则是分析一堆信息，若一行当中有匹配的数据，则将这一行数据拿出来

```bash
grep [-acinv] [--color=auto] '搜索的字符串' filename
```

选项与参数：

- a：将 binary 文件以 text 文件的方式搜索数据
- c：计算找到「搜索字符」的次数
- i：忽略大小写
- n：输出行号
- v：反向选择，显示出没有搜索字符串的那一行数据
- `--color`：可以将找到的关键词部分加上颜色显示

```bash
# 范例 1：将 last 中，有出现 root 的那一行找出来
[mrcode@study ~]$ last | grep 'root'
root     tty3                          Sun Oct  6 23:16 - crash  (22:40)    
root     tty4                          Fri Oct  4 22:48 - 22:48  (00:00)  
# 会发现 root 被高亮颜色了，我们时候 type 命令查看，发现被自动加上了 color 参数
[mrcode@study ~]$ type grep
grep is aliased to 'grep --color=auto'

# 范例 2：与 范例 1 相反，不要 root 的数据
[mrcode@study ~]$ last | grep -v 'root'
mrcode   pts/1        192.168.0.105    Mon Dec  2 01:25   still logged in   
mrcode   pts/0        192.168.0.105    Mon Dec  2 01:25   still logged in   
mrcode   pts/1        192.168.0.105    Mon Dec  2 00:21 - 01:12  (00:51)
reboot   system boot  3.10.0-1062.el7. Fri Oct  4 18:47 - 03:43  (08:56)

# 范例 3：在 last 的输出信息中，只要有 root 就取出，并且只取第一栏
# 结合 cut 命令取出第一栏
[mrcode@study ~]$ last | grep 'root' | cut -d ' ' -f 1
root
root

# 范例 4：取出 /etc/man_db.conf 内涵 MANPATH 的那几行
[mrcode@study ~]$ grep 'MANPATH' /etc/man_db.conf
# MANDATORY_MANPATH                     manpath_element
# MANPATH_MAP           path_element    manpath_element

```

grep 支持的语法很多，用在正规表示法里，能够处理的数据太多。但是这里先不了解正规表示法，下一章再来讲解

这里只需要了解下，grep 可以解析一行文字，取得关键词，若改行有存在关键词，就会整行取出来

## 排序命令：sort、wc、uniq

### sort

可以依据不同的数据形态来排序。例如数字与文字的排序不一样，另外，排序的字符与语系的编码有关，因此，如果需要排序时，建议使用 LANG=C 来让语系统一，数据排序比较好一些

```bash
sort [-fbMnrtuk] [file or stdin]
```

选项与参数：

- f：忽略大小写的差异
- b：忽略最前面的空格符
- M：以月份的名字来排序，例如 JAN、DEC 等排序方法
- n：使用纯数字进行排序，默认是以文字形态来排序
- r：反向排序
- u：uniq，相同的数据中，仅出现一行代表，也就是去重
- t：分隔符，预设使用 「tab」来分割
- k：以那个区间（field）来进行排序

```bash
# 范例 1：个人账户都记录在 /etc/passwd 下，将账户进行排序
[mrcode@study ~]$ cat /etc/passwd | sort
abrt:x:173:173::/etc/abrt:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
chrony:x:993:990::/var/lib/chrony:/sbin/nologin
# 可以看到按字符排序了

# 范例 2：/etc/passwd 内容是以 : 来分割的，想使用第三栏进行排序
[mrcode@study ~]$ cat /etc/passwd | sort -t ':' -k 3
root:x:0:0:root:/root:/bin/bash
mrcode:x:1000:1000:mrcode:/home/mrcode:/bin/bash
qemu:x:107:107:qemu user:/:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
# 第三栏是数字，但是这里并没有按数字大小来排序，因为默认使用文字排序
# 与数值大小进行排序
[mrcode@study ~]$ cat /etc/passwd | sort -t ':' -k 3 -n
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

# 范例 3：利用 last ，将输出的数据仅取账户，并排序
[mrcode@study ~]$ last | cut -d ' ' -f 1 | sort

mrcode
mrcode

```

### uniq

```bash
uniq [-ic]
- i：忽略大小写
- c：进行计数
```

实践练习

```bash
# 范例 1： 使用 last 将账户列出，仅取出账户，排序后去重
[mrcode@study ~]$ last | cut -d ' ' -f 1 | sort | uniq

mrcode
reboot
root
wtmp

# 范例 2：以上题，统计每个账户登录的总次数
[mrcode@study ~]$ last | cut -d ' ' -f 1 | sort | uniq -c
      1
    136 mrcode
     19 reboot
      2 root
      1 wtmp

# 第一行和 wtmp 是 last 的默认字符，可以忽略
```

### wc

wc 可以计算输出的信息。比如：/etc/man_db.conf 这个文件里面有多少字？多少行？

```bash
wc [-lwm]

-l：仅列出行
-w：仅列出多少字（英文单字）
-m：多少字符
```

```bash
# 范例 1：/etc/man_db.conf 这个文件里面有多少字
[mrcode@study ~]$ cat  /etc/man_db.conf | wc
	   行     字数	   字符数
    131     723    5171

# 范例 2：last 可以输出登陆者，但是 last 最后两行并非账户内容，那么该如何以一行指令取得登录系统的总人次？
last | grep [a-zA-Z] | grep -v 'wtmp' | grep -v 'reboot' | grep -v 'unknown' | wc -l
138
# grep 正则匹配，排除了非英文字符的账户
# grep -v 反向选择，相当于排除了指定的账户
# 最后使用 wc 统计行数
```

## 双向重导向：tee

前一节讲解到 > 会将数据流整个栓送给文件或装置，因此除非去读取该文件或装置，那么如果想要将整个暑假流的处理过程中将某段信息存下来该怎么做？就可以使用 tree

```bash
Standard input   ------> tee --------> Screen
												  ↓
												 file
# 流程如上
```

tee 会同时将数据流分送到文件与屏幕，而输出到屏幕的其实就是 stdout，那么就可以让指令继续处理

```bash
tee [-a] file
- a：以累加（append）的方式，将数据加入 file 中
```

```bash
# 将 last 内容输出到 last.list 文件中，并继续处理
[mrcode@study ~]$ last | tee last.list | cut -d " " -f 1

# 将 ls 数据存一分到 ~/homefile 同时屏幕也输出信息
[mrcode@study ~]$ ls -l /home/ | tee ~/hoefile | more

```

## 字符转换命令：tr、col、join、paste、expand

在 vim 程序编辑器中提到过 DOS 换行符与 Unix 不一样，并且可以使用 dos2unix 与 unix2dos 来完成转换。

那么思考下，是否还有其他的字符转换命令，比如：将大写改成小写、将数据中的 tab 转成空格、如何将两篇信息整合成一篇？

### tr：正则替换或删除字符

tr 可以用来删除一段信息中的文字，或则是进行文字信息的替换

```bash
tr [-ds] SET1 ...

-d：删除信息当中的 SET1 这个字符串
-s：替换重复的字符
```

```bash
# 范例 1：将 last 输出的信息中，原有的小写变成大写字符
[mrcode@study ~]$ last | tr '[a-z]' '[A-Z]'
MRCODE   PTS/1        192.168.0.105    MON DEC  2 07:00   STILL LOGGED IN

# 范例 2：将 /etc/passwd 输出的信息中，将冒号 : 删除
[mrcode@study ~]$ cat /etc/passwd | tr -d ':'
rootx00root/root/bin/bash

# 范例 3：将 /etc/passwd 转成 dos 换行到 ~/passwd 中，再将 ^M 符号删除
# 由于我这里没有安装 unix2dos 这里无法实际演示
cp /etc/passwd ~/passwd && unix2dos ~/passwd
file /etc/passwd ~/passwd
cat ~/passwd | tr -d '\r' > ~/passwd.linux
# \r 是 dos 的换行符
ll /etc/passwd ~/passwd*
# 就会发现处理之后和源文件一样大小了
# 本例子是：将 unix 转成 dos，/n 转成了 /r/n ，然后使用 tr 命令将 /r 删除了，相当于又还原了

#那么经过上面的分析之后，其实转换程序就是转换了换行符，那么可以利用 tr 手动来完成转换
[mrcode@study ~]$ cp /etc/passwd ~/passwd
[mrcode@study ~]$ file /etc/passwd ~/passwd
/etc/passwd:         ASCII text
/home/mrcode/passwd: ASCII text
# 将 unix 换行符 \n 替换成 dos 换行符 \r\n
[mrcode@study ~]$ cat passwd | tr '\n' '\r\n' > passwd.dos
[mrcode@study ~]$ file passwd*
passwd:     ASCII text
passwd.dos: ASCII text, with CR line terminators		# 可以看到已经变了
# 再将 \r 删掉
[mrcode@study ~]$ cat passwd | tr -d '\r' > passwd.linux
[mrcode@study ~]$ file passwd*
passwd:       ASCII text
passwd.dos:   ASCII text, with CR line terminators
passwd.linux: ASCII text

```

该指令也可以写在正规表示法里面，因为他也是由正规表示法的方式来取代数据的，比如上面使用 `[]` 来设置字符，通常用来取代文件中的怪异符号。

### col：将 tab 转换成对等的空格

```bash
col [-xb]

-x:将 tab 键转换成对等的空格键
```

```bash
# 范例 ： 利用 cat -A 显示出所有的特殊按键，最后以 col 将 tab 转成空白
[mrcode@study ~]$ cat -A /etc/man_db.conf
MANDATORY_MANPATH^I^I^Imanpath_element$		# ^I 的符号就是 tab

[mrcode@study ~]$ cat /etc/man_db.conf | col -x | cat -A | more
MANDATORY_MANPATH                      /usr/src/pvm3/man$

```

虽然 col 有特殊的用途，但是很多时候可以用来简单的将 tab 取代为空格键，并且可以取代会对等宽度的空格

### join：合并两个文件中相同行的数据

```bash
join [-ti12] file1 file2
```

选项与参数：

- t：join 默认以空格符分割数据，并且比对「第一个字段」的数据，如果两个文件相同，则将两笔数据连城一行，且第一个字段放在第一个
- i：忽略大小写
- 1：数值 1，代表「第一个文件要用哪个字段来分析」
- 2：数值 2，代表「第二个文件要用哪个字段来分析」

```bash
# 范例 1：用 root 身份，将 /etc/passwd 与 /etc/shadow 相关数据整合成一栏
[root@study ~]# head -n 3 /etc/passwd /etc/shadow
==> /etc/passwd <==
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin

==> /etc/shadow <==
root:$6$oTg/fYGfv9/GIl6h$UEcmYlRZacV757rHtXlvmu5xH5TWGfqd3eDOEotB3CAc5mcW5UEoMTSg0pDICd/sYGrEScsHQY9tYZY0FGkKS1::0:99999:7:::
bin:*:17834:0:99999:7:::
daemon:*:17834:0:99999:7:::
# 输出的信息来看，最左边的的账户有相同的账户，且以 : 分割

[root@study ~]# join -t ':' /etc/passwd /etc/shadow | head -n 3
# 看到了吗，作用就是将某个字段的数据合并成一段
root:x:0:0:root:/root:/bin/bash:$6$oTg/fYGfv9/GIl6h$UEcmYlRZacV757rHtXlvmu5xH5TWGfqd3eDOEotB3CAc5mcW5UEoMTSg0pDICd/sYGrEScsHQY9tYZY0FGkKS1::0:99999:7:::
bin:x:1:1:bin:/bin:/sbin/nologin:*:17834:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin:*:17834:0:99999:7:::

# 范例 2：/etc/passwd 第四个字段是 GID，/etc.group 的第三个字段是 GID ,那么如何将两个文件合并？
[root@study ~]# head -n 3 /etc/passwd /etc/group
==> /etc/passwd <==
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin

==> /etc/group <==
root:x:0:
bin:x:1:
daemon:x:2:

# 下面两种写法一致
join -t ':' -1 4 -2 3 /etc/passwd /etc/group | head -n 3
join -t ':' -1 4 /etc/passwd -2 3 /etc/group | head -n
# 报错了，提示没有排序过，所以在使用时要先对内容排序，这样才能合并两行数据
join: /etc/passwd:6: is not sorted: sync:x:5:0:sync:/sbin:/bin/sync
join: /etc/group:11: is not sorted: wheel:x:10:mrcode
# 看下面被整合的内容
0:root:x:0:root:/root:/bin/bash:root:x:
1:bin:x:1:bin:/bin:/sbin/nologin:bin:x:
2:daemon:x:2:daemon:/sbin:/sbin/nologin:daemon:x:

```

### paste：将两行贴在一起

将两行贴在一起，且中间以 tab 隔开

```bash
paste [-d] file1 file2

-d：后面可以接分割符。默认以 tab 来分割
- ：如果 file 部分写成 -，表示来自 standard input
```

```bash
# 范例 1：用 root 身份，将 /etc/passwd 与 /etc/shadow 同一行贴在一起
[root@study ~]# paste /etc/passwd /etc/shadow | head -n 3
root:x:0:0:root:/root:/bin/bash root:$6$oTg/fYGfv9/GIl6h$UEcmYlRZacV757rHtXlvmu5xH5TWGfqd3eDOEotB3CAc5mcW5UEoMTSg0pDICd/sYGrEScsHQY9tYZY0FGkKS1::0:99999:7:::
bin:x:1:1:bin:/bin:/sbin/nologin        bin:*:17834:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin daemon:*:17834:0:99999:7:::

# 范例 2：先将 /etc/group 用 cat 读出，然后与范例 1 贴在一起，且仅取出前三行
# paset 文件部分可以是多个，这里最后一个文件使用了 -，也就是 cat /cat/etc/group
[root@study ~]# cat /etc/group | paste /etc/passwd /etc/shadow - | head -n 3
root:x:0:0:root:/root:/bin/bash root:$6$oTg/fYGfv9/GIl6h$UEcmYlRZacV757rHtXlvmu5xH5TWGfqd3eDOEotB3CAc5mcW5UEoMTSg0pDICd/sYGrEScsHQY9tYZY0FGkKS1::0:99999:7:::       root:x:0:
bin:x:1:1:bin:/bin:/sbin/nologin        bin:*:17834:0:99999:7:::        bin:x:1:
daemon:x:2:2:daemon:/sbin:/sbin/nologin daemon:*:17834:0:99999:7:::     daemon:x:2:

```

### expand：将 tab 转成空格

```bash
expand [-t] file

-t：后面可以接数字。一般来说，一个 tab 可以用 8 个空格取代，这里自定义几个空格取代
```

```bash
# 范例 1：将 /etc/man_db.conf 内行首为 MANPATH 的字样取出，仅取前三行
[root@study ~]# grep '^MANPATH' /etc/man_db.conf | head -n 3
MANPATH_MAP     /bin                    /usr/share/man
MANPATH_MAP     /usr/bin                /usr/share/man
MANPATH_MAP     /sbin                   /usr/share/man
# 行首正则为 ^,下接讲解

# 范例 2：承上，将所有的符号都列出来
[root@study ~]# grep '^MANPATH' /etc/man_db.conf | head -n 3 | cat -A
MANPATH_MAP^I/bin^I^I^I/usr/share/man$
MANPATH_MAP^I/usr/bin^I^I/usr/share/man$
MANPATH_MAP^I/sbin^I^I^I/usr/share/man$
# ^I 是 tab

# 范例 3：承上，将 tab 转成 6 个空格
[root@study ~]# grep '^MANPATH' /etc/man_db.conf | head -n 3 | expand -t 6 | cat -A
MANPATH_MAP /bin              /usr/share/man$
MANPATH_MAP /usr/bin          /usr/share/man$
MANPATH_MAP /sbin             /usr/share/man$
# 可以看到 tab 被替换成空格了
```

有一个需要特别注意：tab 最大功能就是格式排列整齐，但是换成空格之后，就不一定是排列整齐的了，也可以参考一下  unexpand 这个将空白转成 tab 的指令

```bash
[root@study ~]# grep '^MANPATH' /etc/man_db.conf | head -n 3 | expand -t 6 | unexpand -t 6 | cat -A
MANPATH_MAP /bin^I^I^I/usr/share/man$
MANPATH_MAP /usr/bin^I^I/usr/share/man$
MANPATH_MAP /sbin^I^I^I/usr/share/man$
# 可以看到，范例 3 的还可以被 unexpand 给转换回来
```

## 分区命令：split

split 可以分割文件，按文件大小或行数来分割

```bash
split [-bl] file PREFIX

-b：后面可接要分区的大小，可加单位，如 b、k、m 等
-l：以行数进行分区

PREFIX：表示分区文件命名前缀
```

```bash
# 范例 1：/etc/services 有 600 多 k，若想要分成 300k 一个文件
[mrcode@study ~]$ cd /tmp; split -b 300k /etc/services servers
[mrcode@study tmp]$ ll servers*
-rw-rw-r--. 1 mrcode mrcode 307200 Dec  2 09:53 serversaa
-rw-rw-r--. 1 mrcode mrcode 307200 Dec  2 09:53 serversab
-rw-rw-r--. 1 mrcode mrcode  55893 Dec  2 09:53 serversac

# 范例 2：如何将上面三个文件合成一个文件？
[mrcode@study tmp]$ cat serversa* > servicesback
[mrcode@study tmp]$ ll serv*
-rw-rw-r--. 1 mrcode mrcode 307200 Dec  2 09:53 serversaa
-rw-rw-r--. 1 mrcode mrcode 307200 Dec  2 09:53 serversab
-rw-rw-r--. 1 mrcode mrcode  55893 Dec  2 09:53 serversac
-rw-rw-r--. 1 mrcode mrcode 670293 Dec  2 09:54 servicesback

# 范例 3：使用 ls -al / 输出的信息中，每 10 行记录成一个文件
# 这里文件使用了 - ，表示使用标准输入，前面讲过的
[mrcode@study tmp]$ ls -al / | split -l 10 - lsroot
[mrcode@study tmp]$ ll lsroot*
-rw-rw-r--. 1 mrcode mrcode 456 Dec  2 09:57 lsrootaa
-rw-rw-r--. 1 mrcode mrcode 523 Dec  2 09:57 lsrootab
-rw-rw-r--. 1 mrcode mrcode 192 Dec  2 09:57 lsrootac
[mrcode@study tmp]$ wc -l lsroot*
  10 lsrootaa
  10 lsrootab
   4 lsrootac
  24 total
# - 一般用在，指令 stdout/stdin 时，但偏偏又没有文件，就用 - 来表示 stdout/stdin
```

## 参数代换：xargs

产生某个指令的参数。xargs 可以读入 stdin 的数据，并且以空格符或换行符号作为分辨，将 stdin 的数据分割成为 arguments。

```bash
xargs [-0epn] command
```

- 0：数值 0，如果输入的 stdin 含有特殊字符，例如 \`、\\、空格等时，可以将他转义为一个普通字符
- e：EOF（end of file）。后面可以接一个字符串，当 xargs 分析到这个字符串时，会停止继续工作；注意：`-e'sync'` 选项与后面的 eof 字符中间没有空格
- p：在执行每个指令的 argument 时，都会询问使用者
- n：后面接次数，每次 command 指令执行时，要使用几个参数

当 xargs 后面没有接任何指令时，默认是以 echo 来进行输出的

实践练习

```bash
# 范例 1：将 /etc/passwd 内第一栏取出，仅取三行，使用 id 这个指令将每个账户内容秀出来
# id 可以查询用户的 UID/GID 等信息
[mrcode@study tmp]$ id root
uid=0(root) gid=0(root) groups=0(root)

# 通过之前的指令把前三行的第一栏用户名提取出来
[mrcode@study tmp]$ cat /etc/passwd | head -n 3 | cut -d ':' -f 1
root
bin
daemon

# 通过 $(cmd) 可以预先取得参数，但可惜的时候，id 这个指令只能接收一个参数，导致报错了
[mrcode@study tmp]$ id $(cat /etc/passwd | head -n 3 | cut -d ':' -f 1)
id: extra operand ‘bin’
Try 'id --help' for more information.

# 因为 ID 不是管线命令，管线前的输出都没有用，相当于只输出了 id 的内容
[mrcode@study tmp]$ cat /etc/passwd | head -n 3 | cut -d ':' -f 1 | id
uid=1000(mrcode) gid=1000(mrcode) groups=1000(mrcode),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

# xargs 将 3 个账户处理后给 id，一样的会报错
[mrcode@study tmp]$ cat /etc/passwd | head -n 3 | cut -d ':' -f 1 | xargs id
id: extra operand ‘bin’
Try 'id --help' for more information.

# 通过 -n 来指定每次指令命令使用几个参数
# 因为前面输出是三行，在 xargs 中会被当成 3 个参数
[mrcode@study tmp]$ cat /etc/passwd | head -n 3 | cut -d ':' -f 1 | xargs -n 1 id
uid=0(root) gid=0(root) groups=0(root)
uid=1(bin) gid=1(bin) groups=1(bin)
uid=2(daemon) gid=2(daemon) groups=2(daemon)

# 范例 2：同上，但是每次执行 id 时，都要询问使用者是否动作
[mrcode@study tmp]$ cat /etc/passwd | head -n 3 | cut -d ':' -f 1 | xargs -n 1 -p id
id root ?...			# 这里没有输入 y 被判定为不执行了
id bin ?...y
uid=1(bin) gid=1(bin) groups=1(bin)
id daemon ?...

# 范例 3：将所有的 /etc/passwd 内的账户都以 id 查询，但差到 sync 就结束指令串
[mrcode@study tmp]$ cat /etc/passwd | cut -d ':' -f 1 | xargs -e'sync' -n 1 id
uid=0(root) gid=0(root) groups=0(root)
uid=1(bin) gid=1(bin) groups=1(bin)
uid=2(daemon) gid=2(daemon) groups=2(daemon)
uid=3(adm) gid=4(adm) groups=4(adm)
uid=4(lp) gid=7(lp) groups=7(lp)

```

xargs 是一个非常好用的指令，一般使用它的原因是，很多指令其实并不支持管线命令，因此可以通过 xargs 来提供该指令引用 standard input 。如果还不太明白，下面在来看一个例子

```bash
# 范例 4：找出 /usr/sbin 下具有特殊权限的文件名，并使用 ls -l 列出详细属性
# 但是 ls 不是管线命令
[mrcode@study tmp]$ find /usr/bin/ -perm /7000 | ls
# 可以使用 $(cmd) 语法
[mrcode@study tmp]$ ls -l $(find /usr/bin/ -perm /7000)

# 使用 xargs
[mrcode@study tmp]$ find /usr/bin/ -perm /7000 | xargs -n 1 ls -l
-r-xr-sr-x. 1 root tty 15344 Jun 10  2014 /usr/bin/wall
-rwsr-xr-x. 1 root root 32096 Oct 31  2018 /usr/bin/fusermount
```

## 关于减号 `-` 的用途

管线命令在 bash 的连续的处理程序中是相当重要的。另外，在 log file 的分析中也是很重要的一环。

另外，在管线命令中，常常会使用到前一个指令的 stdout 作为这次的 stdin，某些指令需要用到文件名（例如 tar）来进行处理时，该 stdin 与 stdout 可以利用减号 `-`来替代

```bash
# 将 /home 里的文件打包，但打包的数据不是记录到文件，而是传送到 stdout
# 经过管线后，将 tar -cvf - /home 传送给后面的 tar -xvf - ，
# 这里的 - 就是取用前一个指令的 stdout
mkdir /tmp/homeback
[mrcode@study tmp]$ tar -cvf - /home/ | tar -xvf - -C /tmp/homeback/
```

## 重点回顾

- 由于核心在内存中是受保护的区块，因此我们必须通过 shell 将我们输入的指令与 Kernel 沟通，好让 kernel 可以控制硬件来正确无误的工作
- 学习 shell 的原因主要有：

  - 文字接口的 shell 在各大 distribution 都一样

  - 远程管理时，文字接口速度较快

  - shell 是管理 linux 系统非常重要的一环，因为 linux 内很多控制都是以 shell 撰写的
- 系统合法的 shell 均写在 /etc/shells 文件中
- 用户默认登录取得的 shell 记录于 /etc/passwd 的最后一个字段
- bash 的功能主要有：

  - 命令编修能力
  - 命令与文件补全功能
  - 命令别名设置功能
  - 工作控制、前景背景控制
  - 程序化脚本
  - 通配符
  - 
- type 可以用来找到执行指令为何中类型，也可以用于与 which 相同的功能
- 变量就是以一组文字或符号等，来取代一些设置或是一串保留的数据
- 变量主要有环境变量与自定义变量，或称为全局变量与局部变量
- 使用 env 与 export 可以观察环境变量，其中 export 可以将自定义变量转成环境变量
- set 可以观察目前 bash 环境下的所有变量
- `$?`为变量，是前一个指令执行完毕后的回传值。在 linux 回传值为 0 表示执行成功
- locale 可用于观察语系资料
- 可用 read 让用户由键盘输入变量的值
- ulimit 可用以限制用户使用系统的资源情况
- bash 的配置文件主要分为 login shell 与 non-login shell。
  - login shell 主要读取 /etc/profile 与 `~/.bash_profile`
  - non-login shell 则仅读取 `~/.bashrc`
- 在使用 vim 时，若不小心按了 ctrl + s 则画面会被冻结。可以使用 ctrl + q 来解除冻结
- 通配符主要有：`*、？、[]` 等
- 数据流重导向通过 `>、2>、<` 之类的符号将输出的信息转到其他文件或装置去
- 连续命令的下达可通过 `;、&&、||` 等符号来处理
- 管线命令的重点是：
  - 管线命令仅会处理 standard output，对于 standard error output 会忽略
  - 管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行
- 本章介绍的管线命令主要有：cut、grep、sort、wc、uniq、tee、tr、col、join、paste、expand、split、xargs 等

# 本章习题

情景模拟题 1：由于 `~/.bash_history` 仅能记录指令，我想要在每次注销时都记录时间，并将后续的指令 50 笔记录下来，要怎么做？

- 目标：了解 history，并通过数据流重导向的方式记录历史命令
- 前提：需要了解本章的数据流重导向，以及了解 bash 的各个环境配置文件信息

这里其实很简单，并不是要记录每条指令执行的时间，而是每次注销时的时间

```bash
# 退出的钩子在 ~./bash_logout
[mrcode@study tmp]$ vi ~/.bash_logout 
# 先把当前时间写入到文件第一行
date > ~/.myhistory 
# 再将最新 50 条指令追加写入到文件
history 50 >> ~/.myhistory
clear

```

简答题：

- 在 Linux 上可以找到那些 shell（举出三个）？那个文件记录可用的 shell？而 Linux 预设的 shell 是？

  1. /bin/bash、/bin/tcsh、/bin/csh
  2. /etc/shells
  3. /bin/bash

- 你输入一串指令之后，发现前面写的一长串数据是错误的，你想要删除游标所在处到最前面的指令串内容，应该如何处理？

  使用 ctrl + u 删除

- 在 shell 环境下，有个提示字符（prompt），可用修改吗？要修改什么？默认的提示字符内容是？

  可用修改的，修改 PS1 变量，默认内容为 `[\u@\h \W]\$`

- 如何显示 HOME 这个变量

  `echo ${HOME}`

- 如何得知目前的所有变量与环境变量的设置？

  环境变量用 env 或 export ，使用 set 查看所有的环境变量

- 是否可以设置一个变量名称为 3myhome?

  不可以，变量名不可以以数值作为开头

- 在这样的练习中 `A=B 且 B=C`，若下达 `unset $A` 则取消的变量是 A 还是 B？

  被取消的是 B，因为 unset $A 相当于 unset B，所以取消的是 B，A 会继续存在

- 如何取消变量与命令别名的内容？

  使用 unset 及 unalias

- 如何设置一个变量名称为 name 内容为 It's my name?

  `name="it's my name"` 或 `name=it\‘s\my\name`

- bash 环境配置文件主要分为哪两种类型的读取？分别读取哪些重要文件？

  - login shell：主要读取 /etc/profile 以及 `~/.bash_profile`
  - Non-login shell：主要读取 `~/.bashrc` 

- CentOS 7.x 的 man page 的路径配置文件名？

  /etc/man_db.conf

- 说明  `’、"、`与 \`在变量定义中的用途

  - `'`：表示普通字符串
  - `"`：具有变量上下文属性
  - \`：被包裹的指令可以先被执行

- 跳脱符号 `\`有什么特殊用途

  可以用来跳过特殊字符，例如 Enter、$ 等，使其成为一般字符

- 连续命令中，`;、$$、||` 有何不同？

  - `;`：分别让两个 command 连续执行，不考虑 command1 的输出状态
  - `$$`：前一个指令必须没有错误信息，回传值为 0，则 command2 才会执行
  - `||`：前一个指令必须有错误信息，与 && 相反

- 如何将 last 的结果中，独立出账户，并且印出曾经登录过的账户？

  ​	`last | cut -d ' ' -f 1 | sort | uniq`

- 请问 `fool && foo2 | foo3 > foo4` 这个指令串中， foo1、foo2、foo3、foo4 是指令还是文件？整个指令的意义是？

  - Foo1、foo2、foo3 是指令，foo4 是文件
  - 若 foo1 执行错误时，则该指令串结束
  - 若 foo1 执行成功实，则执行 foo2 | foo3 > foo4,其中
    - foo2 的 stdout 结果传给 foo3 处理
    - Foo3 将来自 foo2 的 stdout 当成 stdin，处理完成后，将数据流重导向 foo4 这个装置/文件

- 如何秀出在 /bin 下任何以 a 开头的文件名详细资料

  `ls -ld /bin/a*`

- 如何秀出 /bin 下，文件名为 4 个字符的文件

  `ls -ld /bin/????`

- 如何秀出 /bin 下，文件名开头不是 a-d 的文件

  `ls -ld /etc/[^a-d]*`

- 想要让终端机接口的登录提示字符修改成我自己喜好的模样，需要修改哪个文件？

  `/etc/issue`

- 接上题，如果我是想要使用者登录后，才显示欢迎信息，需要修改哪个文件？

  `/etc/motd`

  