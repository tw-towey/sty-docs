# Linux 磁盘与文件系统管理
系统管理员很重要的任务之一就是管理好自己的磁盘文件系统，每个分区槽不可太大也不能太小，
太大浪费，太小则不够用。

前面谈到的文件权限与属性，他们是记录在文件系统的哪个区块内？这就要谈到 filesystem 中的
inode 与 block 了。

为了虚拟化大容量磁盘，现在的 Centos7 默认使用大容量效能较佳的 xfs 当预设文件系统。

本章重点：如何制作文件系统，包括分区、格式化与挂载等。该章比较重要

## 认识 Linux 文件系统
最传统的 linux 磁盘文件系统是 EXT2 ，所以要了解 Linux 的文件系统，就要先由 EXT2 开始，而文件系统是建立在磁盘上面的，因此我们得了解磁盘的物理组成才行

- [磁盘物理组成](../00/)
- [磁盘分区](../02/)

前面讲解了以上两个知识点，那么本节重点就在于 inode、block 和 superblock 等文件系统的基本部分

## 磁盘组成与分区的复习
### 磁盘组成
磁盘的组成主要有：

- 圆形的磁盘（主要记录数据的部分）
- 机械手臂，与机械手臂上的磁盘读取头（可擦写磁盘上的数据）
- 主轴马达，可以转动磁盘，让机械手臂的读取头在磁盘上读写数据

数据存储与读取的重点在于磁盘，那么磁盘上的物理组成则为（假设为单盘片）：

- 扇区（Sector）为最小的物理存储单位，且依据磁盘设计的不同，目前主要有 512 bytes  与 4 k 两种格式
- 将扇区组成一个圆，那就是磁柱（Cylinder）
- 早期的分区主要以磁柱为最小单位，现在的分区通常使用扇区为最小分区单位（每个扇区都有其号码）
- 磁盘分区表主要有两种格式：

  - MBR 分区表：限制较多
  - GPT 分区表：新的限制较少
- MBR 分区表中，第一个扇区很重要，里面主要有：

  1. 主要开机区（Master boot record ，MBR），占用 446 bytes
  2. 分区表（partition table），占用 64 bytes

- GPT 分区表除了分区数量扩充较多外，支持的磁盘容量也可以超过 2 TB

磁盘文件名部分，所有实体磁盘的文件名都已经被模拟成 `/dev/sd[a-p]` 的格式，
第一课磁盘文件名为 /dev/sda。而分区槽则为 `/dev/sda[1-128]`（以第一颗磁盘为例）。

虚拟持平通常为  `/dev/vd[a-p]` 格式。如有使用到软件磁盘阵列的话，还有 `/dev/md[0-128]` 的磁盘文件名。使用的是 LVM 时，则为 `/dev/VGNAME/LVNAME` 等格式。

关于磁盘阵列与 LVM 后面会继续介绍，这里主要介绍以实体磁盘及虚拟磁盘为主。

- `/dev/sd/[a-p][1-128]`：为实体磁盘的磁盘文件名
- `/dev/vd/[a-d][1-128]`：为虚拟磁盘的磁盘文件名

### 磁盘分区

GPT 分区表支持大容量的磁盘，小磁盘默认会使用 MBR 的分区，可以使用配置强制使用 GPT 分区表

## 文件系统特性
为什么在分区完成之后需要格式化（format）才能够使用这个文件系统？因为每种操作系统所设定的文件属性、权限不同，为了存放这些文件所需的数据，因此就需要将分区槽进行格式化成操作系统能够利用的「文件系统格式」

windows 使用 FAT16，包括现在的 NTFS 文件系统，Linux 的正统文件系统则为 Ext2（Linux second extended file system，EXT2fs），
在默认情况下，windows 操作系统不会认识 linux 的 ext2 的

传统的磁盘与文件系统之应用中，一个分区槽只能被格式化为一个文件系统，
所以我们可以称之为说一个 filesystem 就是一个 partition。
新技术的出现，如 LVM 与 软件磁盘阵列（software raid），这些技术可以将一个分区槽格式化
为多个文件系统（如 LVM），也可以将多个分区槽合并成一个文件系统（LVM、RAID）。
所以目前在格式化时已经不再说成针对 partition 来格式化了，通常我们可以称呼
**一个可被挂载的数据为一个文件系统而不是一个分区槽**

文件系统的运作与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外，
通常有非常多的属性（例如 linux 的 rwx 群组等）。

文件系统通常会将这两部分数据分别存放在不同的区块：

- inode： 权限与属性放置处
- data block ：实际的数据
- superblock（超级区块）：记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等

每个 inode 与 block 都有编号，简介如下：

- superblock

  记录此 filesystem 的整体信息，包括 inode、block 的总量、使用量、剩余量、文件系统的格式与相关信息等
- inode

  记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 号码
- block

  实际记录文件的内容，若文件太大时，会占用多个 block

下图是 inode 与 block 区块图解说明。文件系统先格式化出 inode（灰色） 与 block（蓝色）区块；

![](http://p4ui.toweydoc.tech:20080/images/stydocs/markdown-img-paste-20191020201151284.png)

假设 inode 4 中记录了 2、7、13、15 这 4 个 block 的号码，操作系统就能够依据此来排列磁盘的阅读顺序，可以一口气将 4 个 block 内容读出来。

这种数据存取方法称为「索引式文件系统（indexed allocation）。那么一般使用的 U 盘，
通常为 FAT 格式，这种文件系统没有 inode 存在，所以没法讲这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 中，读取方式如下图所示

![](http://p4ui.toweydoc.tech:20080/images/stydocs/markdown-img-paste-20191020201550290.png)

它只能一个一个将 blcok 读出来后，才会知道下一个 block 在哪里。如果同一个文件数据写入的 block 分散太过厉害，则磁盘读取头可能需要多转好几圈才能读完整个文件内容

**磁盘碎片** 整理就是如此，文件写入的 block 太过于离散了，此时文件读取的效能将会变得很差。可以通过磁盘碎片整理程序将同一个文件所属的 blocks 汇总在一起，这样读取会比较容易

那么 EXT2 是否需要磁盘碎片整理呢？基本不太需要！因为 ext2 是所索引式文件系统。
但是如果文件系统使用太久，常常删除、编辑、新增文件时，还是有可能造成文件数据太过离散的问题。但是貌似基本上没有做过这个碎片整理的操作

## Linux 的 Ext2 文件系统（inode）

ext2 就是使用这种 inode 为基础的文件系统，并且文件系统一开始就将 inode 与 block 规划好了，除非重新格式化（或则利用 resize2fs 等指令变更文件系统大小），
否则 inode 与 block 固定后就不再变动。

当文件系统数据高达数百 GB 时，将所有的 inode 与 block 通通放置在一起很不理智，而且这么多数量的 inode 与 blcok ，不太统一管理。

因此 ext2 文件系统在格式化的时候，基本上是分区为多个区块组（block group）的，
每个区块群组都有独立的 inode、block、superblock 系统。这样分成一群一群的比较好管理，整个来说 ext2 格式化后有点像下图这样

![](http://p4ui.toweydoc.tech:20080/images/stydocs/markdown-img-paste-20191020202557601.png)

在整体规划中，**文件系统最前面有一个启动扇区（boot sector）**，
这个启动扇区可以安装开机管理程序，这是个非常重要的设计，因为能将不同的开机管理程序安装
到个别的文件系统最前端，而不用覆盖整颗磁盘唯一的 MBR，正因为这样才能够制作出多重引导环境

每个区块群组（block group）的 6 个主要内容如下

### data block 资料区块
data block 是用来存放文件内容的地方，EXT2 中所支持的 block 大小有 1k、2k 及 3k 三种。在格式化时 block 的大小就固定了，并都有编号，方便 inode 的记录。

由于 block 大小的差异，会导致该文件系统能够支持的最大磁盘容量与最大单一文件容量并不相同。限制如下：

Block 大小         | 1 KB  | 2KB    | 4kb
-------------------|-------|--------|------
最大单一文件限制   | 16 GB | 256 GB | 2TB
最大文件系统总容量 | 2 TB  | 8 TB   | 16 TB

虽然 ext2 已经能够支持大于 2GB 以上的单一文件容量，有些应用程序依然使用旧的限制，
无法读取超过 2GB 的文件

block 的基本限制如下：

- 原则上，block 的大小与数理在格式化完成就不能够再改变了（除非重新格式化）
- 每个 block 内最多只能放置一个文件的数据
- 如果文件大于 block 的大小，则一个文件会占用多个 block 数量
- 若文件小于 block ，则该 block 的剩余容量就不能够再被使用（磁盘空间会浪费）

原理如上，那么假设你的 ext2 文件系统使用 4k block，有 10000 个小文件（均为 50 bytes），此时硬盘浪费多少容量？

```
一个 block 只能存储一个文件，每个 block 会浪费：4096 - 50 = 4046 byte
所有文件总量为：50 bytes * 10000 = 488.3 kbytes
此时浪费容量为：4046 bytes * 10000 = 38.6 MBytes

总共不到 1 MB 的总文件容量却浪费近 40 MB 的容量
```

在什么场景下回出现以上所说的问题？比如在 BBS 网站中的数据，使用纯文本记录每篇留言，
当留言内容都都很少时，就会产生很多的小文件（留言越多产生小文件越多）

那么将 block 设置为 1k ，可能也不妥当，因为大型文件会占用数量更多的 block，
而 inode 也需要记录更多的 block 号码，此时将可能导致文件系统不良的读写效能

所以在进行文件系统的格式化时，需要按你的使用场景来预计使用情况，如基本上都是几百兆的文件，那么就选择 4k 的（目前硬盘容量都很大了，所以一般都会选择 4k，而不管场景了）

### inode table
inode 记录文件的属性和实际数据的 block 号码，基本上记录的文件信息至少有以下：

- 该文件存取模式（read、write、excute）
- 文件拥有者与群组（owner、group）
- 文件的容量
- 文件建立或状态改变实际（ctime）
- 最近一次的读取实际（atime）
- 最近修改的时间（mtime）
- 定义文件特性的旗标（flag），如 SetUID 等
- 该文件真正内容的指向（pointer）

inode 的数量与大小在格式化时以及固定，还有以下特点：

- 每个 inode 大小均固定为 128 bytes（新的 ext4 与 xfs 可设定到 256 bytes
- 每个文件仅会占用一个 inode
- 因此文件系统能建立的文件数量与 inode 的数量有关
- 系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，符合才会读取 block 的内容

下面简略分析 ext2 的 inode、block 与文件大小的关系。

inode 记录的数据非常多，但是仅 128 bytes，记录一个 block 号码花掉 4 byte；
假设有一个文件有 400 MB 且米格 block 为 4k 时，至少需要 10 万笔 block 号码要记录，但是 inode 的 128 byte 怎么能够记录下这么多的号码？

系统将 inode 记录 block 号码的区域定义为 12 个直接、一个间接、一个双间接、一个三间接记录区，如下图所示

![](http://p4ui.toweydoc.tech:20080/images/stydocs/markdown-img-paste-20191020205428576.png)

- 直接：该区域内直接存取 block 号码
- 间接：该区域内记录了一个 block 号码，该 block 才是记录文件内容的 block 号码
- 双间接：当文件太大时，在第二层中来记录 block 号码
- 三间接：当文件更大时使用，在第三层中记录数据内容的 block 号码

这样子的 inode 能够指定多少个 block 呢？以 1k block 来说明：

- 12 个直接指向：12 * 1k = 12k

  总共可以记录 12 笔记录，总额为 12k
- 间接：256 * 1k = 256k

  每个 block 号码需要 4 byte 来记录，因此 1k 的大小能够记录 256 个。
- 双间接：256 * 256 * 1k = 256 的 2 次方

  第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个号码
- 三间接：256 * 256 * 256 * 1k = 256 的 3 次方

- 总额：直接 + 间接 + 双间接 + 三间接

  12 + 256 + 256 * 256 + 256 * 256 * 256 = 16 GB

在 ext2 中，当 block 格式化为 1k 大小时，能够容量的最大单文件为 16 GB,
在前面的文件系统限制表总的说明大小一致！但是该方法不能用在 2k 以及 4k block 大小的计算中，因为大于 2k 的 block 将会受到 ext2 文件系本身的限制（啥限制？笔者没看明白）

所以新系统能使用 ext4 还是使用最新的文件系统，ext4 的 inode 容量扩大到 256 bytes 了，可以记录更多的文件系统信息，包括新的 acl 以及 SELinux 类型等，单一文件容量高达 16 TB 且单一文件系统总容量可达 1 EB

### Superblock 超级区块
superblock 是记录真个 filesystem 相关信息的地方，没有 superblock 就没有这个 filesystem 了，记录的主要信息有：

- block 与 inode 的总量
- 未使用与已使用的 inode 、block 数量
- block 与 inode （block 1、2、4k，inode 为 128 、256 bytes）
- filesystem 的挂载时间、最近一次写入时间的时间、最近一次检验磁盘（fsck）的时间等
- 一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0，否则为 1

superblock 的大小为 1024 bytes，它非常重要，这个文件系统的基本信息都写在这里，
如果 superblock 挂掉，那么可能需要花费很多时间去挽救。后续使用 dumpe2fs 指令来观察

此外，每个 block group 都可能含有 superblock ，一个文件系统只应该有一个 superblock，多出来的只是备份（这样才可以有救援的机会）；第一个 block group 内会含有 superblock 之外，
后续的 block group 不一定含有 superblock，如果含有则是作为第一个 block group 内
superblock 的备份

### Filesystem Description 文件系统描述说明
该区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段
（superblock、bitmap、inodemap、data block）分别介于哪一个 block 号码之间。
这部分也可以使用 dumpe2fs 指令来观察

### block bitmap 区块对照表
新增文件时会用到 block ，如何选择到一个空的 block 来记录文件数据，就是通过 block bitmap 来知道的。

同样，删除文件时，原本占用的 block 号码需要释放，bitmap 中对应的标志就需要修改

### inode bitmap （inode 对照表）
与 block bitmap 类似，记录 inode 的使用情况

### dumpe2fs 查询 ext 家族 superblock 信息的指令

由于目前 centos7 使用了 xfs 为预设文件系统，所以本次学习无法进行试验，
dumpe2fs 只支持 ext 家族信息查询。

后续讲过格式化内容之后，就可以自己切除一个 ext4 的文件系统来实践这里的指令

这里的 ext 文件系统为 1GB 容量，使用默认方式进行格式化，观察内容如下：

```bash
dumpe2fs [-bh] 装置文件名
```
选项参数：

- b：列出保留为坏轨的部分
- h：仅列出 superblock 的数据，不会列出其他区段的内容

实践练习：

```bash
# 通过该指令查看目前系统有被格式化的装置
# 这里使用一块 1GB ext4 文件系统内容
blkid
# 能看到如下的信息
/dev/vda5: UUID="e20-xxx-333c---" TYPE="ext4"

dumpe2fs /dev/vda5
# 信息非常之多，笔者也没有练习场景，就先截图了
```
![](http://p4ui.toweydoc.tech:20080/images/stydocs/markdown-img-paste-20191020213231296.png)
![](http://p4ui.toweydoc.tech:20080/images/stydocs/markdown-img-paste-20191020213324262.png)

利用 dumpe2fs 可以查询到非常多的信息，group 也有号码，这里看 group0 的信息：

- group0 所占用的 block 号码由 0 到 32767 号，superblock 则在第 0 号的 block 区块
- 文件系统描述说明在 第 1 号 block 中
- block bitmap 与 inode bitmap 则在 129 及 145 的 block 号码上
- inode table 分布与 161-672 的 block 号码中
- 由于

  1. 一个 inode 占用 256 bytes
  2. 总共有 672 - 161 + 1（161 本身） = 512 个 block 话在 inode table 上
  3. 每个 block 的大小为 4096 bytes（4k）

  由这些数据可以算出 inode 的数量共有 512 * 4096/256 = 8192 个 inode
- group0 目前可用的 block 有 28521 个，可用的 inode 有 8181 个
- 剩余的 inode 号码为 12-8192 号

想要了解更多信息的话，参考本章最后一小节，否则知道这些信息以及足够了

## 与目录树的关系
前面讲到，每个文件都会占用一个 inode，按文件内容分配多个 block 给文件使用，
在前面的权限章节中有说到，目录记录文件名，而文件是实际记录数据内容的地方，
那么目录与文件在文件系统中是如何记录数据的？

### 目录

当新建一个目录时，**文件系统会分配一个 inode 与至少一块 block 给该目录**，
其中，inode 记录该目录的相关权限与属性和分配的 block 号码，而 block 则记录该目录下的文件名
与该文件名占用的 inode 号码数据。

```
目录所占用的 block 内容记录如下的信息

inode number | 文件名
-------------|--------
522222       | ks.cfg
533333       | setup.cfg
```

可以使用指令来观察上面所示的信息

```bash
# 观察 root 目录下文件所占用的 inode 号码
[root@study ~]# pwd
/root
[root@study ~]# ls -li
总用量 12
25165890 -rw-------. 1 root   root   2175 10月  4 18:32 anaconda-ks.cfg
25165899 -rw-r--r--. 1 root   root   2206 10月  4 18:42 initial-setup-ks.cfg
25377248 -rwxr-xrwx. 1 mrcode mrcode 2206 10月  7 23:30 initial-setup-ks-mrcode.cfg
```

这里有点懵逼，我自己不记得自己当时分区选的是 1k 还是 2k 还是 4k 的了，
而且我这里看也不是书上说的是几乎都是 1024 的倍数（使用 ll 指令查看），
（难道这里书上用的是是 ext 文件格式的问题？）

```bash
[root@study ~]# ll -d / /boot /usr/sbin/ /proc/ /sys/
dr-xr-xr-x.  17 root root   224 10月 11 05:03 /      # 咋和书上不一致？不是 4k
dr-xr-xr-x.   5 root root  4096 10月  4 18:32 /boot   # 1 个 4k block
dr-xr-xr-x. 190 root root     0 10月 16 21:35 /proc/  # 内存数据不占用磁盘容量
dr-xr-xr-x.  13 root root     0 10月 16 21:35 /sys/
dr-xr-xr-x.   2 root root 20480 10月  4 18:25 /usr/sbin/  # 这里也是不一样，是 5 个 4k
```

### 文件
当在 ext2 建立一个一般文件时，ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件。
例如：我的一个 block 为 4Kbytes ，创建一个 100KBytes 的文件，会得到 一个 inode 与 25 个 block 来
存储该文件，同时请注意：inode 仅有 12 个直接指向，还需要多一个 block 来作为区块号码记录

### 目录树读取

上面的知识点中并没有说到文件夹会存在 inode 中，文件名的记录是在目录的 block 中的。
因此在前面章节「文件与目录的权限」说明中，才会提到新增、删除、更名文件名 **与目录的 w 权限有关**。

因此我们要读取某个文件时，必须经过目录的 inode 与 block，才能找到要读取文件的 inode 号码，
最终才会读到正确的 block 内的数据

由于目录树是由根目录开始读起的，需要一层一层往下读，举例来说明读取 /etc/passwd 这个文件时的流程：

```bash
[root@study ~]# ll -di / /etc /etc/passwd
      64 dr-xr-xr-x.  17 root root  224 10月 11 05:03 /
16797761 drwxr-xr-x. 143 root root 8192 10月  4 18:38 /etc
18256917 -rw-r--r--.   1 root root 2323 10月  4 18:31 /etc/passwd
```

假设上面 passwd 文件是由 mrcode 这个一般身份使用者读取：

1. `/` 的 inode

  透过挂载点的信息找到 inode 号码为 128 的 64 的根目录，且 inode 规范的权限让我们可以读取该
  block 的内容（有 r 与 x）
2. `/` 的 block

  经过上个步骤取得 block 号码，并找到该内容有 /etc 目录的 inode 号码（16797761）
3. `etc/` 的 inode

  读取 16797761 号的 inode 得知 mrcode 具有 r 与 x 权限，因此可以读取 etc/ 的 block 内容
4. `etc/` 的 block

  经过上个步骤取得 block 号码，并找到该内容有 passwd 文件的 inode 号码（18256917）
5. passwd 的 inode

  读取 18256917 号 inode 得知 mrcode 具有 r 的权限，因此可以读取 passwd 的 block 内容
6. passwd 的 block

  最后将该 block 内容的数据读取出来

### filesystem 大小与磁盘读取效能
关于文件系统的使用效率上，例如规划一个 100GB 的文件系统时，由于磁盘上面的数据总是来来去去的，
所以整个文件系统上面的文件通常无法连续写在一起（block 号码不会连续的意思），
如果写入的 block 真的很分散，此时就有文件 **数据离散** 的问题发生了

如前所述，虽然 ext2 在 inode 处已经将该文件所记录的 block 号码都记录上了，
所以资料可以一次性读取，但是太过离散，确实会发生读取效率低落的问题。
因为磁盘读取头需要再整个文件系统中来来去去频繁读取，如果真的发生了这样的问题，
那么可以将整个 filesystem 内的数据全部复制出来，将该 filesystem 重新格式化，在复制回去，即可解决


此外，如果 filesystem 真的太大了，当一个文件分别记录在该文件系统的最前面和最后面的 block 号码中，
此时会造成磁盘的机械手臂移动幅度过大，也会造成读取低落的问题。所以 partition 的规划并不是越大越好，
而是需要针对用途来规划才行


## ext2、3、4 文件的存取与日志式文件系统的功能

前面谈到读取，如果新建一个文件或目录时，文件系统是如何处理的呢？
这个时候需要 block bitmap 与 inode bitmap 来帮忙了，例如：新增一个文件，此时文件系统的行为是：

1. 先确定用户对于新增文件的目录是否具有 w 与 x 的权限，若有的话才能新增
2. 根据 indoe bitmap 找到没有使用 inode 号码，并将新文件的权限、属性写入
3. 根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，并且更新 inode 的 block 指向数据
4. 将刚刚写入的 inode 与 block 数据同步更新 inode bitmap 与 block bitmap ，并更新 superblock 的内容

一般来说，将 inode table 与 data block 称为数据存放区，
superblock、block bitmap 、inode bitmap 等区段称为 metadata（中介资料，元数据？），
因为 superblock、block bitmap 、inode bitmap 的数据经常变动，每次新增、移除、编辑都可能会影响
到这三个部分的数据，因此才被称为中介数据

### 数据的不一致（inconsistent）状态
因为意外原因导致上述的新增动作没有全部完成，比如突然停电等，如写入的数据仅有 inode table 和 data block，
字后一个同步更新的步骤没有做完，此时就会发生 metadata 的内容与实际数据存放区不一致（Inconsistent） 的情况了

在早期 ext2 文件系统中，会在系统重新启动的时候，由 superblock 当中的记录的 valid bit（是否有挂载）
与 filesystem state（clean）等状态来判断是否强制进行数据一致性的检查！若有需要检查则以 e2fsck 程序来进行。

不过这样的机制很耗时，要针对 metadata 区域与实际数据存放区来进行比对，要搜索整个 filesystem，
当你文件系统有 100GB 以上，文件数量又多时，就很耗时。
比如该服务器上有对外提供的服务，那么就会延迟对外提供服务了

那么日志式文件系统就兴起了（看来每一个设计都不是完美的，都是在使用中优化的）

### 日志式文件系统（Journaling filesystem）

为了解决不一致的情况发生，而且回复要快速；在 filesystem 中规划处一个区块专门记录写入或修订文件时
的步骤，就可以简化一下一致性检查步骤了：

1. 预备：当系统要写入一个文件时，会先在日志记录区块中记录某个文件准备要写入的信息
2. 实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据
3. 结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的记录

这样一来，只要检查日志记录区块，就可以知道哪个文件发生了问题，能达到快速修复 filesystem 的能，
这就是日志式文件最基础的功能

ext2 不能，需要通过他的升级版本 ext3、4 版本来实现，前面使用 dumpe2fs 输出的信息，
发现 superblock 里面还有下面类似的信息，有 32 M 的容量在处理日志

```
Journal inode:  8
Journal backup: inode blocks
Journal features:
Journal size: 32M
Journal length:
```

## 文件系统的运作
现在知道目录树与文件系统的关系；在 [第 0 章节](../00/) 中知道，所有的数据都要加载到内存后，
CPU 才能对该数据进行处理。如果你常常编辑一个很大的文件，在编辑中又频繁的要系统写入到磁盘中，
由于磁盘写入速度比内存慢很多，因此你会常常耗在等待磁盘写入、读取上。效率太低

为了解决这个问题，linux 使用 asynchronously 方式（异步处理）：
当系统加载一个文件到内存中，如果没有被更动过，则在内存区段的文件数据会被设置为感觉（clean）的。
但如果内存中的文件数据被更动过了（例如编辑过），此时内存中的数据会被设定为脏的（Dirty），
此时所有的动作都还在内存中执行，并没有写到磁盘中。系统不定时的将内存中设定为 Dirty 的数据写回磁盘

因此 linux 系统上面文件系统与内存有非常大的关系：

- 系统会将常用的文件数据放置到主存储器的缓冲区，加速文件系统的读写
- 因此 linux 的物理内存最后都会被用光，这是正常的，可加速系统性能
- 可以手动使用 sync 来强迫内存中设置为 dirty 的文件回写到磁盘中
- 若正常关机时，关机指令会主动调用 sync 将内存的数据回写到磁盘中
- 但若不正常关机时（如断电、宕机等不明原因），由于数据尚未回写到磁盘内，因此重新启动后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损坏（非磁盘损坏）

## 挂载点意义 mount point
每个 filesystem 都有独立的 inode、block、superblock 等信息，这个文件系统要能够链接到目录树
才能被我们使用。将文件系统与目录树结合的动作我们成为「挂载」

::: tip
到这里笔者才明白，目录树只是一个系统软件，文件系统是物理硬盘中管理硬盘中数据怎么存储的软件，
他们两个需要通过挂载，目录树才能操作这个硬件
:::

重点：挂载点一定是目录，该目录为进入该文件系统的入口

例如：依据本书前面章节安装 Centos7 的话，那么应该会有三个挂载点，分别是：/、/boot、/home ，
对应的装置文件名为 LVM、LVM、/dev/vda2（笔者上没有找到与书上一致的虚拟磁盘，这里描述可能不一致）。
那么观察这三个目录 inode 号码时，可发现如下情况：

```bash
[root@study ~]# ls -lid / /boot/ /home/
# 书上是 128 号
64 dr-xr-xr-x. 17 root root  224 10月 11 05:03 /
64 dr-xr-xr-x.  5 root root 4096 10月  4 18:32 /boot/
64 drwxr-xr-x.  4 root root   42 10月  8 23:01 /home/
```

这里三个目录的号码都是一样的（有序 xfs 最顶层的目录之 inode 一般为 64），但是我们的确是分了三个挂载点，而且他们的文件系统格式也不一样，
这里难道是说明每个 filesystem 是独立的，他们的号码也是独立的？如果是这样，那么这里就能说得过去了
（这里笔者有点懵逼）

使用文件系统的观点来看，同一个 filesystem 的某个 inode 只会对于到一个文件内容，
可以通过 inode 号码来确定不同文件名是否为相同的文件

```bash
[root@study ~]# ls -lid / /. /..
64 dr-xr-xr-x. 17 root root 224 10月 11 05:03 /
64 dr-xr-xr-x. 17 root root 224 10月 11 05:03 /.
64 dr-xr-xr-x. 17 root root 224 10月 11 05:03 /..

# 这个能看清楚了，/usr 上层目录就是 /  为 64
[root@study /]# ls -lid /usr/ /usr/. /usr/..
25377249 drwxr-xr-x. 13 root root 155 10月  4 18:21 /usr/
25377249 drwxr-xr-x. 13 root root 155 10月  4 18:21 /usr/.
      64 dr-xr-xr-x. 17 root root 224 10月 11 05:03 /usr/..

```

## 其他 Linux 支持的文件系统与  VFS
虽然 linux 的标准文件系统是 ext 家族，事实上还支持很多文件系统格式，尤其是近来推出的几种
速度很快的日志式文件系统，如 SGI 和 XFS 文件系统，可以使用更小型文件的 Reiserfs 文件系统，
以及 windows 的 FAT 文件系统等。常见的支持文件系统有：

- 传统文件系统：ext2、minix、MS-DOS、FAT（用 vfat 模块）、iso9660（光盘）等
- 日志式文件系统：ext3/4、ReiserFS、windows NTFS、IMB JFS、SGI XFS、ZFS
- 网络文件系统：NFS、SMBFS

想要知道你的 linux 支持哪些文件系统，可以查看下面目录

```bash
[root@study /]# uname -r
3.10.0-1062.el7.x86_64
[root@study /]# ls -l /lib/modules/3.10.0-1062.el7.x86_64/kernel/fs/

# 系统目前已加载到内存中支持的文件系统有;出来挺多格式的
[root@study /]# cat /proc/filesystems
```

那么 Linux 的核心是如何管理这些认识的文件系统的？整个 linux 系统都是通过一个名为
Virtual Filesystem Switch（VFS） 的核心功能去读取 filesystem 的。使用者并不需要知道每个
partition 上的 filesystem 是什么，VFS 会做好读取动作

假设 / 使用的是 /dev/hda1 用 ext3，而 /home 使用 /dev/hda2 用 reiserfs ，
那么你取用 /home/mrcode/.bashrc 时，你没有特别指定用什么文件系统的模块来读取，整个就是 VFS
的功能。 VFS 简略图示如下

![](http://p4ui.toweydoc.tech:20080/images/stydocs/markdown-img-paste-20191020233249283.png)

## XFS 文件系统简介

为什么从 CentOS 7 将预设文件系统由 ext4 变成了 XFS 文件系统了呢？为啥舍弃支持度最完整的 ext ？
原因如下

### Ext 家族优点：支持度最广，但格式化超慢
ext 文件系统对于文件格式化的处理，采用预先规划处所有的 inode、block、meta data 等数据，
未来系统可以直接取用，不需要再进行动态配置的作为。

在早期容量不大的时候没有问题，在大容量磁盘上来预先分配，尤其是在 PB 或 EB 级别的磁盘，
格式化就很慢了（书上说格式化 70 TB的磁盘阵列为 ext4 文件系统，出去喝完咖啡回来还没有格式完）

另外，虚拟化应用广泛起来，而作为虚拟化磁盘来源的巨型文件（单一文件好几个 GB 以上）也常见起来。

所以改用了 xfs 这一个较适合高容量磁盘与巨型文件效能较佳的文件系统了

::: tip
速度方面可能仅在格式化，文件系统复原速度等方面有很大区别，很慢
:::

### XFS 文件系统的配置

xfs 是一个日志式文件系统，最早是被开发来用于高容量磁盘以及高性能文件系统之用，
此外几乎所有 ext4 文件有的功能，xfs 都可以具备

xfs 文件系统在资料的分布上，主要规划为 3 个部分：

- 一个资料区（data section）
- 一个文件系统活动等录区（log section）
- 一个实时运作区（realtime section）

#### 资料区（data section）
基本上，数据区和之前的 ext 家族类似，包括 inode、data block、superblock 等数据。

该数据区与 ext 家族的 block group 类型，分为多个存储群组（allcation groups）来分别
放置文件系统所需要的数据。

每个存储区群组都包含了：

- 整个文件系统的 superblock
- 剩余空间的管理机制
- inode 的分配与追踪

此外，inode 与 block 都是系统需要用到时，动态配置产生，所以格式化动作超级快。

与 ext 家族不同的是：xfs 的 block 与 inode 有多重不同的容量可设置，block 容量可由
512 bytes ~ 64 k 调配，在 linux 环境下，由于内存控制的关系（页面文件 pagesize 的容量），
因此最高可以使用的 block 大小为 4k 而已。

鸟哥尝试格式化 block 为 16k 是没有问题，但是 linux 核心不给挂载，所以格式化完后也不能使用。

至于 inode 的容量可以由 256 bytes 到 2M 大小，不过，大概还是保留 256 bytes 的默认值就够用了

总之：xfs 的这个资料区（数据区）的储存区群组（allocation groups ，AG），就看成是 ext 的
block 群组（block groups），只是 inode 与 block 是动态产生，并非一开始就格式化完成配置的

#### 文件系统活动登录区（log section）
登录区主要用来记录文件系统的变化，有点像日志区。文件的变化会在这里记录下来，直到该变化完整的
写入到数据区后，该笔记录才会被中介。

如果文件系统因为故障而损坏时，系统会拿这个登录区块进行检验，并快速修复文件系统。

因为系统所有动作基本都在该区块记录，磁盘活动很频繁，xfs 设计有点有趣，在这个区域中，
可以指定外部的磁盘来作为文件系统的日志区块，例如可以使用 SSD 磁盘作为 xfs 的登录区

#### 实时运作区（realtime section）
当有文件要被建立时，xfs 会在该区段找到数个的 extent 区块，将文件放置在这个区块内，等分配完毕后，
再写入到 data section 的 inode 与 block 去。

extent 区块的大小需要在格式化的时候指定，范围是 4 k ~ 1 G。一般非磁盘阵列默认为 64k，
具有类似磁盘阵列的 stripe 情况下，则建议设置为与 strip 一样大较佳。该 extent 最好不要乱动，
因为由可能会影响到实体磁盘的效能

### XFS 文件系统的描述数据观察
可以使用 xfs_info 来观察相关信息

```bash
xfs_info 挂载点/装置文件名

# 找出系统  /boot/ 挂载点下的文件系统的 superblock 记录
[mrcode@study ~]$ df -T /boot/
Filesystem     Type 1K-blocks   Used Available Use% Mounted on
/dev/sda2      xfs    1038336 174108    864228  17% /boot
# 这里看到了 xfs 的文件系统。

# 观察该挂载点的内容
[mrcode@study ~]$ xfs_info /dev/sda2
1 meta-data=/dev/sda2              isize=512    agcount=4, agsize=65536 blks
2          =                       sectsz=512   attr=2, projid32bit=1
3          =                       crc=1        finobt=0 spinodes=0
4 data     =                       bsize=4096   blocks=262144, imaxpct=25
5          =                       sunit=0      swidth=0 blks
6 naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
7 log      =internal               bsize=4096   blocks=2560, version=2
8          =                       sectsz=512   sunit=0 blks, lazy-count=1
9 realtime =none                   extsz=4096   blocks=0, rtextents=0

```

- 第一行

  - isize=512：inode 的容量为 512 bytes
  - agcount=4：存储区群组（allocation group）为 4 个
  - agsize=65536：每个存储区群组具有 65536 个 block，配合第 4 行的 block 设置为 4k，因此整个文件系统的容量应该是 4 * 65536 * 4k 这么大
- 第二行：sectsz=512 逻辑扇区 sector 的容量为 512 bytes
- 第四行：bsize 为 block 的容量，为 4 k，共有 262144 个 block 在这个文件系统内
- 第五行：sunit 与 swidth 与磁盘阵列的 stripe 相关性较高。该部分在格式化操作时候讲解
- 第七行：internal 指登录区的位置在文件系统内。占用了 4 k * 2560 个 block ，总共约 10 M 容量
- 第九行：realtime 区域里面的 extent 容量为 4 k，不过目前没有使用

第五行中的两个值与磁盘阵列相关，会影响文件系统性能，因此格式化时需要特别注意

## 文件系统的简单操作
本章讲解如何查询整体文件系统的总容量与每个目录所占用的容量。
此外前面谈到的文件类型中尚未将清楚的连接文档（link file）也会在这里介绍

## 磁盘与目录的容量
磁盘整体数据是在 superblock 区块中，但是每个各别文件的容量则在 inode 中记载的。
可以使用如下指令查询：

- df：列出文件系统的整体磁盘使用量
- du：评估文件系统的磁盘使用量（常用在预估目录所占容量）

### df

```bash
df [-ahikHTm] [目录或文件名]
```
- a：列出所有的文件系统，包括系统特有的 /proc 等文件系统
- k：以 KBytes 的容量显示个文件系统
- m：以 MBytes 的容量显示
- h：以人类容易阅读的 GBytes、MBytes、KBytes 等格式自行显示
- H：以 M=1000K 取代 M=1024k 的进位方式
- T：连同该 partition 的 filesystem 名称（例如 xfs）也列出
- i：不用磁盘容量，而已 inode 的数量来显示

实践练习

将系统内所有的 filesystem 列出来

```bash
[mrcode@study ~]$ df
Filesystem              1K-blocks    Used Available Use% Mounted on
devtmpfs                   578464       0    578464   0% /dev
tmpfs                      595476       0    595476   0% /dev/shm
tmpfs                      595476    8660    586816   2% /run
tmpfs                      595476       0    595476   0% /sys/fs/cgroup
/dev/mapper/centos-root  10475520 4795672   5679848  46% /
/dev/mapper/centos-home   5232640   40552   5192088   1% /home
/dev/sda2                 1038336  174108    864228  17% /boot
tmpfs                      119096      12    119084   1% /run/user/42
tmpfs                      119096       0    119096   0% /run/user/1000
# 不加任何选项，会默认将系统内所有的（不含特殊内存内的文件系统与 swap）都以 1 Kbytes 的容量列出来
# /dev/shm 是与内存有关的挂载，可以先忽略
```

- Filesystem：代表该文件系统是在哪个 partition
- 1k-block2：该列下的单位为 1kb，可以利用 -h 或 -m 来改变容量
- Used：已使用掉的磁盘空间
- Available：可用空间
- Use%：磁盘使用率
- Mounted on：磁盘挂载的目录（挂载点）

将容量结果以容易阅读的容量格式显示

```bash
[mrcode@study ~]$ df -h
Filesystem               Size  Used Avail Use% Mounted on
devtmpfs                 565M     0  565M   0% /dev
tmpfs                    582M     0  582M   0% /dev/shm
tmpfs                    582M  8.5M  574M   2% /run
tmpfs                    582M     0  582M   0% /sys/fs/cgroup
/dev/mapper/centos-root   10G  4.6G  5.5G  46% /
/dev/mapper/centos-home  5.0G   40M  5.0G   1% /home
/dev/sda2               1014M  171M  844M  17% /boot
tmpfs                    117M   12K  117M   1% /run/user/42
tmpfs                    117M     0  117M   0% /run/user/1000
```

将系统内的所有特殊文件格式及名称都列出来

```bash
[mrcode@study ~]$ df -aT
Filesystem              Type       1K-blocks    Used Available Use% Mounted on
sysfs                   sysfs              0       0         0    - /sys
proc                    proc               0       0         0    - /proc
devtmpfs                devtmpfs      578464       0    578464   0% /dev
securityfs              securityfs         0       0         0    - /sys/kernel/security
tmpfs                   tmpfs         595476       0    595476   0% /dev/shm

# 这里只是其中一部分，还有很多，几乎上都在内存中，例如 /proc 这个挂载点
# 因此这些特殊的文件系统都不会占用磁盘空间
```

将 /etc/ 下的可用的磁盘容量以易读格式显示

```bash
[mrcode@study ~]$ df -h /etc/
Filesystem               Size  Used Avail Use% Mounted on
/dev/mapper/centos-root   10G  4.6G  5.5G  46% /

# 在 df 后面加上目录或则是文件时，df 会自动分析该目录或文件所在的 partition，
# 并将该 partition 容量显示出来，所以就可以知道该目录下又多少容量可用了
```

将目前各个 partition 当中可用的 inode 数量列出

```bash
[mrcode@study ~]$ df -ih
Filesystem              Inodes IUsed IFree IUse% Mounted on
devtmpfs                  142K   382  141K    1% /dev
tmpfs                     146K     1  146K    1% /dev/shm
tmpfs                     146K   653  145K    1% /run
tmpfs                     146K    16  146K    1% /sys/fs/cgroup
/dev/mapper/centos-root   5.0M  150K  4.9M    3% /
/dev/mapper/centos-home   2.5M   237  2.5M    1% /home
/dev/sda2                 512K   340  512K    1% /boot
tmpfs                     146K     9  146K    1% /run/user/42
tmpfs                     146K     1  146K    1% /run/user/1000

# -i 主要列出可用的 inode 剩余容量与总容量
# 会发现，通常 inode 的数量剩余逗比 block 还要多
```

由于 df 主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要是在 Superblock 内的信息，所以该指令显示结果速度非常快速。
在显示结果中，要特别留意根目录容量，因为我们所有的数据都是由根目录衍生出来的（这里应该说的是，当前这颗磁盘分区，没有额外的挂载，几乎上所有数据都放在了同一个分区上。

另外需要注意的是：如果使用 -a 参数时，系统会出现 /proc 这个挂载点，但是里面的东西
都是 0，不要紧张。 /proc 的东西都是 linux 系统所需要加载的系统数据，
而且是挂载在「内存中」的，所以不会占用磁盘空间

至于 /dev/shm/ 目录，其实是利用内存虚拟出来的磁盘空间，通常是总物理内存的一半。
由于是透过内存仿真出来的磁盘，在该目录下建立任何数据文件时，访问速度非常快。
只是 **该目录下的东西不是持久性的，下次开机后就失效了**

### du

```bash
du [-ahskm] 文件或目录名称
```

- a：列出所有的文件与目录容量，默认仅统计目录下的文件量
- h：以人类易读的容量格式显示
- s：列出总量，而不列出每个各别的目录占用容量
- S：不包括子目录下的总计，与 -s 有差别
- k：以 KBytes 列出容量显示
- m：以 MBytes 列出容量显示

实践练习

```bash
# 列出当前目录下的所有文件容量
[root@study ~]# du
4       ./.cache/dconf
4       ./.cache/abrt
8       ./.cache
4       ./.dbus/session-bus
4       ./.dbus
0       ./.config/abrt
0       ./.config
0       ./.local/share
0       ./.local
56      .
# 不加参数会默认当前目录下的文件与目录所占用的磁盘空间
# 实际显示只显示了目录，不包含文件
# 下面哪个 . 的总量为 56 K(默认是以 kbytes 显示的)，是 目录 + 文件占用的
# 看这里的几个目录加起来肯定没有 56 这么大

# 列出当前目录下所有文件容量（包括文件）
[root@study ~]# du -a
4       ./.bash_logout
4       ./.bash_profile
4       ./.bashrc
4       ./.cshrc
4       ./.tcshrc
4       ./anaconda-ks.cfg  # 省略了很多显示结果，这里就是一个文件
4       ./.cache/dconf/user
56      .

# 检查根目录下每个目录所占用的容量
[root@study ~]# du -sm /*
0       /bin
138     /boot
0       /dev
42      /etc
8       /home
0       /lib
0       /lib64
0       /media
0       /mnt
0       /opt
du: 无法访问"/proc/32240/task/32240/fd/3": 没有那个文件或目录
du: 无法访问"/proc/32240/task/32240/fdinfo/3": 没有那个文件或目录
du: 无法访问"/proc/32240/fd/3": 没有那个文件或目录
du: 无法访问"/proc/32240/fdinfo/3": 没有那个文件或目录
0       /proc       # 不占用空间
1       /root
9       /run
0       /sbin
0       /srv
0       /sys
1       /tmp
4182    /usr      # 可以看到系统初期最大的就是这个了
347     /var
```

与 df 不一样，du 指令会直接到文件系统内搜寻所有的文件数据，所以上述例子显示不是很快，
因为要搜寻文件数据。默认容量为 kb，可使用 -h 等参数来格式化容量

```bash
# -s 与 -s 的区别，看总量
# -s 为 56k 是包含了下面的所有子目录
# -S 不包含子目录的 只有 44k
[root@study ~]# du -sh
56K     .
[root@study ~]# du -Sh
4.0K    ./.cache/dconf
4.0K    ./.cache/abrt
0       ./.cache
4.0K    ./.dbus/session-bus
0       ./.dbus
0       ./.config/abrt
0       ./.config
0       ./.local/share
0       ./.local
44K     .
```

## 实体链接与符号链接 ln
link 链接在前面 Linux 文件属性 与 Linux 文件种类与扩展名 中简单讲解过。本章详细讲解

链接文档有两种：

- 类似 windows 的快捷方式的文件
- 通过 inode 连接来产生新文档名，而不是产生新文件，**称为实体链接**

### Hard Link 实体链接、硬式连结或实际连结

前面文件系统中了解到：

- 每个文件都会占用一个 inode，文件内容由 inode 记录指向
- 想要读取该文件，必须要经过目录记录的文件名来指向到正确的 inode 号码才能读取

也就是说，文件名只与目录有关，但是文件内容则与 inode 有关。
因此有没有可能：多个文档名对应到同一个 inode 号码呢？肯定有，这就是 Hard Link 的由来。

简单说：hard link 只是在某个目录下新增一个文件名链接到某个 inode 号码的关联记录而已

例如：假设 /root/crontab 是 /etc/crontab 的实体链接（他们两个文件名都对应到同一个 inode），
这两个文件名的所有相关信息都会一模一样（除了文件名之外）

```bash
[root@study ~]# ll -i /etc/crontab
# 查看文件属性与 inode 号码
17639161 -rw-r--r--. 1 root root 451 6月  10 2014 /etc/crontab
# 建立实体链接
[root@study ~]# ln /etc/crontab .
# 对比两个文件的属性
[root@study ~]# ll -i /etc/crontab crontab
17639161 -rw-r--r--. 2 root root 451 6月  10 2014 crontab
17639161 -rw-r--r--. 2 root root 451 6月  10 2014 /etc/crontab
```

![](http://p4ui.toweydoc.tech:20080/images/stydocs/markdown-img-paste-20191022221802204.png)

上面原始文件的 1 变成了 2，该字段称为「连结」，表示有多少个文件名链接到这个 inode 号码;

- 这里将任意一个文件删除，其实 inode 与 block 都还是存在的。
- 无论通过哪一个文件来编辑内容，都会反应到 inode 与 block 中

一般来说，使用 hard link 设置连接文件时，磁盘空间与 inode 的数目都不会改变。
除非遇到说，在目录中新增文件名时，刚好 block 满了，那么就会多出来一个 block 记录文件名

限制如下：

- 不能跨 Filesystem ：不是同一个 indoe 号码了，肯定不能了
- 不能 link 目录：

  如果使用 hard link 链接到目录时，链接的数据需要连同被链接目录下所有数据都建立连接。
  当新建文件时需要建立该文件的 hard link，这对环境影响太大，所以不支持

## Symbolic Link 符号链接、快捷方式
Symbolic 就是建立一个独立的文件，而这个文件会让数据的读取指向他 link 的那个文件名。
原始文件被删，该文件肯定也打不开了

```bash
# 建立符号链接
[root@study ~]# ln -s /etc/crontab crontab2
# 对比
[root@study ~]# ll -i /etc/crontab crontab crontab2
17639161 -rw-r--r--. 2 root root 451 6月  10 2014 crontab
17639161 -rw-r--r--. 2 root root 451 6月  10 2014 /etc/crontab
# 可以看到上面两个一模一样，有一个 hard link 和原始文件。并且他们的 inode 是 2
# 而下面这个符号链接的信息和上面的都不一样，唯独后面有一个连接指向了原始文件
25377009 lrwxrwxrwx. 1 root root  12 10月 22 00:00 crontab2 -> /etc/crontab

```

![](http://p4ui.toweydoc.tech:20080/images/stydocs/markdown-img-paste-20191022223136195.png)


```bash
ln [-sf] 来源文件 目标文件

-s：不加参数就是建立实体链接 hard link，加 -s 就是建立符号链接
-f：如果 目标文件 存在时，就主动的将目标文件直接移除后再建立
```

实践练习

```bash
# 将 /etc/passwd 复制到 /tmp 并观察 inode 与 block
[root@study ~]# cd /tmp/
[root@study tmp]# cp -a /etc/passwd .
[root@study tmp]# du -sb; df -i
153266  .   # du -sb 计算 /tmp/ 下有多少 bytes 容量
文件系统                  Inode 已用(I) 可用(I) 已用(I)% 挂载点
/dev/mapper/centos-root 5242880  153177 5089703       3% /
# df -i 显示 inode 的使用量

# 将 /tmp/passwd 制作 hard link 称为 passwd-hd 文件，并观察文件与容量
[root@study tmp]# ln passwd passwd-hd
[root@study tmp]# du -sb; df -i
153266  .
文件系统                  Inode 已用(I) 可用(I) 已用(I)% 挂载点
/dev/mapper/centos-root 5242880  153177 5089703       3% /
# 观察总容量 153266 没有改变
# 观察已用的 inode 153177 没有改变

# 将 /tmp/passwd 建立符号链接
[root@study tmp]# du -sb; df -i
153272  .
文件系统                  Inode 已用(I) 可用(I) 已用(I)% 挂载点
/dev/mapper/centos-root 5242880  153178 5089702       3% /
# 观察总容量 153266 变成了 153272
# 观察已用的 inode 153177 变成了 153178

[root@study tmp]# ls -li passwd*
16797769 -rw-r--r--. 2 root root 2323 10月  4 18:31 passwd
16797769 -rw-r--r--. 2 root root 2323 10月  4 18:31 passwd-hd
16807525 lrwxrwxrwx. 1 root root    6 10月 22 00:20 passwd-so -> passwd
# 可以看到这里的符号链接文件大小 6 kb，而上面 153272 - 153266 = 6

## 删除源文件 passwd ，其他两个链接文件是否能打开？
[root@study tmp]# rm passwd
rm：是否删除普通文件 "passwd"？y
[root@study tmp]# cat passwd-hd
... 正常显示
[root@study tmp]# cat passwd-so
cat: passwd-so: 没有那个文件或目录

# 查看状态
[root@study tmp]# ls -l passwd*
-rw-r--r--. 1 root root 2323 10月  4 18:31 passwd-hd
# 这里后面的文件名在能链接到源文件的时候，会显示绿色，现在链接不到了就会显示红色了
lrwxrwxrwx. 1 root root    6 10月 22 00:20 passwd-so -> passwd

```

![](http://p4ui.toweydoc.tech:20080/images/stydocs/markdown-img-paste-20191022225353742.png)

```bash
# 如果使用下面的命令，将 /bin/ 目录创建了一个符号链接（快捷方式）
ln -s /bin /root/bin
[root@study bin]# ll -l /root/
lrwxrwxrwx. 1 root   root      5 10月 22 00:28 bin -> /bin/

# 那么这个时候如果你要执行下面的命令的话，
# 这里千万不要执行，否则会将 bin 下的文件数据全部干掉的
cd /root/bin; rm .

# 通过下面的方式查看，和硬链接一样，他们都连到了同一个 node
# 所以这里与文件链接还不一样，上面看是单独的目录 -> /bin/
# 这里  cd 通过快捷方式进入到真正的目录下，所以操作等同于操作 bin 本身
[root@study bin]# ls -lid /bin/ /root/bin/
78 dr-xr-xr-x. 2 root root 57344 10月 11 05:03 /bin/
78 dr-xr-xr-x. 2 root root 57344 10月 11 05:03 /root/bin/

# 使用命令删除刚刚那个目录链接文档
# 注意这里的提示。带斜杠貌似是直接指向了连接的目录，不带才是符号链接本身
[root@study bin]# rm /root/bin/
rm: 无法删除"/root/bin/": 是一个目录
[root@study bin]# rm /root/bin
rm：是否删除符号链接 "/root/bin"？y
```

基本上，符号链接的用途比较广。需要掌握

### 关于目录的 link 数量

创建一个目录 link 会显示几？对于文件来说会显示 1.那么目录呢？

```bash
[root@study tmp]# ls -ld /tmp/
# link 数量为 40
drwxrwxrwt. 40 root root 4096 10月 22 00:43 /tmp/
# 创建目录
[root@study tmp]# mkdir testing1
[root@study tmp]# ls -ld /tmp/
# /tmp/ link +1 变成 41 了
drwxrwxrwt. 41 root root 4096 10月 22 00:44 /tmp/

# 看下该目录的 link 为 2，表示有两个,是为什么？
[root@study tmp]# ls -ld /tmp/testing1/
drwxr-xr-x. 2 root root 6 10月 22 00:44 /tmp/testing1/

# 新建立的一个目录下包含了当前目录
# /tmp/testing1/ /temp/testing1/.  这两个路径都链接到同一个 inode，所以 link 为 2
[root@study tmp]# ls -al /tmp/testing1/
总用量 8
drwxr-xr-x.  2 root root    6 10月 22 00:44 .
drwxrwxrwt. 41 root root 4096 10月 22 00:46 ..

```


## 磁盘的分区、格式化、检验与挂载

对于系统管理者（root）而言，磁盘管理是非常重要的一环，尤其是近来磁盘已经渐渐被当成是消耗品了。

想要在系统里面新增一颗磁盘时，应该做的有：

1. 对磁盘进行分区，建立可用的 partition
2. 对该 partition 进行格式化（format），建立系统可用的 filesystem
3. 可选：对刚刚建立好的 filesystem 进行检查
4. 在 linux 系统上，建立挂载点（目录），并将它挂载上来

当然在上述步骤中有很多细致的需要考虑，比如磁盘分区槽（partition）需要多大？是否需要加入 jounal 的功能？inode 与 block 的数量应该如何划分等。

但是这些问题的决定，都需要与你的主机用途来考虑的，因此在本节，讲解几个入门操作，其他的自己去实战了解

##  观察磁盘分区状态

磁盘分区主要有 MBR 和 GPT 两种格式，支持的工具不一样（后续讲解的 parted 都支持），
习惯使用的是 fdisk 、gdisk 来处理分区。

###  lsblk 列出系统上所有磁盘列表

```bash
lsblk [-dfipt] [device]
```

- d：仅列出磁盘本身，并不会列出该磁盘的分区数据
- f：同时列出该磁盘内的文件系统名称
- i：使用 ASCII 的线段输出，不要使用复杂的编码（在某些环境下很有用）
- m：同时输出该装置在 /dev 下的权限数据（rwx）
- p：列出该装置的完整文件名，而不是仅列出最后的名字
- t：列出该磁盘装置的详细数据，包括磁盘队列机制、预读写的数据量大小等

实践练习

列出本系统下的所有磁盘与磁盘内的分区信息

```bash
[mrcode@study ~]$ lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0 40.8G  0 disk 				# 这是一整颗磁盘
├─sda1            8:1    0    2M  0 part
├─sda2            8:2    0    1G  0 part /boot
└─sda3            8:3    0   30G  0 part 				# 在 sda3 内的其他的文件系统
  ├─centos-root 253:0    0   10G  0 lvm  /
  ├─centos-swap 253:1    0    1G  0 lvm  [SWAP]
  └─centos-home 253:2    0    5G  0 lvm  /home
sdb               8:16   0    2G  0 disk
sr0              11:0    1 73.6M  0 rom
```

从输出来看，主要有 sda 、sdb、sr0 装置，而 sda 下面又分了 3 个分区，其中 sda3 还有 LVM 产生的文件系统

- NAME：装置文件名，会省略 /dev 等前导目录
- MAJ:MIN：其实核心认识的装置都是通过这两个代码来熟悉的，分别是：`主要:次要` 装置
- RM：是否为颗拆卸装置（removable device）。如光盘、USB 磁盘等
- SIZE：容量
- RO：是否为只读
- TYPE：磁盘 disk、分区槽 partition、只读存储器 rom
- MOUTPOINT：挂载点

列出 /dev/sda (前面已经说过了，使用虚拟机不同，磁盘里面没有 vda 的，我的是 sda 哦) 装置内的所有数据的完整文件名

```bash
[root@study ~]# lsblk -ip /dev/sda
NAME                        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
/dev/sda                      8:0    0 40.8G  0 disk
|-/dev/sda1                   8:1    0    2M  0 part
|-/dev/sda2                   8:2    0    1G  0 part /boot
`-/dev/sda3                   8:3    0   30G  0 part
  |-/dev/mapper/centos-root 253:0    0   10G  0 lvm  /
  |-/dev/mapper/centos-swap 253:1    0    1G  0 lvm  [SWAP]
  `-/dev/mapper/centos-home 253:2    0    5G  0 lvm  /home
```

### 列出装置的 UUID 等参数

使用 `lsblk -f` 可以列出来 UUID 的数据，不过习惯使用 blkid 来找出装置的 UUID，可以用来作为挂载或则是使用这个装置/文件系统用

```bash
[root@study ~]# lsblk -f
NAME            FSTYPE    LABEL           UUID                                   MOUNTPOINT
sda                                                                              
├─sda1                                                                           
├─sda2          xfs                       13d0663f-4cbd-412d-aa9f-975eb18da590   /boot
└─sda3          LVM2_memb                 cksKYp-dPYj-CCPQ-Qxpq-m6rE-bhcL-84NkM3
  ├─centos-root xfs                       7b220a88-4e13-4869-9aa9-87031303f3e1   /
  ├─centos-swap swap                      0576b616-9606-434b-91c6-b99cbba5597d   [SWAP]
  └─centos-home xfs                       d475b892-bcde-4c97-99da-497f3ff7163c   /home
sdb                                                                              
sr0             iso9660   VBox_GAs_6.0.10 2019-07-12-09-13-14-35   

# 显示格式不一样，还多了分区的 UUID，感觉上面的少了一个 dsa1 的呢？
[root@study ~]# blkid
/dev/sda1: PARTUUID="bf674a46-65e1-43b1-a348-ac2c06c25293"
/dev/sda2: UUID="13d0663f-4cbd-412d-aa9f-975eb18da590" TYPE="xfs" PARTUUID="783703d8-96cb-48fa-bfdb-853e7a0b1581"
/dev/sda3: UUID="cksKYp-dPYj-CCPQ-Qxpq-m6rE-bhcL-84NkM3" TYPE="LVM2_member" PARTUUID="cb3c0557-b7a5-493c-bab0-250a62a11099"
/dev/sr0: UUID="2019-07-12-09-13-14-35" LABEL="VBox_GAs_6.0.10" TYPE="iso9660"
/dev/mapper/centos-root: UUID="7b220a88-4e13-4869-9aa9-87031303f3e1" TYPE="xfs"
/dev/mapper/centos-swap: UUID="0576b616-9606-434b-91c6-b99cbba5597d" TYPE="swap"
/dev/mapper/centos-home: UUID="d475b892-bcde-4c97-99da-497f3ff7163c" TYPE="xfs"
```

### parted 列出磁盘的分区表类型与分区信息

```bash
# 语法：parted device_name print
[root@study ~]# parted /dev/sda print
Model: ATA VBOX HARDDISK (scsi)										# 磁盘模块名称（厂商）
Disk /dev/sda: 43.8GB															# 磁盘的总容量
Sector size (logical/physical): 512B/512B					# 磁盘的每个逻辑/物理扇区容量
Partition Table: gpt						# 分区格式
Disk Flags: pmbr_boot

# 下面是分区信息
Number  Start   End     Size    File system  Name  标志
 1      1049kB  3146kB  2097kB                     bios_grub
 2      3146kB  1077MB  1074MB  xfs
 3      1077MB  33.3GB  32.2GB                     lvm

```

## 磁盘分区：gdisk、fdisk

- MBR：使用 fdisk 分区
- GPT：使用 gdisk 分区

两个工具使用相似，通过内部的说明来操作，不需要死记硬背。刚刚通过 parted 指令输出的结果得知 sda 这个磁盘是 GPT 分区，所以下面的使用 gdisk 来操作

### gdisk

语法很简单

```bash
gdisk 装置名称
```

例：观察 /dev/sda 磁盘的分区与相关数据

```bash
[root@study ~]# gdisk /dev/sda
GPT fdisk (gdisk) version 0.8.10

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present
# 找到了 GPT 的分区表
Found valid GPT with protective MBR; using GPT.

Command (? for help): ?  # 等待你输入指令，可以输入问号显示说明
b       back up GPT data to a file
c       change a partition's name
d       delete a partition		# 删除分区
i       show detailed information on a partition
l       list known partition types
n       add a new partition		# 增加分区
o       create a new empty GUID partition table (GPT)
p       print the partition table # 打印分区表（常用）
q       quit without saving changes # 不存储分区就直接离开 gdisk
r       recovery and transformation options (experts only)
s       sort partitions
t       change a partition's type code
v       verify disk
w       write table to disk and exit	# 存储分区操作后离开 gdisk
x       extra functionality (experts only)
?       print this menu

```

再来回顾下步骤：

1. 使用 lsblk 或 blkid 找到磁盘
2. 使用 parted /dev/xxx print 来找出内部的分表表类型
3. 使用 gdisk 或 fdisk 来操作

通过上面的帮助，有两个重要信息：指令 q 和 w，在 gdisk 里面执行的操作，**只有使用这两个指令后才会生效**，
使用 q 退出不生效，使用 w 生效并离开。

```bash
Command (? for help): p		# 输出目前磁盘的状态
Disk /dev/sda: 85491712 sectors, 40.8 GiB				# 磁盘文件名、扇区数量、总容量
Logical sector size: 512 bytes									# 单一扇区大小为 512 bytes
Disk identifier (GUID): 67038DBF-B66A-4D0F-92B2-BFBF0744CD1D	# 磁盘的 GPT标识符
Partition table holds up to 128 entries
First usable sector is 34, last usable sector is 85491678
Partitions will be aligned on 2048-sector boundaries
Total free space is 20467645 sectors (9.8 GiB)

# 下面是分区信息
# 分区编号 开始扇区号码			 结束扇区号码    容量大小
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048            6143   2.0 MiB     EF02  
   2            6144         2103295   1024.0 MiB  0700  
   3         2103296        65026047   30.0 GiB    8E00
# 这里的 Code linux 为 8300，swap 为 8200，不过只是一个提示，不见得真的代表此分区槽内的文件系统
```

从上表可以发现几件事情：

- 整颗磁盘还可以进行额外的分区

  最大扇区为 85491712 个，下面三个分区表（第三个）结束扇区为 65026047，
  在上面信息中也提示了空闲的扇区 `20467645 sectors (9.8 GiB)`

- 分区槽的设计中，新分区通常选用上一个分区的结束扇区号码数加 1 作为起始扇区号码

::: warning
注意不要在 MBR 分区上使用 gdisk，如果指令按错，恐怕分区记录会挂掉，
另外在 gdisk 中操作，离开的时候记得按 q ，不要按 w 就不会生效
:::

### 用 gdisk 新增分区槽

最开始安装的时候就预留了一块容量来做练习，在上面也看到了还剩余 9.8 G 的空余容量，假设有如下的分区需求：

- 1 GB 的 xfs 文件系统（linux）
- 1 GB 的 vfat 文件系统（windows）
- 0.5 GB 的 swap （linux swap）

```bash
[root@study ~]# gdisk /dev/sda
Command (? for help): p
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048            6143   2.0 MiB     EF02  
   2            6144         2103295   1024.0 MiB  0700  
   3         2103296        65026047   30.0 GiB    8E00
# 打印分区信息，主要目的是为了找到最后一个 sector 的号码，这里是 65026047
# 使用指令 n 增加物理分区
Command (? for help): n
Partition number (4-128, default 4): 4  # 分区号码，这里默认就是 4，所以可以直接按回车
First sector (34-85491678, default = 65026048) or {+-}size{KMGTP}: # 第一个扇区号码，同样有默认的
Last sector (65026048-85491678, default = 85491678) or {+-}size{KMGTP}: +1G  # 结束扇区号码
# 上面有默认的值，不需要我们自己计算扇区数量，使用 +- KMGTP 等单位容量方式来容量

# 选择未来该分区槽预计使用的文件系统，预设的都是 linux 文件系统的 8300
Current type is 'Linux filesystem'
Hex code or GUID (L to show codes, Enter = 8300):
Changed type of partition to 'Linux filesystem'

# 再次打印，就发现多了刚刚分出来的分区信息
Command (? for help): p
Disk /dev/sda: 85491712 sectors, 40.8 GiB
Logical sector size: 512 bytes
Disk identifier (GUID): 67038DBF-B66A-4D0F-92B2-BFBF0744CD1D
Partition table holds up to 128 entries
First usable sector is 34, last usable sector is 85491678
Partitions will be aligned on 2048-sector boundaries
Total free space is 18370493 sectors (8.8 GiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048            6143   2.0 MiB     EF02  
   2            6144         2103295   1024.0 MiB  0700  
   3         2103296        65026047   30.0 GiB    8E00  
   4        65026048        67123199   1024.0 MiB  8300  Linux filesystem

那么后面两个区的分区继续，记得每次分区完就打印下信息，查看是否正确

Command (? for help): n
Partition number (5-128, default 5):
First sector (34-85491678, default = 67123200) or {+-}size{KMGTP}:
Last sector (67123200-85491678, default = 85491678) or {+-}size{KMGTP}: +1G
Current type is 'Linux filesystem'
Hex code or GUID (L to show codes, Enter = 8300): 0700  # 0700 为 windows 文件系统
Changed type of partition to 'Microsoft basic data'

Command (? for help): n
Partition number (6-128, default 6):
First sector (34-85491678, default = 69220352) or {+-}size{KMGTP}:
Last sector (69220352-85491678, default = 85491678) or {+-}size{KMGTP}: +500M
Current type is 'Linux filesystem'
Hex code or GUID (L to show codes, Enter = 8300): 8200  # linux swap
Changed type of partition to 'Linux swap'

# 最后分区完成后的分区信息如下
Command (? for help): n
...
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048            6143   2.0 MiB     EF02  
   2            6144         2103295   1024.0 MiB  0700  
   3         2103296        65026047   30.0 GiB    8E00  
   4        65026048        67123199   1024.0 MiB  8300  Linux filesystem
   5        67123200        69220351   1024.0 MiB  0700  Microsoft basic data
   6        69220352        70244351   500.0 MiB   8200  Linux swap

# 分区的时候需要使用到 code，上面有对应的 code 数值了
# 如果忘记或则不知道，可以使用 l 命令来显示所有的 code 值
Command (? for help): l
0700 Microsoft basic data  0c01 Microsoft reserved    2700 Windows RE          
3000 ONIE boot             3001 ONIE config           4100 PowerPC PReP boot  
...

# 最后使用 w 命令写入磁盘分区表
Command (? for help): w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? (Y/N): y
OK; writing new GUID partition table (GPT) to /dev/sda.
Warning: The kernel is still using the old partition table.
The new table will be used at the next reboot.
The operation has completed successfully.

# 等你输入 y 确认之后，开始执行，上面的警告信息翻译如下
警告：内核仍在使用旧的分区表。
新表将在下次重新启动时使用。
操作已成功完成。

# 查看信息，发现分区中还没有出现 sda4、5、6 ，这是因为核心还没有更新
[root@study ~]# cat /proc/partitions
major minor  #blocks  name

   8        0   42745856 sda
   8        1       2048 sda1
   8        2    1048576 sda2
   8        3   31461376 sda3
   8       16    2097152 sdb
  11        0      75354 sr0
 253        0   10485760 dm-0
 253        1    1048576 dm-1
 253        2    5242880 dm-2
```

对于警告内核未生效，我们有两种方式来处理，第一种就是重新启动，另一种就是通过 partprobe 指令来处理



### partprobe 更新 Linux 核心的分区表信息

```bash
# -s 输出信息，不加则不会输出任何信息
[root@study ~]# partprobe -s
/dev/sda: gpt partitions 1 2 3 4 5 6
Warning: 无法以读写方式打开 /dev/sr0 (只读文件系统)。/dev/sr0 已按照只读方式打开。

# 查看磁盘状态，发现出现了 4、5、6 分区
[root@study ~]# lsblk /dev/sda
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0 40.8G  0 disk 
├─sda1            8:1    0    2M  0 part 
├─sda2            8:2    0    1G  0 part /boot
├─sda3            8:3    0   30G  0 part 
│ ├─centos-root 253:0    0   10G  0 lvm  /
│ ├─centos-swap 253:1    0    1G  0 lvm  [SWAP]
│ └─centos-home 253:2    0    5G  0 lvm  /home
├─sda4            8:4    0    1G  0 part 
├─sda5            8:5    0    1G  0 part 
└─sda6            8:6    0  500M  0 part 

# 查看分区记录，也出现了 4、5、6
[root@study ~]# cat /proc/partitions 
major minor  #blocks  name

   8        0   42745856 sda
   8        1       2048 sda1
   8        2    1048576 sda2
   8        3   31461376 sda3
   8        4    1048576 sda4
   8        5    1048576 sda5
   8        6     512000 sda6
   8       16    2097152 sdb
  11        0      75354 sr0
 253        0   10485760 dm-0
 253        1    1048576 dm-1
 253        2    5242880 dm-2

```

### 用 gdisk 删除一个分区槽

```bash
[root@study ~]# gdisk /dev/sda
GPT fdisk (gdisk) version 0.8.10

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.

# 查看分区信息
Command (? for help): p
Disk /dev/sda: 85491712 sectors, 40.8 GiB
Logical sector size: 512 bytes
Disk identifier (GUID): 67038DBF-B66A-4D0F-92B2-BFBF0744CD1D
Partition table holds up to 128 entries
First usable sector is 34, last usable sector is 85491678
Partitions will be aligned on 2048-sector boundaries
Total free space is 15249341 sectors (7.3 GiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048            6143   2.0 MiB     EF02  
   2            6144         2103295   1024.0 MiB  0700  
   3         2103296        65026047   30.0 GiB    8E00  
   4        65026048        67123199   1024.0 MiB  8300  Linux filesystem
   5        67123200        69220351   1024.0 MiB  0700  Microsoft basic data
   6        69220352        70244351   500.0 MiB   8200  Linux swap

# 删除第 6 个分区
Command (? for help): d
Partition number (1-6): 6

# 再次查看，发现 6 不在了
Command (? for help): p
Disk /dev/sda: 85491712 sectors, 40.8 GiB
Logical sector size: 512 bytes
Disk identifier (GUID): 67038DBF-B66A-4D0F-92B2-BFBF0744CD1D
Partition table holds up to 128 entries
First usable sector is 34, last usable sector is 85491678
Partitions will be aligned on 2048-sector boundaries
Total free space is 16273341 sectors (7.8 GiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048            6143   2.0 MiB     EF02  
   2            6144         2103295   1024.0 MiB  0700  
   3         2103296        65026047   30.0 GiB    8E00  
   4        65026048        67123199   1024.0 MiB  8300  Linux filesystem
   5        67123200        69220351   1024.0 MiB  0700  Microsoft basic data

# 写入并离开
Command (? for help): w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? (Y/N): y
OK; writing new GUID partition table (GPT) to /dev/sda.
Warning: The kernel is still using the old partition table.
The new table will be used at the next reboot.
The operation has completed successfully.

# 查看磁盘状态，发现 sda6 还存在，只是因为没有更新核心分区表导致的
# 使用命令 partprobe -s 更新下再查看就没有了
[root@study ~]# lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0 40.8G  0 disk 
├─sda1            8:1    0    2M  0 part 
├─sda2            8:2    0    1G  0 part /boot
├─sda3            8:3    0   30G  0 part 
│ ├─centos-root 253:0    0   10G  0 lvm  /
│ ├─centos-swap 253:1    0    1G  0 lvm  [SWAP]
│ └─centos-home 253:2    0    5G  0 lvm  /home
├─sda4            8:4    0    1G  0 part 
├─sda5            8:5    0    1G  0 part 
└─sda6            8:6    0  500M  0 part 
sdb               8:16   0    2G  0 disk 
sr0              11:0    1 73.6M  0 rom  

```

需要注意的是：不要去处理一个 **正在使用中的分区槽** 。例如：现在已经使用了 /dev/sda5，
必须先将 /dev/sda5 先 **卸载** ，否则直接删除该分区的话，虽然磁盘会写入正确的分区信息，
但是核心会无法更新分区表的信息。

总之：千万不要处理正在活动的文件系统，先卸载后再处理

### fdisk

虽然 MBR 在未来可能会慢慢淘汰，但是如果恰巧你遇到了呢，使用方式与 gdisk 类似，下面列出指令帮助文档

![image-20191027131011438](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20191027131011438.png)

##  磁盘格式化（建立文件系统）

分区完成之后需要进行格式化才能使用磁盘，可以使用指令「make filesystem，mkfs」，该指令是一个综合指令，回去调用正确的系统格式化工具软件。因为 CentOS 7 使用 xfs 作为预设文件系统，下面先介绍 mkfs.xfs ，再介绍新一代的 mkfs.ext4，最后再聊 mkfs 这个综合指令

### XFS 文件系统 mkfs.xfs

常听到的格式化其实应该称为「建立文件系统（make filesystem）」。

```bash
mkfs.xfs [-b bsize][-d parms][-i parms][-l parms][-L parms][-f][-r parms] 设备名称
```

选项与参数：下面描述关于单位的说明，没有加单位则为 bytes，可以用 k、m、g、t、p 等来解释，特殊的为 s 单位，指的是 sector 的个数

- b：后面接 block 容量，可由 512 到 64k，不过最大容量限制为 Linux 的 4k

- d：后面接 data section 的相关参数，主要的值有：

  - agcount=数值：设置需要几个存储群组（AG），通常与 CPU 有关

  - agsize=数值：每个 AG 设置为多少容量，通常 agcount/agsize 只选一个设置即可

  - file：格式的的装置是个文件而不是个装置（例如虚拟磁盘）

  - size=数值：data section 的数量，你可不将全部的容量用完的意思

  - su=数值：当有 RAID 时，哪个 stripe 数值，与下面的 sw 搭配使用

  - sw=数值：当有 RAID 时，用于存储的磁盘数量（需扣除备份碟与备用碟）

  - sunit-数值：与 su 类型，不过单位使用的是「几个 sector（512bytes大小）」

  - swidth=数值：su*sw 的值，但是以「几个 sector*（512bytes 大小）」来设置

- f：如果装置内已经有文件系统，则需要使用该参数来强制格式化

- i：与 inode 有较相关的设置，主要的设置值有：

  - size=数值：最小是 256bytes，最大是 2k，一般保留 256 足够使用了
  - internal=[0|1]：log 装置是否为内建？预设为 1 内建，如果需要使用外置的，配置下面的参数
  - logdev=device：指定 log 装置在哪个装置上
  - size=数值：指定这块登录区的容量，通常最小需要  512 个 block，大约 2M 以上

- L：指定该文件系统的表头名称 Label name

- r：指定 realtime section 的相关设置，常见的有

  - extsize=数值：就是那个重要的 extent 数值，一般不需要设置，担忧 RAID 时，最好设置与 swidth 相同的数值，最小为 4k ，最大为 1G

实践练习

```bash
# 将前面分区出来的 /dev/sda4 格式化为 xfs 文件系统
[root@study ~]# mkfs.xfs /dev/sda4
meta-data=/dev/sda4              isize=512    agcount=4, agsize=65536 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=262144, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
# 很快就格式化完成了，不加任何参数使用的是默认值，较重要的是 inode 与 block 的数值
# isize 就是 inode的大小，bsize 就是 block 的大小

# 查看信息，确定为 xfs 了
[root@study ~]# blkid /dev/sda4
/dev/sda4: UUID="4079b244-7ef8-47eb-85d0-1d634c8c703f" TYPE="xfs" PARTLABEL="Linux filesystem" PARTUUID="3819b115-2ab8-4fb6-8425-bb2ff8e797b7" 
```

一般使用默认的 xfs 文件系统参数来格式化即可，如果有其他额外的定制则需要添加对应的参数来设置。比如：因为 xfs 可以使用多个数据流来读写系统，增加速度，因此哪个 agcount 可以跟 CPU 的核心数量来做搭配。比如服务器有一颗 4 核心 8 线程的 CPU，其实就相当于是 8 核心了，可以设置为 8

```bash
# 找出系统的 CPU 数量，并设置 agcount 数量
[root@study ~]# grep 'processor' /proc/cpuinfo
processor       : 0
# 这里只有一个 processor，则表示只有一颗 CPU

# 使用 -f （前面已经格式化有文件系统了，强制）-d 指定 agcount 数值
[root@study ~]# mkfs.xfs -f -d agcount=1 /dev/sda4
meta-data=/dev/sda4              isize=512    agcount=1, agsize=262144 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=262144, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
# 不过：笔者发现，默认的 agcount=4 而不是按照 cpu 数量来的

```

### XFS 文件系统 for RAID 效能优化（Optional）

在后续会谈到「进阶文件系统的设置」，其中就有磁盘阵列，是多颗磁盘组成一颗大磁盘的意思，利用同步写入到这些磁盘的技术，不但可以加快读写速度，还可以让某一颗磁盘坏掉时，整个文件系统还是开源持续运作的状态，这就是所谓的容错

基本上，磁盘阵列 RAID 就是通过将文件先细分为数个小型的分区区块（stripe）后，将他们分别放到磁盘阵列里面的所有磁盘，所以一个文件是被同时写入到多个磁盘中去的（这也是为什么磁盘阵列高效读取的原因之一）。为了文件数据的安全，在这些磁盘中还会规划处一部分作为备份磁盘（parity disk），以及可能会保留一个以上的备用磁盘（spare disk），这些区块基本上会占用掉磁盘阵列的总容量，但是对于数据来说比较有保障

分区区块 stripe 的数值大多介于 4k 到 1m 之间，这与你的磁盘阵列卡支持的项目有关。stripe 与你的文件数据容量以及效能相关性较高。当用于大型文件时，一般建议 stripe 可以设置大一点，这样磁盘阵列读写频率会降低，效能会提升。如果是用于系统，那么小文件比较多的情况下，stripe 建议大约在 64K 左右可能会更好。不过，这些参数最好经过测试之后看是否能达到预期效果再调整。更详细的信息在后续再讲解

「磁盘阵列章节」在后续学完，再回过头来看该章节。

文件系统的读写要能够有优化，最好能够搭配磁盘阵列的参数来设计；提前先在文件系统就将 stripe 规划好，哪交给 RAID 去存取时，它就无需重复进行文件的 stripe 过程，效能会更好，在格式化时，优化效能与哪些有关系呢？下面模拟一个环境：

- CPU 2 核心，所以设置 agcount 为 2
- 当初设置 RAID 的 stripe 指定为 256k ，因此 su 最好设置为 256k
- 设置的磁盘阵列有 8 颗，因为是 RAID5 的设置，所以有一个 parity（备份碟）因此指定 sw 为 7
- 由上述数据可以发现数据宽度 swidth 应该为 256k * 7 = 1792k，可以设置 extsize 为 1792k

这里仅快速的使用 mkfs.xfs 的参数来处理格式化动作（相关磁盘阵列要求的数量等，请自行百度）

```bash
[root@study ~]# mkfs.xfs -f -d agcount=2,su=256k,sw=7 -r extsize=1792k /dev/sda4
meta-data=/dev/sda4              isize=512    agcount=2, agsize=131072 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=262144, imaxpct=25
         =                       sunit=64     swidth=448 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=64 blks, lazy-count=1
realtime =none                   extsz=1835008 blocks=0, rtextents=0
# 关注 agcount、sunit、swidth、extsz 的值
```

从输出结果来看，agcount 没有问题

- agcount：没有问题
- sunit：64 个 block，64 * 4096（单个block 容量）=256K（也就是 su 的数值）
- swidth：448 * 4k = 1792k（extsize 的数值）

如果 sunit 与 swidth 直接套用在 mkfs.xfs 中的话，就需要注意了，因为指令中的这两个参数用的是「几个 512bytes 的 sector 数量

- sunit：256k/(512byte*1024)=512 个 sector 
- Swidth：7 个磁盘 * sunit = 7 * 512 = 3584 个 sector

所以指令就需要变成下面这样了

```bash
mkfs.xfs -f -d agcount=2,sunit=512,swidth=3584 -r extsize=1792k /dev/sda4
```

### EXT4 文件系统 mkfs.ext4

```bash
mkfs.ext4 [-b size][-L label] 装置名称

- b：设置 block 的大小，有 1k、2k、4k 的容量
- L：装置表头名称
```

实践练习

```bash
# 将 /dev/sda5 格式化为 ext4 文件系统
[root@study ~]# mkfs.ext4 /dev/sda5
mke2fs 1.42.9 (28-Dec-2013)
文件系统标签=
OS type: Linux
块大小=4096 (log=2)		# 每一个 block 大小
分块大小=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks	# 与 RAID 相关性较高
65536 inodes, 262144 blocks		# 总计 inode、block 数量
13107 blocks (5.00%) reserved for the super user
第一个数据块=0
Maximum filesystem blocks=268435456
8 block groups		# 共有 8 个 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376

Allocating group tables: 完成                            
正在写入inode表: 完成                            
Creating journal (8192 blocks): 完成
Writing superblocks and filesystem accounting information: 完成

[root@study ~]# dumpe2fs -h /dev/sda5
dumpe2fs 1.42.9 (28-Dec-2013)
Filesystem volume name:   <none>
Last mounted on:          <not available>
Filesystem UUID:          939ac781-62e4-48a9-a4c5-d804e0f0ee52
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize
Filesystem flags:         signed_directory_hash 
Default mount options:    user_xattr acl
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              65536
Block count:              262144
Reserved block count:     13107
Free blocks:              249189
Free blocks:              249189
Free inodes:              65525
First block:              0
Block size:               4096
Fragment size:            4096
Group descriptor size:    64
Reserved GDT blocks:      127
Blocks per group:         32768
Fragments per group:      32768
Inodes per group:         8192
Inode blocks per group:   512
Flex block group size:    16
Filesystem created:       Tue Oct 22 08:51:57 2019
Last mount time:          n/a
Last write time:          Tue Oct 22 08:51:57 2019
Mount count:              0
Maximum mount count:      -1
Last checked:             Tue Oct 22 08:51:57 2019
Check interval:           0 (<none>)
Lifetime writes:          33 MB
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:               256
Required extra isize:     28
Desired extra isize:      28
Journal inode:            8
Default directory hash:   half_md4
Directory Hash Seed:      9f6434c1-738d-47e2-ae2c-bc766c2198cd
Journal backup:           inode blocks
Journal features:         (none)
日志大小:             32M
Journal length:           8192
Journal sequence:         0x00000001
Journal start:            0

```

这里之后了之前讲解过的 [dumpe2fs](./01.md#dumpe2fs-查询-ext-家族-superblock-信息的指令) 命令，这里就能再回过头去练习了

### 其他文件系统 mkfs

mkfs 是一个综合指令，当使用 `mkfs -t xfs` 指令时，其实会去找 mkfs.xfs 相关参数给我们使用。如果还想知道该命令支持哪些文件系统格式，可以使用 tab 的补全来显示

```bash
[root@study ~]# mkfs [tab*2]
mkfs         mkfs.cramfs  mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.xfs
mkfs.btrfs   mkfs.ext2    mkfs.ext4    mkfs.minix   mkfs.vfat 

# 这里看到这么多的支持格式，如果将刚才的 /dev/sda5 格式化为 vfat 可以这样做
[root@study ~]# mkfs -t vfat /dev/sda5 
mkfs.fat 3.0.20 (12 Jun 2013)
[root@study ~]# blkid /dev/sda5
/dev/sda5: UUID="4DA6-A982" TYPE="vfat" PARTLABEL="Microsoft basic data" PARTUUID="9cffc784-99a3-40f6-8e5f-0c71b3bb7f05" 
```

## 文件系统检验

当文件系统出现问题是，如硬件、软件、硬件等问题等宕机时。现在我们知道文件系统运作时会有磁盘与内存数据异步的状况发生，因此在宕机时可能导致文件系统的错乱。

不同的文件系统救援的指令不太一样，这里主要针对 xfs、ext4 两个主流的来讲解

### xfs_repair 处理 XFS 文件系统

当有 xfs 文件系统错乱才需要使用该命令

```bash
xfs_repair [-fnd] 装置名

- f：后面的装置是个文件（如虚拟硬盘）而不是实体状态
- n：单纯检查并不修改文件系统的任何数据
- d：通常用在单人维护模式下，针对根目录进行检查与修复的动作，很危险！不要随便使用
```

实践练习

``` bash
检查 /dev/sda4 的文件系统
[root@study ~]# xfs_repair /dev/sda4
Phase 1 - find and verify superblock...
Phase 2 - using internal log
        - zero log...
        - scan filesystem freespace and inode maps...
        - found root inode chunk
Phase 3 - for each AG...
        - scan and clear agi unlinked lists...
        - process known inodes and perform inode discovery...
        - agno = 0
        - agno = 1
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
        - agno = 0
        - agno = 1
Phase 5 - rebuild AG headers and trees...
        - reset superblock...
Phase 6 - check inode connectivity...
        - resetting contents of realtime bitmap and summary inodes
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify and correct link counts...
done
# 共有 7 个重要的检查流程，详细的流程介绍可以 man xfs_repair 查看

# 检查下系统原本就有的 /dev/centos/home 文件系统
[root@study ~]# xfs_repair /dev/centos/home 
xfs_repair: /dev/centos/home contains a mounted filesystem
xfs_repair: /dev/centos/home contains a mounted and writable filesystem

fatal error -- couldn't initialize XFS library

```

xfs_repair 可以检查或修复文件系统，因为修复工作是个很庞大的任务，不允许已挂载的文件系统，所以上面会提示 `xfs_repair /dev/centos/home` 是一个已挂载的文件系统（需要卸载后再处理）。

Linux 系统还有个根目录装置无法被卸载，要对根目录救援怎么办？这个就是单人救援模式来处理了，使用参数 `-d` 进入。记得很危险这个指令！

### fsck.ext4 处理 ext4 文件系统

```bash
fsck.ext4 [-pf][-b superblock] 装置名称
```

选项与参数：

- p：当文件系统在修复时，若有需要回复 y 的动作时，自动回复 y 来继续进行修复动作
- f：强制检查。一般来说，如果 fsck 没有发现任何 unclean 的旗标，不会主动进入细部检查的，可以通过 -f 参数强制检查
- D：针对该文件系统下的目录进行优化配置
- b：后面接 superblock 的位置。一般来说该选项用不到，但是如果 superblock 因故损坏时，通过该参数即可利用文件系统内备份的 superblock 来尝试救援。一般来说 superblock 备份在： 1k block 放在 8193、2k block 放在16384、4k block 放在 32786

实践练习

```bash
# 找出刚刚建立的 /dev/sda5 的另一块 superblock，并检查它
# 发现报错了，这个是前面练习格式化成非 ext 系统了，这里需要格式化回来
[root@study ~]# dumpe2fs -h /dev/sda5 | grep 'Blocks per group'
dumpe2fs 1.42.9 (28-Dec-2013)
dumpe2fs: Bad magic number in super-block 当尝试打开 /dev/sda5 时
# 格式回 ext4
[root@study ~]# mkfs.ext4 /dev/sda5
[root@study ~]# dumpe2fs -h /dev/sda5 | grep 'Blocks per group'
dumpe2fs 1.42.9 (28-Dec-2013)
Blocks per group:         32768
# 看起来每个 block 群组会有 32768 个 block，因此第二个 superblock 应该就在 32768 上
# 因为 block 号码为 0 号开始

[root@study ~]# fsck.ext4 -b 32768 /dev/sda5
e2fsck 1.42.9 (28-Dec-2013)
/dev/sda5 was not cleanly unmounted, 强制检查.
第一步: 检查inode,块,和大小
删除 inode 1577 has zero dtime.  处理<y>? 是
第二步: 检查目录结构
第3步: 检查目录连接性
Pass 4: Checking reference counts
第5步: 检查簇概要信息

/dev/sda5: ***** 文件系统已修改 *****  # 文件系统被修改过，所以出现了警告
/dev/sda5: 11/65536 files (0.0% non-contiguous), 12955/262144 blocks

# 如果没有检查到问题，则不会强制检查
[root@study ~]# fsck.ext4 /dev/sda5
e2fsck 1.42.9 (28-Dec-2013)
/dev/sda5: clean, 11/65536 files, 12955/262144 blocks
# -f 参数强制检查
[root@study ~]# fsck.ext4 -f /dev/sda5
e2fsck 1.42.9 (28-Dec-2013)
第一步: 检查inode,块,和大小
第二步: 检查目录结构
第3步: 检查目录连接性
Pass 4: Checking reference counts
第5步: 检查簇概要信息
/dev/sda5: 11/65536 files (0.0% non-contiguous), 12955/262144 blocks

```

xfs_repair s或 fsck.ext4 都是用来检查与修正文件系统错误的指令。注意：通常只有身为 root 且你的文件系统有问题的时候才使用该指令，正常情况下不要使用，可能会造成对系统的危害。通常使用的时候，都是系统出现了极大的问题，导致在 linux 开机的时候得进入单人单机模式下进行维护的行为时，才必须使用此指令

另外，如果怀疑刚格式化的磁盘有问题，也可以使用这些指令来检查，此外这些指令在扫描磁盘时，可能会造成部分 filesystem 的修订，所以：执行 xfs_repair、fsck.ext4 时，被检查的 partition 不能挂载到系统上，需要先卸载



## 文件系统挂载与卸载

前面提到过挂载点是目录，目录是进入磁盘分区槽（其实是文件系统）的入口。在挂载前需要确定几件事情：

- 单一文件系统不应该被重复挂载在不同的挂载点（目录）中

- 单一目录不应该重复挂载多个文件系统

- 要作为挂载点的目录，理论上都是空目录才是

  如果不是空目录，挂载之后，原来目录下的内容会暂时消失，等待分区被卸载之后才会显示出来

在 linux 系统上需要使用 mount 指令，该指令很难，这里简单学一点

```bash
mount -a
mount [-l]
mount [-t 文件系统] LABEL='' 挂载点
mount [-t 文件系统] UUID='' 挂载点
mount [-t 文件系统] 装置文件名='' 挂载点
```

选项与参数：

- a：按照配置文件 /etc/fstab 的数据将所有未挂载的磁盘都挂载上来
- l：单纯的输入 mount 会显示目前挂载的信息。加上 -l 可增列 Label 名称
- t：可以加上文件系统种类来指定欲挂载的类型。常见的 Linux 支持类型有
  - xfs
  - ext3
  - ext4
  - reiserfs
  - vfat
  - Iso9660（光盘格式）
  - nfs（网络文件系统类型）
  - cifs（网络文件系统类型）
  - smbfs（网络文件系统类型）
- o：后面可以接一些挂载时额外加上的参数，例如账户、密码、读写权限等
  - async、sync：此文件系统是否使用同步写入（sync）或异步（async）的内存机制，请参考文件系统运作方式。预设为 async
  - atime、noatime：是否修订文件的读取时间（atime），为了效能，某些时刻刻使用 noatime
  - ro、rw：挂载文件系统位只读（ro）或可擦写（rw）
  - auto、noauto：允许此 filesystem 被 以 mount -a 自动挂载（auto）
  - dev、nodev：是否允许此 filesystem 上，可建立装置文件？dev 为允许
  - suid、nosuid：是否允许此 filesystem 含有 suid、sgid 的文件格式
  - exec、noexec：是否允许此 filesystem 上拥有可执行 binary 文件
  - user、nouser：是否允许此 filesystem 让任何使用者执行 mount ？一般来说 mount 仅有 root 可以进行，但下达 user 参数则可以让一般 user 也能够对此 partition 进行 mount
  - defaults：默认值为 rw、suid、dev、exec、auto、nouser、async
  - remount：重新挂载，这在系统除错或重新更新参数时，很有用

基本上 CentOS 7 不需要加上 -t 这个选项，系统会自动分析使用的是什么文件系统格式，这也是使用 blkid 就能够显示正确的文件系统的缘故。

那么 centos 是怎么找出文件系统类型的呢？由于文件系统几乎都有 superblock ，可以通过分析 superblock 搭配 linux 自己的驱动程序去测试挂载，如果成功了，就like自动的使用该类型的文件系统挂载起来。那么可以主要在以下两个文件中找到有哪些 filesystem 支持上述的挂载测试

- /etc/filesystems：系统指定的测试挂载文件系统类型的优先级
- /proc/filesystems：linux 系统已经加载的文件系统类型

可以在 `/lib/modules/$(uname -r)/kernel/fs/` 目录中找到相关文件系统类型的驱动程序，比如 ext4 的驱动在 `/lib/modules/$(uname -r)/kernel/fs/ext4/` 目录下

注：`$(uname -r)`括号中的指令可以执行的，使用这种占位来引用指令输出的结果

另外，过去都习惯使用装置文件名然后直接用该文件名来挂载，不过这里推荐使用 UUID 来识别文件系统，因为是独一无二的，很可靠



### 挂载 xfs/ext4/vfat 等文件系统

```bash
# 先找出 uuid，使用 uuid 来挂载文件系统到 /data/xfs 内
[root@study fs]# blkid /dev/sda4
/dev/sda4: UUID="819c0c18-8d4a-4c3f-9a98-0ab039e769f5" TYPE="xfs" PARTLABEL="Linux filesystem" PARTUUID="3819b115-2ab8-4fb6-8425-bb2ff8e797b7" 
[root@study fs]# mount UUID="819c0c18-8d4a-4c3f-9a98-0ab039e769f5" /data/xfs
mount: 挂载点 /data/xfs 不存在
[root@study fs]# mkdir -p /data/xfs
[root@study fs]# mount UUID="819c0c18-8d4a-4c3f-9a98-0ab039e769f5" /data/xfs
[root@study fs]# df /data/xfs
文件系统         1K-块  已用    可用 	  已用% 挂载点
/dev/sda4      1038336 32896 1005440    4% /data/xfs
# 这里顺利挂载了，且容量约为 1g 左右
[root@study fs]# df -h /data/xfs
文件系统        容量  已用  可用 已用% 挂载点
/dev/sda4      1014M   33M  982M    4% /data/xfs


# 使用相同的方式，将 /dev/sda5 挂载到 /dev/ext4 目录
[root@study fs]# mkdir /data/ext4
[root@study fs]# blkid /dev/sda5
/dev/sda5: UUID="b0923041-024a-47cf-a4b8-d59b573855d7" TYPE="ext4" PARTLABEL="Microsoft basic data" PARTUUID="9cffc784-99a3-40f6-8e5f-0c71b3bb7f05" 
[root@study fs]# mount UUID="b0923041-024a-47cf-a4b8-d59b573855d7" /data/ext4
[root@study fs]# df /data/ext4
文件系统        1K-块  已用   可用 已用% 挂载点
/dev/sda5      999320  2564 927944    1% /data/ext4

```

### 挂载 CD 或 DVD 光盘

这里拿出装系统的时候那个 iso 的文件，加载到虚拟机中

![image-20191027165331804](http://p4ui.toweydoc.tech:20080/images/stydocs/image-20191027165331804.png)

```bash
[root@study ~]# blkid
/dev/sr0: UUID="2019-07-12-09-13-14-35" LABEL="VBox_GAs_6.0.10" TYPE="iso9660" 
# 找到上图的光驱
/dev/sr1: UUID="2019-09-11-18-50-31-00" LABEL="CentOS 7 x86_64" TYPE="iso9660" PTTYPE="dos" 
...

# 挂载到 /data/cdrom 目录下
[root@study ~]# mkdir /data/cdrom
[root@study ~]# mount /dev/sr1 /data/cdrom/
mount: /dev/sr1 写保护，将以只读方式挂载
[root@study ~]# df /data/cdrom/
文件系统         1K-块    已用  可用 已用% 挂载点
/dev/sr1       4554702 4554702     0  100% /data/cdrom

```

光驱挂载之后就无法退出盘片了，除非卸载才能够退出。在图形界面，系统会自动帮你挂载这个光盘到 /media/ 里面去，也可以不卸除就直接退出，但是文字界面就没有这个福利了



### 挂载 vfat （USB 磁盘）

USB 不能是 NTFS 的文件系统

```bash
由于笔者没有 USB 磁盘，这里就不做练习了，直接复制命令
blkid
/dev/sda1:UUID="xxxx22" TYPE="vfat"
mkdir /data/usb
mount -o codepage=950,iocharset=utf8 UUID="xxxx22" /data/usb
df /data/usb
文件系统         1K-块    已用    可用 已用% 挂载点
/dev/sda1    4554702 4554702     0  100% /data/usb
```

如果带有中文文件名的数据，那么可以在挂载时指定下挂载文件系统所使用的语系数据，在 man mount 找到 vfat 文件格式当中可用使用 codepage 来处理，中文语系代码为 950

如果你使用的 usb 磁盘是 NTFS 时，因为预设的 CentOS 7 不支持 NTFS 文件系统格式，所以需要安装 NTFS 文件系统的驱动程序后，才可以（该部分后续讲解 yum 服务器时会继续）



### 重新挂载根目录与挂载不特定目录

根目录不能被卸载的，如果想要改变挂载参数或则根目录出现「只读」状态时，如何重新挂载呢？最可能的处理方式就是重新启动系统，但是可以用下面的指令来做

```bash
# 将 / 重新挂载，并加入参数为 rw 与 auto
mount -o remount,rw,auto /
```

另外，可以利用 mount 来将某个目录挂载到另外一个木去，这并不是挂载文件系统，而是额外故障某个目录的方法，虽然下面的演示也可以使用 symbolic link 来连结，不过在某些不支持符号链接的程序运行中，就可以通过这种方式来处理

```bash
[root@study ~]# mkdir /data/var
[root@study ~]# mount --bind /var /data/var
[root@study ~]# ls -lid /var /data/var
69 drwxr-xr-x. 20 root root 282 10月  4 18:38 /data/var
69 drwxr-xr-x. 20 root root 282 10月  4 18:38 /var
# 可以看到两个目录一模一样

# 通过 mount 指令查找 var 内容，看到下面的 /data/var 的挂载属性
[root@study ~]# mount | grep var
sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw,relatime)
/dev/mapper/centos-root on /data/var type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
# 从此进入 /data/var 就是进入 /var 的效果了
```

### umount 将装置文件卸除

```bash
umount [-fn] 装置文件名或挂载点

-f：强制卸除，可用在类似网络文件系统无法读取到的情况下
-l：like卸除文件系统，比 -f 还强
-n：不更新 /etc/mtab 情况下卸除

# 将本章讲解的示例挂载全部卸除
/dev/sr1 on /data/cdrom type iso9660 (ro,relatime)
/dev/mapper/centos-root on /data/var type xfs (rw,relatime,seclabel,attr2,inode64,noquota)

# 笔者这里刚才虚拟机重启了，找不到 /data/xfs 和 /data/ext4 的挂载点信息了
# 查看了下目录信息，发现变成最后一个 一样的了，都是 /dev/mapper/centos-root

# 卸载后面可以使用以下方式
# umount /dev/sr1  # 用装置文件名
umount /data/cdrom # 用挂载点来卸载
umount /data/var # 说是这个装置有被其他方式挂载，这里一定要用挂载点
# 这里笔者就懵逼了，完全看不出来怎么算是被其他挂载点挂载的？

```

## 磁盘/文件系统参数修订

某些时候，可能希望修改一下目前文件系统的一些相关信息，比如需要修改 Label name，或则是 journal 的参数，或则是其他磁盘、文件系统运作时的相关参数（DMA 启动与否）。这个时候就需要下面的相关指令了

### mknod

在 Linux 下所有的装置都以文件来代表的，但是那个文件如何代表该装置呢？

```bash
[mrcode@study ~]$ ll /dev/sda*
# 注意这里的 8,0 这一列
brw-rw----. 1 root disk 8, 0 Oct 27 17:36 /dev/sda
brw-rw----. 1 root disk 8, 1 Oct 27 17:36 /dev/sda1
brw-rw----. 1 root disk 8, 2 Oct 27 17:36 /dev/sda2
brw-rw----. 1 root disk 8, 3 Oct 27 17:36 /dev/sda3
brw-rw----. 1 root disk 8, 4 Oct 27 17:36 /dev/sda4
brw-rw----. 1 root disk 8, 5 Oct 27 17:36 /dev/sda5

```

上面信息中的 8 为主要装置代码（Major），而 0~5 则为次要装置代码（Minor），linux 核心就是通过这两个数值来决定的。举例来说，常见的磁盘文件名 /dev/sda 与 /dev/loop0 装置代码如下所示

| 磁盘文件名 | Major | Minor |
| :--------: | :---: | :---: |
|  /dev/sda  |   8   | 0-15  |
|  /dev/sdb  |   8   | 16-31 |
| /dev/loop0 |   7   |   0   |
| /dev/loop1 |   7   |   1   |

可以通过核心官网连结了解更多核心支撑的硬件装置代码。基本上 linux 核心 2.6 以后，硬件文件名已经都可以被系统自动的实时产生了，不需要手动创建装置文件。不够某些情况下需要东涌处理装置文件，例如在某些服务被关到特定目录下时（chroot）就需要这样做了，此时 mknod 指令可以实现

```bash
mknod 装置文件名 [bcp][Major][Minor]
选项与参数
装置种类：
 b：设置装置名称成为一个周边存储设备文件，例如磁盘等
 c：设置装置名称成为一个周边输入设备文件，例如鼠标、键盘灯
 p：设置装置名称成为一个 FIFO 文件
Major：主要装置代码
Minor：次要装置代码
```

实践练习

```bash
# 上述介绍知道  /dev/sda10 的装置代码为 8，10 ，请建立并查阅此装置
[root@study ~]# mknod /dev/sda10 b 8 10
[root@study ~]# ll /dev/sda10
brw-r--r--. 1 root root 8, 10 10月 27 17:52 /dev/sda10
# 注意前面的 b 和 8，10 这个是有意义的不要随意设定

# 建立一个 FIFO 文件
[root@study ~]# mknod /tmp/testpipe p
[root@study ~]# ll /tmp/testpipe 
prw-r--r--. 1 root root 0 10月 27 17:53 /tmp/testpipe
# 该文件不是一般文件，不可以随便放这里，测试完成后删除掉该文件

[root@study ~]# rm /dev/sda10 /tmp/testpipe 
rm：是否删除块特殊文件 "/dev/sda10"？y
rm：是否删除先进先出 "/tmp/testpipe"？y

```

### xfs_admin 修改 XFS 文件系统的 UUID 与 Lable name

如果当初格式化的手忘记加上 lable name，后来想要重新加上，不需要重新格式化

```bash
xfs_admin [-lu] [-L labe][-U uuid] 装置文件名
```

选项与参数：

- l：列出这个装置的 lable
- u：列出这个装置的 uuid
- L：设置这个装置的 label name
- U：设置这个装置的 uuid

```bash
# 开始查看，没有 label
[root@study ~]# xfs_admin -l /dev/sda4
label = ""
# 设置后，发现后了
[root@study ~]# xfs_admin -L mrcode_xfs /dev/sda4
writing all SBs
new label = "mrcode_xfs"
[root@study ~]# xfs_admin -l /dev/sda4
label = "mrcode_xfs"

# 利用 uuidgen 产生新 UUID 来设置 /dev/sda4 ，并测试挂载
[root@study ~]# umount /dev/sda4
umount: /dev/sda4：未挂载  # 前面练习中我说咋没有发现他了，原来挂载失效了？
# 生成 uuid
[root@study ~]# uuidgen
edfa7161-5847-4935-80e1-6e081be9ab77
[root@study ~]# xfs_admin -u /dev/sda4
UUID = 819c0c18-8d4a-4c3f-9a98-0ab039e769f5
# 修改为新生成的 uuid
[root@study ~]# xfs_admin -U edfa7161-5847-4935-80e1-6e081be9ab77 /dev/sda4
Clearing log and setting UUID
writing all SBs
new UUID = edfa7161-5847-4935-80e1-6e081be9ab77
# 用新的 uuid 挂载
[root@study ~]# mount UUID=edfa7161-5847-4935-80e1-6e081be9ab77 /data/xfs

```

### tune2fs 修改 ext4 的 label name 与 UUID

```bash
tune2fs [-l][-L label][-U uuid] 装置名

-l：类似 dumpe2fs -h 的功能，将 superblock 内的数据读出来
-L：修改 label name
-U：修改 UUID
```

实践练习

```bash
[root@study ~]# dumpe2fs -h /dev/sda5 | grep name
dumpe2fs 1.42.9 (28-Dec-2013)
Filesystem volume name:   <none>		# 无名称
[root@study ~]# tune2fs -L mrcode_ext4 /dev/sda5
tune2fs 1.42.9 (28-Dec-2013)
[root@study ~]# mount LABEL=mrcode_ext4 /data/ext4
# 再次查看就有了
[root@study ~]# dumpe2fs -h /dev/sda5 | grep name
dumpe2fs 1.42.9 (28-Dec-2013)
Filesystem volume name:   mrcode_ext4

```

## 设置开机挂载

手动处理 mount 后不是永久挂载的，就像上一节我的虚拟机软件崩溃了，重启之后挂载的都不在了。

## 开机挂载 /etc/fstab 及 /etc/mtab

可以通过修改 /etc/fstab 文件来达到开机自动挂载，下面说一说系统挂载的限制

- 根目录 / 是必须挂载的，而且一定要先于其他的 mount point 被挂载出来
- 其他 mount point 必须为已建立的目录，可任意指定，但一定要遵守必须的系统目录架构原则（FHS）
- 所有 mount point 在同一时间之内，只能挂载一次
- 所有 partition 在同一时间之内，只能挂载一次
- 若进行卸载，必须先将工作目录移到 mount point（及其子目录）之外

```bash
[mrcode@study ~]$ cat /etc/fstab

#
# /etc/fstab
# Created by anaconda on Fri Oct  4 18:20:52 2019
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
# device								Mount point				filesystem	 paramters		dump fsck
/dev/mapper/centos-root /                       xfs     defaults        0 0
UUID=13d0663f-4cbd-412d-aa9f-975eb18da590 /boot                   xfs     defaults        0 0
/dev/mapper/centos-home /home                   xfs     defaults        0 0
/dev/mapper/centos-swap swap                    swap    defaults        0 0

```

/etc/fstab（filesystem table）将我们利用 mount 指令进行挂载时，将所有的选项与参数写入该文件。初次之外，/etc/fstab 还加入了 *dump* 这个备份用指令的支持。与开机时是否进行文件系统检验 *fsck* 等指令有关。该文件内容提供的 6 个字段很重要，需要背下来

```bash
【装置/UUID等】【挂载点】【文件系统】【文件系统参数】【dump】【fsck】
```

- 装置文件名/UUID/LABEL name：

  可以填写的数据主要有三个项目

  - 文件系统或磁盘的装置文件名，如 /dev/sda 等
  - 文件系统的 UUID 名称
  - 文件系统的 LABEL name

  看你自己喜好选择填写哪一项。这里建议使用 UUID，可以使用 blkid 或 xfs_admin 来查询 UUID

- 挂载点 mount point：一定是目录

- 磁盘分区槽的文件系统：手动挂载时，可以让系统自动测试挂载，该文件中需要手动确定，包括 xfs、ext4、vfat、reiserfs、nfs 等

- 文件系统参数

  前面讲解 mount 指令谈到很多特殊的文件系统参数，还有我们使用过的 `-o codepage=950`,这些参数就是写在这里的

  | 参数 | 内容含义 |
  | :----------------------------------: | ------------------------------------------------------------ |
  |async/sync（异步/同步）   | 设置磁盘是否已异步允许方式，预设为 async |
  |      auto/noauto（自动/非自动）      | 当下达 mount -a 时，此文件系统是否被主动测试挂载。预设为 auto |
  |         rw/ro（可擦写/只读）         | 让该分区槽可以擦写或只读的形态挂载上来，当这里设置为只读之后，在文件系统中对文设置 w 权限，也不能写入 |
  |     exec/noexec（可执行/不可执行     | 限制在此文件系统内是否可以进行「执行」的工作？如果纯粹用来存储数据的话，就可以设置为 noexec 比较安全。不过该参数不能随便使用，因为你不知道该目录下是否默认会有执行文档。比如：将 noexec 设置在 /var ，当某些软件将一些执行文件放置到该文件下时，那么这些软件就不能运行 |
  | user/nouser（允许/不允许使用者挂载） | 是否允许用户使用 mount 指令来挂载                            |
  | suid/nosuid（具有/不具有 suid 权限） | 该文件系统是否允许 SUID 的存在？如果不是执行文件放置目录，也可以设置为 nosuid 来取消 SUID 的功能 |
  |               defaults               | 同时具有 rw、suid、dev、exec、auto、nouser、async 等参数。基本上使用该参数即可 |

- 内否被 dump 备份指令作用：dump 是用来做备份的指令，不过现在备份方案太多了，可以不关注该项目，直接输入 0 好了

- 是否已 fsck 检验扇区

  早期开机的流程中，会有一段时间去检验本机的文件系统，看看文件系统是否完整（clean）。不过该方式使用的主要是通过 fsck 来做的。我们现在用 xfs 文件系统就没有办法适用了，因为 xfs 会自己进行检验，直接填写 0 即可

实践练习

```bash
# 将 /dev/sda4 每次开机都自动挂载到 /data/xfs
# 查看 uuid
[root@study ~]# blkid /dev/sda4
/dev/sda4: LABEL="mrcode_xfs" UUID="edfa7161-5847-4935-80e1-6e081be9ab77" TYPE="xfs" PARTLABEL="Linux filesystem" PARTUUID="3819b115-2ab8-4fb6-8425-bb2ff8e797b7" 
# 使用 nano 将下面信息写入到 /etc/fstab 最后
UUID="edfa7161-5847-4935-80e1-6e081be9ab77" /data/xfs xfs defaults 0 0

# 检查是否已挂载
[root@study ~]# df
文件系统                   1K-块    已用    可用 已用% 挂载点
/dev/sda4                1038336   32896 1005440    4% /data/xfs
/dev/sda5                 999320    2564  927944    1% /data/ext4
# 可见已挂载了，先卸除它，我们再来测试，卸载之后自行使用 df 确认
[root@study ~]# umount /dev/sda4 
# 再来挂载，这里使用了 -a 的参数，会默认加载 /etc/fstab 中的项挂载
[root@study ~]# mount -a
[root@study ~]# df /data/xfs
文件系统         1K-块  已用    可用 已用% 挂载点
/dev/sda4      1038336 32896 1005440    4% /data/xfs

# 重启系统后，再观察是否会自动挂载
reboot
# 笔者实测可以被自动挂载
```

/etc/fstab 是开机时的配置文件，不过实际 filesystem 的挂载是记录到 `/etc/mtab` 与 `/proc/mounts` 文件中的。每次当我们更动 filesystem 的挂载时，也会同时更动这两个文件。但是万一发生你再 /etc/fstab 输入的数据错误，导致无法顺利开机成功，而进入单人维护模式当中，哪时候的 / 可是 read only 的状态，就无法修改 /etc/fstab ，也无法更新 /etc/mtab 怎么办？

```bash
# 重新挂载下 / 就可以了修改了
mount -n -o remount,rw /
```

## 特殊装置 loop 挂载（印象档不刻录就挂载使用）

如果有有光盘映像文件，或则是使用文件作为磁盘的方式时，需要使用特别的方法将他挂载起来，不需要颗粒

### 挂载光盘/DVD 映像文件

前面装系统时从网络上下载的 ISO 文件，不用刻录到光盘上再读取，可以通过 loop 来挂载

```bash
# 笔者的虚拟机里面没有这个文件，上传也很慢，现在课程中也还未讲到网络配置等东西
# 这里就不实践了，只记录下步骤
ll -h /tmp/CentOS-7-DVD.iso
mkdir /data/centos_dvd
# 挂载
mount -o loop /tmp/CentOS-7-DVD.iso /data/centos_dvd
df /data/centos_dvd
# 挂载之后，就可以读取该目录下的内容了
ll /data/centos_dev
# 当然这样挂载之后也是可以修改里面的文件的（前面讲解了修改挂载的参数支持写入，获取可以去尝试下）
# 这也是为什么很多 iso 提供之后会有一个 MD5 给使用者来确认该文档没有被修改过
```

### 建立大文件以知错 loop 装置文件

既然可以挂载 DVD 的映像文档，那么能不能制作一个大文件，然后将整个文件格式化后挂载？比如：如果当初在分区时，只分区出一个根目录，假设已经没有多余的容量可以进行额外的分区。偏偏根目录的容量还很大！此时就可以制作出一个大文件，然后将整个文件挂载！如此就感觉多了一个分区槽，用途非常的广泛

下面我们再 /srv 下建立一个 512MB 左右的大文件，然后将整个大文件格式化并且实际挂载来玩一下。

#### 建立大型文件

可以使用 dd 指令来建立空文件（后续会详细讲解）

```bash
[root@study ~]# dd if=/dev/zero of=/srv/loopdev bs=1M count=512
记录了512+0 的读入
记录了512+0 的写出
536870912字节(537 MB)已复制，0.519957 秒，1.0 GB/秒

# 该指令含义如下
if：是 input file 输入文件，/dev/zero 是会一直输出 0 的装置
of：是 output file，将一堆 0 写入到后面接的文件中
bs：每个 block 大小
count：总共几个 bs。所以 bs * count = 该文件容量

# 查看该文件
[root@study ~]# ll -h /srv/loopdev 
-rw-r--r--. 1 root root 512M 10月 27 20:39 /srv/loopdev

```

#### 大型文件格式化

预设 xfs 不能够格式化文件，所以要格式化文件需要使用特别的参数

```bash
# 使用参数 -f 强制格式化
[root@study ~]# mkfs.xfs -f /srv/loopdev 
meta-data=/srv/loopdev           isize=512    agcount=4, agsize=32768 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=131072, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=855, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@study ~]# blkid /srv/loopdev 
# 注意这里的 UUID 后续会用到
/srv/loopdev: UUID="fc6e332b-343f-4a08-921c-9801e3caeb66" TYPE="xfs" 
```

#### 挂载

```bash
[root@study ~]# mount -o loop UUID="fc6e332b-343f-4a08-921c-9801e3caeb66" /mnt
[root@study ~]# df /mnt/
文件系统        1K-块  已用   可用 已用% 挂载点
/dev/loop0     520868 26436 494432    6% /mnt

```

通过这个简单的方法，感觉上可以在原本的分区槽在不更改原有的环境下制作出想要的分区槽了，非常好用，尤其是想要玩 linux 上面的「虚拟机」的话，也就是以一部 Linux 主机再切割成为数个独立的主机系统时，类似 VMware 这类的软件，在 Linux 上使用 xen 这个软件，他就可以配合这种  loop device 的文件类型来进行根目录的挂载，真的非常有用

比较特别的是，Centos7.x 越来越智能了，现在不需要使用 -o loop 选项与参数，统一可以被挂载上来，直接输入 blkid 都会列出这个文件内部的文件系统（为了考虑兼容性，还是建议加上 loop 比较妥当），现在将该文件系统永远的自动挂载

```bash
[root@study ~]# nano /etc/fstab
# 在该文件中写入下面一行的数据
# 注意这里挂载到了 /data/file 中
# UUID="fc6e332b-343f-4a08-921c-9801e3caeb66" /data/file xfs defaults 0 0
# 这里还是使用文件档名来挂载，毕竟系统大多仅查询 block device 去找 UUID，因此使用文件建立的 filesystem 使用文件名比较不容易出错
/srv/loopdev /data/file xfs defaults 0 0

# 卸载原来的 mnt，以及建立对应的目录
[root@study ~]# umount /mnt
[root@study ~]# mkdir /data/file
[root@study ~]# mount -a
[root@study ~]# df /data/file
文件系统        1K-块  已用   可用 已用% 挂载点
/dev/loop0     520868 26436 494432    6% /data/file


```

## 内存交换空间（swap）之建置

早期年代因为内存不足，因此可以暂时将内存的程序拿到硬盘中暂放的内存置换空间（swap）就显得非常重要，所以之前老见到说安装 linux 一定需要两个 partition，一个是根目录，另一个就是 swap 了

一般来说，如果硬件资源配置足够的话，swap 应该不会被系统使用到。会被用到的时候，通常就是物理内存不足的情况了。在用到 swap 时，你的主机磁盘灯就会开始闪个不停

但是你不能预估不会存在物理内存不够用的情况，所以预留 swap 是有必要的，特别是在服务器上，不知道什么时候会有大量的网络请求。

假如现在有这样一种情况：系统已经建立起来了，但是却发现没有建立 swap，那么可以通过如下的方式来做

- 设置一个 swap partition
- 建立一个虚拟内存的文件

## 使用实体分区槽建立 swap

步骤如下

1. 分区：使用 gdisk 在磁盘中分区出一个分区槽给系统作为 swap。
2. 格式化：利用建立 swap 格式的 「mkswap 装置文件名」就能够格式化该分区槽成为 swap 格式
3. 使用：最后将该 swap 装置启动，方法为「swapon 装置文件名」
4. 观察：通过 free 与 swapon -s 指令来观察内存的用量

### 1. 分区

```bash
[root@study ~]# gdisk /dev/sda
GPT fdisk (gdisk) version 0.8.10

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.

Command (? for help): n
Partition number (6-128, default 6): 
First sector (34-85491678, default = 69220352) or {+-}size{KMGTP}: 
Last sector (69220352-85491678, default = 85491678) or {+-}size{KMGTP}: +512M
Current type is 'Linux filesystem'
Hex code or GUID (L to show codes, Enter = 8300): 8200

Command (? for help): p
Disk /dev/sda: 85491712 sectors, 40.8 GiB
Logical sector size: 512 bytes
Disk identifier (GUID): 67038DBF-B66A-4D0F-92B2-BFBF0744CD1D
Partition table holds up to 128 entries
First usable sector is 34, last usable sector is 85491678
Partitions will be aligned on 2048-sector boundaries
Total free space is 15224765 sectors (7.3 GiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048            6143   2.0 MiB     EF02  
   2            6144         2103295   1024.0 MiB  0700  
   3         2103296        65026047   30.0 GiB    8E00  
   4        65026048        67123199   1024.0 MiB  8300  Linux filesystem
   5        67123200        69220351   1024.0 MiB  0700  Microsoft basic data
   6        69220352        70268927   512.0 MiB   8200  Linux swap

Command (? for help): w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? (Y/N): y
OK; writing new GUID partition table (GPT) to /dev/sda.
Warning: The kernel is still using the old partition table.
The new table will be used at the next reboot.
The operation has completed successfully.

# 刷新分区
[root@study ~]# lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0 40.8G  0 disk 
├─sda1            8:1    0    2M  0 part 
├─sda2            8:2    0    1G  0 part /boot
├─sda3            8:3    0   30G  0 part 
│ ├─centos-root 253:0    0   10G  0 lvm  /
│ ├─centos-swap 253:1    0    1G  0 lvm  [SWAP]
│ └─centos-home 253:2    0    5G  0 lvm  /home
├─sda4            8:4    0    1G  0 part /data/xfs
├─sda5            8:5    0    1G  0 part 
└─sda6            8:6    0  512M  0 part   	# 出现了
```

### 2. 建立 swap 格式

```bash
[root@study ~]# mkswap /dev/sda6
正在设置交换空间版本 1，大小 = 524284 KiB
无标签，UUID=89727d5b-a222-4878-be50-19bbb61cabb0

# 确实可以抓到该装置了
[root@study ~]# blkid /dev/sda6
/dev/sda6: UUID="89727d5b-a222-4878-be50-19bbb61cabb0" TYPE="swap" PARTLABEL="Linux swap" PARTUUID="5fff6d01-b73a-45c2-be69-8fc4a67e0788" 
```

### 3. 开始观察看看

```bash
[root@study ~]# free
              total        used        free      shared  buff/cache   available
Mem:        1190952      389504       83364       10916      718084      640164
Swap:       1048572           0     1048572
[root@study ~]# free -h
              total        used        free      shared  buff/cache   available
Mem:           1.1G        380M         81M         10M        701M        625M
Swap:          1.0G          0B        1.0G

# 列出目前使用的 swap 装置有哪些
[root@study ~]# swapon -s
文件名                          类型            大小    已用    权限
/dev/dm-1                               partition       1048572 0       -2

# 使用 swapon 指令挂载 swap 分区槽
[root@study ~]# swapon /dev/sda6
[root@study ~]# free
              total        used        free      shared  buff/cache   available
Mem:        1190952      389848       82492       10916      718612      639820
Swap:       1572856           0     1572856
[root@study ~]# swapon -s
文件名                          类型            大小    已用    权限
/dev/dm-1                               partition       1048572 0       -2
/dev/sda6                               partition       524284  0       -3
# 可以看到这里 sda6 被用上了

# 建立永久挂载
nano /etc/fstab
# 这里是文件系统，所以没有挂载点，第二个字段写 swap
UUID="89727d5b-a222-4878-be50-19bbb61cabb0" swap swap defaults 0 0

```

## 使用文件建立 swap

如果是在四题分区槽无法支持的环境下，可以使用上一小节中提到的 loop 装置来建立

```bash
[root@study ~]# dd if=/dev/zero of=/tmp/swap bs=1M count=128
记录了128+0 的读入
记录了128+0 的写出
134217728字节(134 MB)已复制，0.0852543 秒，1.6 GB/秒
[root@study ~]# ll -h /tmp/swap 
-rw-r--r--. 1 root root 128M 10月 27 21:22 /tmp/swap

# 格式化的时候一定要特别注意，路径不要错，否则有可能搞垮你的文件系统
[root@study ~]# mkswap /tmp/swap 
正在设置交换空间版本 1，大小 = 131068 KiB
无标签，UUID=977e598a-ff20-4be9-bc28-7792c19bfe32

[root@study ~]# swapon /tmp/swap
swapon: /tmp/swap：不安全的权限 0644，建议使用 0600。
[root@study ~]# swapon -s
文件名                          类型            大小    已用    权限
/dev/dm-1                               partition       1048572 0       -2
/dev/sda6                               partition       524284  0       -3
/tmp/swap                               file    131068  0       -4

# 使用 swapoff 指令关掉刚才手动挂载的两个挂载点，并配置自动挂载
# 建立永久挂载
nano /etc/fstab
# 增加配置
/tmp/swap swap swap defaults 0 0

# 关闭手动挂载的挂载点
[root@study ~]# swapoff /dev/sda6 /tmp/swap
[root@study ~]# swapon -s
文件名                          类型            大小    已用    权限
/dev/dm-1                               partition       1048572 0       -2

# 手动挂载所有，再查看下，配置正确
[root@study ~]# swapon -a
swapon: /tmp/swap：不安全的权限 0644，建议使用 0600。
[root@study ~]# swapon -s
文件名                          类型            大小    已用    权限
/dev/dm-1                               partition       1048572 0       -2
/dev/sda6                               partition       524284  0       -3
/tmp/swap                               file    131068  0       -4


```

swap 主要功能是当物理内存不够时，则某些在内存中所占的程序会暂时被移动到 swap 中，让物理内存可以被需要的程序来使用。另外，如果主机支持电源管理模式，也就是说使用「休眠」功能的话，运行中的程序状态则会被记录到 swap 中去，以作为「唤醒」主机的状态依据。另外某些程序会利用 swap 的特性来存放一些数据，所以 swap 需要建立，只是不需要太大


## 文件系统的特殊观察与操作

文件系统是在是非常有趣的东西，鸟哥学了好几年很多东西都不懂，这里有一些经验以供参考

## 磁盘空间之浪费问题

前面 ext2 data block 中谈到一个 block 只能放置一个文件，因此太多小文件会浪费很多的磁盘容量。

```bash
[root@study ~]# ll -sh
总用量 16K
4.0K -rw-------. 1 root   root   2.2K 10月  4 18:32 anaconda-ks.cfg
4.0K -rw-r--r--. 2 root   root    451 6月  10 2014 crontab
   0 lrwxrwxrwx. 1 root   root     12 10月 22 00:00 crontab2 -> /etc/crontab
4.0K -rw-r--r--. 1 root   root   2.2K 10月  4 18:42 initial-setup-ks.cfg
4.0K -rwxr-xrwx. 1 mrcode mrcode 2.2K 10月  7 23:30 initial-setup-ks-mrcode.cfg
```

上述的总用量是每个文件所使掉 blcok 的容量的汇总，但是 哪个 crontab 文件实际只有用 451bytes，但是他却占用了整个 block （每个 block 为 4k）。所以总共占用了 16k 的容量，但是实际这里的文件总容量不到 7k

当讨论磁盘空间浪费问题的时候，需要考虑到文件容量的损耗

## 利用 GNU 的 parted 进行分区行为（Optional）

parted 同时支持 gdisk 和 fdisk 分区

```bash
parted [装置][指令][参数]

选项与参数，指令功能：
	新增分区：mkpart [primary|logical|extended][ext4|vfat|xfs] 开始 结束
	显示分区：print
	删除分区：rm [partition]
```

实践练习

```bash
# 列出目前本机的分区表资料
[root@study ~]# parted /dev/sda print
Model: ATA VBOX HARDDISK (scsi)				# 磁盘接口与型号
Disk /dev/sda: 43.8GB									# 磁盘文件名与容量
Sector size (logical/physical): 512B/512B		#每个扇区大小
Partition Table: gpt		# 分区表 gpt
Disk Flags: pmbr_boot

Number  Start   End     Size    File system     Name                  标志
 1      1049kB  3146kB  2097kB                                        bios_grub
 2      3146kB  1077MB  1074MB  xfs
 3      1077MB  33.3GB  32.2GB                                        lvm
 4      33.3GB  34.4GB  1074MB  xfs             Linux filesystem
 5      34.4GB  35.4GB  1074MB  ext4            Microsoft basic data
 6      35.4GB  36.0GB  537MB   linux-swap(v1)  Linux swap

```

上面是最简单的 parted 指令功能简介，可以使用 man parted 或则 `parted /dev/sda help mkpart`查询更详细的数据。下面解释下每个字段是啥意思

- Number：分区槽号码，比如 1 表示 /dev/sda1
- Start：分区的其实位置在这颗磁盘的多少 MB 处？这里以容量作为单位
- End：此分区的结束位置在这颗磁盘的多少 MB 处？
- Size：由上述数据分析，得到这个分区槽有多少容量
- File system：分析可能的文件系统类型
- Name：如同 gdisk 的 System ID 的意思

不过这里你发现没有，start 与 end 的单位都不一样，看起来很费劲，可以通过以下指令固定

```bash
[root@study ~]# parted /dev/sda unit mb print
Model: ATA VBOX HARDDISK (scsi)
Disk /dev/sda: 43772MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: pmbr_boot

Number  Start    End      Size     File system     Name                  标志
 1      1.05MB   3.15MB   2.10MB                                         bios_grub
 2      3.15MB   1077MB   1074MB   xfs
 3      1077MB   33293MB  32216MB                                        lvm
 4      33293MB  34367MB  1074MB   xfs             Linux filesystem
 5      34367MB  35441MB  1074MB   ext4            Microsoft basic data
 6      35441MB  35978MB  537MB    linux-swap(v1)  Linux swap

```

如果想将原本的 MBR 和 GPT 分区表互相换，也可以使用 parted，不过不要用本次的 sda 来测试，因为分区表格式不能转换，该磁盘上的系统会损坏的。

下面测试，笔者就没有条件测试了，直接记录笔记

```bash
# 将 /dev/sda 原本是 MBR 分区变成 GPT 分区表
parted /dev/sda print
...
Partition Table: msdos  # MBR 就是现实 msdos 格式

# 改变成 gpt 分区
parted /dev/sda mklabel gpt
```

新的示例：建立一个全新的分区槽，格式化为 vfat 格式，且挂载到 /data/win 目录

```bash
# 查看分区表情况
[root@study ~]# parted /dev/sda print
Model: ATA VBOX HARDDISK (scsi)
Disk /dev/sda: 43.8GB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: pmbr_boot

Number  Start   End     Size    File system     Name                  标志
 1      1049kB  3146kB  2097kB                                        bios_grub
 2      3146kB  1077MB  1074MB  xfs
 3      1077MB  33.3GB  32.2GB                                        lvm
 4      33.3GB  34.4GB  1074MB  xfs             Linux filesystem
 5      34.4GB  35.4GB  1074MB  ext4            Microsoft basic data
 6      35.4GB  36.0GB  537MB   linux-swap(v1)  Linux swap
# 找到最后一个分区的 end 位置，作为下一个分区的起始位置
[root@study ~]# parted /dev/sda mkpart primary fat32 36.0GB 36.5GB
信息: You may need to update /etc/fstab.
# 再次查看，就看到第 7 个了
[root@study ~]# parted /dev/sda print
 7      36.0GB  36.5GB  522MB                   primary
 
 # 确认真的存在
[root@study ~]# partprobe 
Warning: 无法以读写方式打开 /dev/sr0 (只读文件系统)。/dev/sr0 已按照只读方式打开。
[root@study ~]# lsblk /dev/sda7
NAME MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda7   8:7    0  498M  0 part 

# 格式化分区为 vfat 格式
[root@study ~]# mkfs -t vfat /dev/sda7
mkfs.fat 3.0.20 (12 Jun 2013)
[root@study ~]# blkid /dev/sda7
/dev/sda7: SEC_TYPE="msdos" UUID="72BE-0556" TYPE="vfat" PARTLABEL="primary" PARTUUID="3a31eca1-2f5d-4960-8d61-739c4461b30f" 

# 添加到自动挂载
nano /etc/fstab
UUID="72BE-0556" /data/win vfat defaults 0 0

[root@study ~]# mkdir /data/win
[root@study ~]# mount -a
[root@study ~]# df /data/win/
文件系统        1K-块  已用   可用 已用% 挂载点
/dev/sda7      509672     0 509672    0% /data/win

```

事实上，你应该使用 gdisk 来处理 GPT 分区，不过 parted 非常适合通过脚本来一口气将分区全部建立，因为 parted 可以不用与用户交互

## 重点回顾

- 一个可以被挂载的数据通常称为「文件系统 filesystem」而不是分区槽（partition）
- 基本上 Linux 的传统文件系统位 Ext2，该文件系统内的信息主要有：
  - superblock：记录此 filesystem 的整体信息，包括 inode、block 的总量、使用量、剩余量，以及文件系统的格式与相关信息
  - inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 号码
  - block：实际记录文件的内容，若文件太大时，会占用多个 block
- Ext2 文件系统的数据存取为索引式文件系统（indexed allocation）
- 需要碎片整理的原因就是文件写入的 block 太过于离散了，此时文件读取的效能变得很差。可以通过碎片整理将同一个文件所属的 blocks 整理在一起
- Ext 文件系统主要有：boot sector、superblock、inode bitmap、inode table、data block 等 6 大部分
- data block 是用来放置文件内容数据的地方，在 ext2 文件系统中所支持的 block 大小有 1k、2k、4k 三种
- inode 记录文件的属性、权限等数据，其他重要项目为：每个 inode 大小均为固定，有 128、256bytes 两种基本容量。每个文件都仅会占用一个 inode。因此文件系统能够建立的文件数量与 inode 的数量有关
- 文件的 block 在记录文件的实际数据，目录的 block 则在记录该目录下文件名与其 inode 号码的对照表
- 日志文件系统（journal）会多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间
- Linux 文件系统位增加效能，会让主存储器作为大量的磁盘告诉缓存
- 实体链接只是多了一个文件名对该 inode 号码的连接
- 符号链接就类似 windows 的快捷方式功能
- 磁盘的使用必须经过：分区、格式化与挂载，分别惯用的指令为：gdisk、mkfs、mount 三个指令
- 分区时，应使用 parted 检查分区表格式，再判断使用 fdisk 或 gdisk 来分区，或直接使用 parted 分区
- 为了考虑效能，xfs 文件系统格式化时，可以考虑加上 agcount、su、sw、extsize 等参数
- 如果磁盘以无未分区的容量，可以考虑使用大型文件取代磁盘装置的处理方式，通过 dd 与格式化功能
- 开机自动挂载可参考 /etc/fstab 的设置，设置完后务必使用 mount -a 测试语法正确性



## 卸载挂载的分区练习

将本章挂载的几个挂载点全部卸载。并删除这些分区，回复到原本刚安装时的状态；

- 目标：了解到删除分区槽需要注意的各项信息
- 前提：本章各项示例都有做过，才会拥有 /dev/sda4 ~ /dev/sda7 的分区出现
- 需求：熟悉 gdisk、parated、umount、sapoff 等指令

1. 使用 free、swapon -s、mount 等指令查询要被处理的文件系统不可以被使用，如果有被使用则必须使用 umount 卸载文件系统。如果是 swap，则需要使用 swapon -s 找出被使用的分区槽再用 swapoff 卸载

   ```bash
   [root@study ~]# umount /data/ext4 /data/xfs /data/file /data/win
   umount: /data/ext4：未挂载
   [root@study ~]# swapoff /dev/sda6 /tmp/swap

   ```

2. 观察 /etc/fstab 将相关的配置删除或注释掉

   ```bash
   nano /etc/fstab
   # 将相关的都注释掉了
   # UUID="edfa7161-5847-4935-80e1-6e081be9ab77" /data/xfs xfs defaults 0 0
   # /srv/loopdev /data/file xfs defaults 0 0
   # UUID="89727d5b-a222-4878-be50-19bbb61cabb0" swap swap defaults 0 0
   # /tmp/swap swap swap defaults 0 0
   # UUID="72BE-0556" /data/win vfat defaults 0 0

   ```

3. 使用 gdisk 删除，也可以使用 parted 来删除

   ```bash
   [root@study ~]# parted /dev/sda rm 7
   信息: You may need to update /etc/fstab.

   [root@study ~]# parted /dev/sda rm 6
   信息: You may need to update /etc/fstab.

   [root@study ~]# parted /dev/sda rm 5
   信息: You may need to update /etc/fstab.

   [root@study ~]# parted /dev/sda rm 4
   信息: You may need to update /etc/fstab.
   # 刷新分区表
   [root@study ~]# partprobe                                                 

   # 确认下，确实只剩下三个了
   [root@study ~]# parted /dev/sda print
   Model: ATA VBOX HARDDISK (scsi)
   Disk /dev/sda: 43.8GB
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: pmbr_boot

   Number  Start   End     Size    File system  Name  标志
    1      1049kB  3146kB  2097kB                     bios_grub
    2      3146kB  1077MB  1074MB  xfs
    3      1077MB  33.3GB  32.2GB                     lvm

   # 将相关文件删除
   [root@study ~]# rm /tmp/swap /srv/loopdev
   rm：是否删除普通文件 "/tmp/swap"？y
   rm：是否删除普通文件 "/srv/loopdev"？y

   ```
