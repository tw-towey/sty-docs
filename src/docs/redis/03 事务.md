# 参考

- [深入理解数据库事务](https://zhuanlan.zhihu.com/p/43493165)
- [不支持原子性的 Redis 事务也叫事务吗？](https://xie.infoq.cn/article/84baa7fa9c2c3d3698a601def)
- [Transactions – Redis](https://redis.io/topics/transactions)

# 事务的基础概念

关于事务常见的例子就是银行转账，A 账户给 B 账户转账一个亿（T1），买一块地盖房子。在这种交易的过程中，有几个问题值得思考：

- **A：**如何**同时保证**上述交易中，A 账户总金额减少一个亿，B 账户总金额增加一个亿？
- **I：**A 账户如果同时在和 C 账户交易（T2），如何让两笔交易互不影响？
- **D：**如果交易完成时数据库突然崩溃，如何保证交易数据成功保存在数据库中？
- **C：**如何在支持大量交易的同时，保证数据的合法性（没有钱凭空产生或消失）？

要保证交易正常可靠地进行，数据库就得解决上面的四个问题，这也就是**『事务』**诞生的背景，它能解决上面的四个问题，对应地，它拥有四大特性（**ACID**）。

**下面详细的了解 ACID：**

**（1）原子性（Atomicity）：事务要么全部完成，要么全部取消。如果事务崩溃，状态回到事务之前（事务回滚）。**  
确保不管交易过程中发生了什么意外状况（服务器崩溃、网络中断等），不能出现 A 账户少了一个亿，但 B 账户没到账，或者 A 账户没变，但 B 账户却凭空收到一个亿（数据不一致）。A 和 B 账户的金额变动要么同时成功，要么同时失败（保持原状）。

**（2）隔离性（Isolation）: 如果两个事务 T1 和 T2 同时运行，事务 T1 和 T2 最终的结果是相同的，不管 T1 和 T2 谁结束。**  
如果 A 在转账 1 亿给 B（T1）的同时 C 又在转账 3 亿给 A（T2），不管 T1 和 T2 谁先执行完毕，最终结果必须是 A 账户增加 2 亿，而不是 3 亿，B增加 1 亿，C减少 3 亿。

**（3）持久性（Durability）: 一旦事务提交，不管发生什么（崩溃或者出错），数据要保存在数据库中。**  
确保如果 T1 刚刚提交，数据库就发生崩溃，T1 执行的结果依然会保持在数据库中。

**（4）一致性（Consistency）: 只有合法的数据（依照关系约束和函数约束）才能写入数据库。**  
确保钱不会在系统内凭空产生或消失， 依赖[原子性](https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7&spm=1001.2101.3001.7020)和隔离性。

可以看出，原子性、隔离性、一致性的根本问题，是不同的事务同时对同一份数据( A 账户)进行**『写操作』**(修改、删除、新增)，如果事务中都只是读数据的话，那么它们可以随意地同时进行，反正读到的数据都是一样的。

如果，几个互不知晓的事务在同时修改同一份数据，那么很容易出现后完成的事务覆盖了前面的事务的结果，导致不一致。 事务在最终提交之前都有可能会回滚，撤销所有修改：

- 如果 T1 事务修改了 A 账户的数据，
- 这时 T2 事务读到了更新后的 A 账户数据，并进行下一步操作，
- 但此时 T1 事务却回滚了，撤销了对 A 账户的修改，
- 那么 T2 读取到的 A 账户数据就是非法的，这会导致数据不一致。

这些问题都是事务需要避免的。更多参考 [深入理解数据库事务](https://zhuanlan.zhihu.com/p/43493165)

# 并发控制 - 乐观锁和悲观锁

并发控制是为了保证事务的隔离性，即如何避免几个互不知晓的事务在同时修改同一份数据的并发操作，不破坏事务的一致性。

事务的并发控制的目的是保证一个事务的执行不会对另一个事务的执行产生不合理的影响。

实现并发控制的主要手段有两种：

- 乐观并发控制 - 乐观锁
- 悲观并发控制 - 悲观所

# Redis 事务（Transactions）

## 官方介绍

事务允许在一个步骤中执行一组命令，并有两个重要的保证：

- 事务是一个单独的隔离操作：事务中的所有命令都被序列化并按顺序执行。事务在执行过程中，永远不会被另一个客户端发送的请求所打断。
- 事务是一个原子操作：事务中的命令要么全部处理，要不不处理任何命令。`EXEC` 命令触发事务中所有命令的执行，因此，如果客户端在调用 `EXEC` 命令前掉线了，则 Redis 会清空事务队列，事务中的所有命令都不会执行。而一旦客户端调用了 `EXEC` 命令，所有的命令就都会被执行，即使此客户端断线也没关系，因为 Redis 中已经记录了所有要执行的命令。

Redsi 事务的几个命令：

| 命令 | 描述 |
| --- | --- |
| MULTI | 标记一个事务块的开始 |
| EXEC | （在事务块中调用）执行所有事务块内的命令 |
| DISCARD | 丢弃/取消事务，放弃执行事务块内的所有命令 |
| WATCH | （在事务块中调用）监视一个（或多个）key，如果在事务执行之前监视的 key 被其它命令所改动，则整个事务将中止，EXEC 将返回一个 `(nil)` 通知事务失败 |
| UNWATCH | （在事务块中或外调用）取消 WATCH 命令对所有 keys 的监视 |

## 用法

Redis 中提供了以下三个命令来处理事务：

```shell
# 标记一个事务块的开始
# 在事务块内用户可以发出多个命令，但 Redis 不会执行它们
# 而是将它们按照先后顺序放进一个队列中
# 在调用 EXEC 命令后才会原子性（atomic）地执行全部命令
MULTI

# 执行事务块内的所有命令
EXEC

# 取消事务，重置事务队列，放弃执行事务块内的所有命令
DISCARD
```

示例：

```shell
# 初始化测试数据：Jack 有 10 块钱；Rose 有 20 块钱
127.0.0.1:6379> SET Jack 10
OK
127.0.0.1:6379> SET Rose 20
OK

# 标记一个事务：Jack 给 Rose 转账 5 块钱
127.0.0.1:6379> MULTI
# MULTI 命令始终返回 `OK`
OK

# 此时 Redis 连接处于 MULTI 请求的上下文中：`(TX)`
# 事务块中的命令不会被执行，而是被添加到队列中
127.0.0.1:6379(TX)> DECRBY Jack 5
# 所有命令都将返回 `QUEUED`（从 Redis 的角度看，它作为 Status 返回）
QUEUED

127.0.0.1:6379(TX)> INCRBY Rose 5
QUEUED

# 当调用 EXEC 时，队列中的命令被执行
127.0.0.1:6379(TX)> EXEC
# EXEC 命令返回一个数组，其中每个元素都是事务块中单个命令的回复（返回），其顺序与命令发出的顺序相同
1) (integer) 5
2) (integer) 25
```

上面的代码演示了完整的事务过程：

1. **开启事务：**首先使用 `MULTI` 命令告诉 Redis：“下面我发给你的命令属于同一事务，你先不要执行，而是把它们暂时存起来”。Redis 回答：“OK”。
2. **命令入队：**而后我们发送了两个命令来实现相关操作，可以看到 Redis 遵守了承诺，没有执行这些命令，而是返回 `QUEUED` 表示这两条命令已经进入等待执行的事务队列中了。
3. **执行事务：**当把所有要在同一事务中执行的命令都发给 Redis 后，我们使用 `EXEC` 命令告诉 Redis 将等待执行的事务队列中的所有命令按照发送的顺序依次执行。`EXEC` 命令的返回值就是这些命令的返回值组成的列表，返回值顺序和命令的顺序相同。
4. **取消事务：**如果想要**中止事务**，可以执行 `DISCARD` （丢弃）命令，这种情况下，不执行任何命令，连接状态恢复正常。

> 注意：如果向队列中添加命令时报错，在执行（`EXEC`）的时候会直接取消事务，不会执行任何命令：`(error) EXECABORT Transaction discarded because of previous errors.`
> 
> 详细见下面的《事务中的错误处理》

# 事务中的错误处理

在事务期间，可能会遇到两种命令错误：

**（1）命令无法入队 - 调用 `EXEC` 之前**

命令如果无法入队，在调用 `EXEC` 之前可能会出现错误。

例如，命令可能语法错误（参数数量错误、命令名称错误等），或者可能存在一些关键情况，如内存不足（如果使用 `maxmemory` 指令配置了服务器的内存上限）

服务器会对命令入队失败的情况进行记录，在客户端调用 `EXEC` 命令时，只要有一个命令报错，Redis 将返回错误，拒绝执行并自动丢弃这个事务。

示例：

```shell
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> SET foo 1
QUEUED
# 错误语法的命令
127.0.0.1:6379(TX)> SET foo
# 命令报错
(error) ERR wrong number of arguments for 'set' command
127.0.0.1:6379(TX)> SET foo 2
QUEUED
127.0.0.1:6379(TX)> EXEC
# 执行时 Redis 直接 DISCARD 事务
(error) EXECABORT Transaction discarded because of previous errors.
```

**（2）运行错误 - 调用 `EXEC` 之后**

运行错误指在[命令执行](https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C&spm=1001.2101.3001.7020)时出现的错误，例如使用哈希类型的命令操作集合类型的 key、对字符串值调用列表操作等。

这种错误在实际执行之前 Redis 是无法发现的（不会报错），所以在事务里这样的命令会被 Redis 接受并执行。

如果事务里的一个或多个命令出现了运行错误，事务里的其它命令依然会继续执行。

示例：

```shell
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> MSET foo 1 bar 10
QUEUED
# 对字符串类型的 foo 使用了集合操作，该命令将运行失败
127.0.0.1:6379(TX)> SADD foo 2
QUEUED
# 该命令不受影响，将执行成功
127.0.0.1:6379(TX)> SET bar 20
QUEUED
127.0.0.1:6379(TX)> EXEC
# 返回了每个命令的执行结果
# 运行错误的返回错误信息
# 其它的返回正常执行的结果
1) OK
2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
3) OK
127.0.0.1:6379> MGET foo bar
1) "1"
2) "20"
```

# 为什么 Redis 不支持回滚（Rollback）？

Redis 事务没有关系型数据库提供的回滚（rollback）功能。在执行事务期间 Redis 命令可能会失败，但 Redis 仍将执行事务的其余部分，而不是回滚。为此开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等）。

官方对于这种设计的说法是：

- 由 “语法错误” 或 “对持有错误数据类型的 key 调用 Redis 命令” 导致的失败，**实际原因是编程错误的结果**，这些错误应该在开发阶段被发现，而不应该出现在生产环境中。
- 由于 Redis 不支持回滚功能，也使得 Redis 在事务上可以保持**简洁和快速**。

# 事务中的 WATCH 命令

WATCH 用于提供事务的 check-and-set（CAS）行为，即乐观锁（也称为乐观锁定、乐观并发控制）。

## 悲观锁&乐观锁

数据库进行并发控制保证保证事务的隔离性、一致性的方式分为**悲观并发控制（悲观锁）**和**乐观并发控制（乐观锁）**。

- **悲观锁（Pessimistic Lock）**：对数据的修改持悲观态度，总是假设最坏的情况，每次读取数据的时候都认为其它线程会更改数据，因此在读取数据的时候先上锁（获取事务的锁），当其它线程想要读取数据的时候，都会阻塞挂起，直到拿到锁。
    - 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证，但效率方面会增加额外的开销，还会降低并行性，一个事务如果锁定了某行数据，其它事务就必须等待该事务处理完才可以处理那行数据。
    - 传统的关系型数据库就用到了很多这种锁机制，如行锁、表锁、读锁、写锁等，都是再操作之前先上锁。
- **乐观锁（Optimistic Lock）**：对数据的修改持乐观态度，假设数据修改一般不会发生冲突，所以不会上锁，每次在数据提交更新的时候，才会正式对数据的冲突与否进行检测，如果数据发生了变化，则返回给用户异常信息，由用户决定如何处理。
    - 乐观并发控制相信事务之间数据竞争的概率是比较小的，适用于**读多写少**的场景，可以提高程序的吞吐量。
    - 乐观锁不刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。
    - 乐观锁的实现方式一般有：
        - CAS：代表 check-and-set（检查并设置） 或 compare-and-swap（比较并替换）。在更新数据前会检查内存中的数据与期望的数据是否一致，如果一致就执行更新，如果不一致则重新执行事务。
        - 版本号控制：一般是为数据增加版本号 version，表示数据被修改的次数。当数据被修改时，version +1。在读取数据的同时读取 version，在数据提交更新时，若刚刚读取的 version 与数据当前的 version 相等，则提交更新成功，否则重试更新操作，知道更新成功。

## Redis 事务中的 CAS

Redis 通过 WATCH 命令监视 key，以便检测针对它们的更改。

如果在事务执行之前监视的 key 被其它命令所改动，则整个事务将中止，EXEC 将返回一个 `(nil)` 通知事务失败。

相关命令：

```shell
# 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将中止
WATCH key [key ...]

# 取消 WATCH 命令对所有 key 的监视。
# 如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了
UNWATCH
```

## 示例 1

以下是假设示例，模拟了数据操作流程，不是有效的代码：

```shell
# 初始数据：Jack 银行卡里有 100 元余额，Rose 的支付宝也绑定了这张卡
SET balance 100
```

事件1：Jack 买了 50 元的烟

```shell
# 获取银行卡余额，并保存到内存
val = GET balance # val = 100
# 扣除消费，计算新的余额
val = val - 50 # val = 50

# 执行事务更新数据
MULTI
DECRBY balance val
EXEC
# balance = 50
```

事件2：Rose 用 Jack 的卡吃了 30 元的下午茶

```shell
# 获取银行卡余额，并保存到内存
val = GET balance # val = 100
# 扣除消费，计算新的余额
val = val - 30 # val = 70

# 执行事务更新数据
MULTI
DECRBY balance val
EXEC
# balance = 70
```

可以看到，如果 Jack 和 Rose 在同一时间进行支付操作，就可能会造成竞争，最终 `balance` 的值可能是 `50` 或 `70`，而不是 `20`。

使用 WATCH 解决竞争问题：

事件1：

```shell
# 监听 balance
WATCH balance

val = GET balance
val = val - 50

# 执行事务更新数据
MULTI
DECRBY balance val
EXEC
```

事件2：

```shell
# 监听 balance
WATCH balance

val = GET balance
val = val - 30

# 执行事务更新数据
MULTI
DECRBY balance val
EXEC
```

在调用 `WATCH` 和 `EXEC` 之间的时间内，如果另一个客户端修改了 `val` 的结果（`balance` 的值），事务将中止。我们只需要重复该事务。

> 在许多用例中，多个客户端很少访问同一个 key，因此冲突不太可能发生 —— 通常不需要重复该操作。

## WATCH 和 UNWATCH 命令说明

WATCH 是一个使 EXEC 有条件的命令：它要求 Redis 仅在没有修改任何被 WATCH 的 key 的情况下执行事务。

这包括客户端所做的修改，如写命令，以及 Redis 本身所做的修改，如过期或逐出（内存不足导致临时删除数据）。

如果在 WATCH 和 EXEC 之间修改了 key，则整个事务将被中止。

事务中的命令不会触发 WATCH 条件，因为它们只是在发送 EXEC 前入队。

如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令被执行了的话，那么会自动取消 WATCH（当前进程）。

调用 EXEC 后，首先判断 WATCH 的 key 是否被修改，决定是否中止。而无论事务是否中止，当前进程所有 WATCH 的 key 都会变成 `UNWATCHed`（不被监视的）。所以如果事务不中止，执行事务队列的命令时，由于没有 key 被监视，所以修改不会触发当前进程的 WATCH 条件。

WATCH 可以被调用多次。简单的说，所有的 WATCH 调用都具有**“监视从调用 WATCH 开始到调用 EXEC 期间的更改”**的效果。还可以向单个 WATCH 发送任意数量的 key。

如果需要手动停止 WATCH 则可以可以使用 UNWATCH 命令，UNWATCH 命令会取消 WATCH 命令对所有 key 的监视。

## 示例 2

```shell
# 初始化 foo
127.0.0.1:6379> SET foo 1
OK
# 监视 foo
127.0.0.1:6379> WATCH foo
OK
# 更改 foo 的值
127.0.0.1:6379> SET foo 2
OK
# 开启一个事务
127.0.0.1:6379> MULTI
OK
# 向队列添加一个修改 foo 的命令，并没有执行修改操作
127.0.0.1:6379(TX)> SET foo 3
QUEUED
# 执行事务
127.0.0.1:6379(TX)> EXEC
# 由于在 WATCH 和 EXEC 期间将 foo 修改为 2，所以事务被中止
(nil)
127.0.0.1:6379> GET foo
"2"
# 再次修改 foo
127.0.0.1:6379> SET foo 4
OK
# 再次开启一个修改 foo 的事务
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> SET foo 5
QUEUED
127.0.0.1:6379(TX)> EXEC
# 事务执行成功，因为上一次事务 EXEC 后，所有 key 的 WATCH 状态已经被全部取消了（）
1) OK
```

## 示例 3

```shell
# 初始化两个数据
127.0.0.1:6379> MSET foo 1 bar 10
OK
# 监视 foo 和 bar
127.0.0.1:6379> WATCH foo bar
OK
# 只修改了 bar
127.0.0.1:6379> SET bar 20
OK
# 开启一个修改 foo 的事务
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> SET foo 2
QUEUED
127.0.0.1:6379(TX)> EXEC
# 虽然事务没有修改 bar，但是调用 EXEC 命令时仍会检查 WATCH 的所有 key
(nil)
127.0.0.1:6379> MGET foo bar
1) "1"
2) "20"
```
