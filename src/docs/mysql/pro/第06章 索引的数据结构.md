## 为什么使用索引

索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本数课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。

![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/0d06ea26feea4a6a88733411f6986f20.png)  
如上图所示，数据库没有索引的情况下，数据分布在硬盘不同的位置上面，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果数据顺序摆放，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，依旧非常耗时。如果不借助任何索引结构帮助快速定位数据的话，我们查找col 2=89这条记录，就要逐行去查找、去比较。从Col 2= 34开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有上千万条数据，就意味着要做很多很多次6盘I/O才能找到。现在要查找Col 2=89这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间的就是磁盘I/O(涉及到磁盘的旋转时间（速度较快)、磁头的寻道时间(速度慢、费时))  
假如给数据使用二叉树这样的数据结构进行存储，如下图所示  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/ddcbf3981c434672b04972ad8dd0706d.png)  
对字段Col 2添加了索引，就相当于在硬盘上为Col 2维护了一个索引的数据结构，即这个二叉搜索树。二叉搜索树的每个结点存储的是<K，V>结构，key 是Col 2, value是该key所在行的文件指针〈地址)。比如:该二叉搜索树的根节点就是(34,0x07)。现在对Col 2添加了索引，这时再去查找Col 2=89这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找)。读34到内存，89>34;继续右侧数据，读89到内存，89 == 89;找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。可以发现，只需要查找两次就可以定位到记录的地址，查询速真就提高了。  
这就是为什么要建索引，目的就是 为了减少磁盘I/0的次数，加快查询速率

## 索引及其优缺点

#### 索引概述

索引是依托于具体的存储引擎的  
MySQL官方对索引的定义为:索引(Index）是帮助MySQL高效获取数据的数据结构。  
索引的本质:索引是数据结构。可以简单理解为"排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法。  
索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引挚可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。

#### 索引优点

(1)类似大学国书馆建书目索引，提高数据检索的效率，降低数据库的IO成本，这也是创建索引最主要的原因  
(2）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性  
(3)在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。  
(4)在使用分组和排序子句进行数据查询时，可以显著减少查找中分组和排序的时间，降低了CPU的消耗。

#### 索引缺点

增加索引也有许多不利的方面，主要表现在如下几个方面:  
(1）创建索引和维护索引要耗费时间，并且随着数据量的增加。所耗费的时间也会增加。  
(2）索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸  
(3）虽然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。  
因此，选择使用索引时，需要综合考虑索引的优点和缺点。

> 提示:  
> 索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。

## lnnoDB中索引的推演

#### 索引之前的查找

先来看一个精确匹配的例子:

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

##### 在一个页中的查找

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况:

- 以主键为搜索条件  
    可以在页目录中使用二分法快速定位到对应的值，然后再遍历该值对应分组中的记录即可快速找到指定的记录。
    
- 以其他列作为搜索条件  
    因为在数据页中并没有对非主键列建立所谓的页目录，所以无法通过二分法快速定位相应的值。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。
    

##### 在很多页中查找

大部分情况下表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤:  
1.定位到记录所在的页  
2.从所在的页内中查找相应的记录  
在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于并不能快速的定位到记录所在的页，所以只能从一个页沿着双向链表一直往下找，在每一个页中根据上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的。如果一个表有一亿条记录呢?此时索引应运而生。

#### 设计索引

建一个表：

```sql
CREATE TABLE index_demo(
c1 INT,
c2 INT,
c3 CHAR(1),
PRIMARY KEY(c1)
) ROW_FORMAT = Compact;##ROW_FORMAT--行格式
```

这个新建的 index\_demo 表中有2个INT类型的列，1个CHAR(1)类型的列，而且规定了c1列为主键，这个表使用 Compact 行格式来实际存储记录的。这里简化了index\_demo表的行格式示意图  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/63cc540ed3f84f9d996990df50db239f.png)  
在示意图里展示记录的这几个部分:  
**record\_type :** 记录头信息的一项属性，表示记录的类型，0表示普通记录、2表示最小记录、3表示最大记录、1暂时还没用过，下面讲。  
**next\_record** : 记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，用箭头来表明下一条记录是谁。  
**各个列的值**: 这里只记录在index\_demo表中的三个列，分别是c1、c2和c3。  
**其他信息**∶除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息  
将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：

![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/ca8a36130c7d492bae7b2f8b09628c57.png)  
把一些记录放到页里的示意图就是下面这个基本的数据页模型：  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/baa4b15f10254d0d95bbc640c0fc6426.png)

##### 一个简单的索引设计方案

在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？  
因为各个页中的记录并没有规律，并不知道搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。  
所以如果想快速的定位到需要查找的记录在哪些数据页中该咋办？  
可以为快速定位记录所在的数据页而建立一个目录 ，`建这个目录必须满足下面一、二的规定：`  
`**一、下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。**`  
假设:每个数据页最多能存放3条记录(实际上一个数据页非常大，可以存放下好多记录)。有了这个假设之后我们向index\_demo表插入3条记录:

```sql
INSERT INTO index_dema VALUES ( 1,4,'u '),(3,9, 'd')， (5, 3, 'y ' );
```

那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/73efe83e62c84ada8ba3874fbec84cbe.png)  
从图中可以看出来, index\_demo表中的3条记录都被插入到了编号为10的数据页中了。此时再来插入一条记录:

```sql
INSERT INTO index _demo VALUES(4,4, 'a' };
```

因为页10最多只能放3条记录，所以我们不得不再分配一个新页:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/2aec7c69af8b41a186a31621b7ae8782.png)  
注意，新分配的数据页编号可能并不是连续的。它们只是通过维护着上一个页和下一个页的编号而建立了链表关系。另外，页10中的用户记录最大的主键值是5，而页28中有一条记录的主键值是4，因为5 > 4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求。所以在插入主键值为4的记录的时候需要伴随着一次记录移动，也就是把主键值为4的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/319b0d01b4ae42af8c2fda6855dece00.png)  
这个过程表明了在对页中的记录进行增删改操作的过程中，必须通过一些诸如记录移动的操作来始终保证这个状态一直成立:下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为`**页分裂**`  
`**二、给所有的页建立一个目录项**`  
由于数据页的编号可能是不连续的，所以在向index\_demo表中插入许多条记录后，可能是这样的效果:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/3cab9da6c5a646b2b657430dc1480c88.png)  
因为这些16KB的页在物理存储上是不连续的，所以如果想从这么多页中根据主键值快速定位某些记录所在页，需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分:

- 页的用户记录中最小的主键值，用key来表示。
- 页号，用page\_no表示。

所以为上面几个页做好的目录就像这样子:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/c14160428a854c0992a30d61ca2f24ba.png)  
以页28 为例，它对应目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键值 5 。只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键  
值快速查找某条记录的功能了。  
比如：查找主键值为 20 的记录，具体查找过程分两步：

1. 先从目录项中根据二分法快速确定出主键值为20的记录在目录项3中（因为 12 < 20 <  
    209 ），它对应的页是页9 。
2. 再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。  
    至此，针对数据页做的简易目录就搞定了。这个**目录**有一个别名，称为**索引**

#### InnoDB中的索引方案

##### 迭代1次:目录项记录的页

上边称为一个简易的索引方案，是因为为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存放，但是这样做有几个问题:

- InnoDB是使用页来作为管理存储空间的基本单位，最多能保证16KB的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数且非常多的表是不现实的。
- 实际中时常会对记录进行增删，假设把页28中的记录都删除了，那意味着目录项2也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下。这样牵一发而动全身的操作效率很差

所以，需要一种可以灵活管理所有目录项的方式。可以发现目录项其实长得跟用户记录差不多，只不过目录项中的两个列是主键和页号而已，为了和用户记录做一下区分，把这些用来表示目录项的记录称为目录项记录。那InnoDB怎么区分一条记录是普通的用户记录还是目录项记录呢?使用记录头信息里的record\_type属性，它的各个取值代表的意思如下:

- 0：普通的用户记录
- 1：目录项记录
- 2：最小记录
- 3：最大记录

现在把上面使用到的目录项放到数据页中的样子就是这样:![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/87c1cee45f294f5c91a49d39c08180af.png)  
从图中可以看出来，新分配了一个编号为30的页来专门存储目录项记录。  
再次强调目录项记录和普通的用户记录的异同  
不同点：

- 目录项记录的record\_type值是1，而普通用户记录的record\_type值是0
- 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含 很多列 ，另外还有InnoDB自己添加的隐藏列
- 了解：记录头信息里还有一个叫min\_rec\_mask的属性，只有在存储目录项记录的页中的主键值  
    最小的目录项记录的min\_rec\_mask值为1 ，其他别的记录的 min\_rec\_mask 值都是 0

相同点：

- 两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。

现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1. 先到存储目录项记录的页，也就是页30中通过二分法快速定位到对应目录项，因为 12 < 20 <209 ，所以定位到对应的记录所在的页就是页9。
2. 再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。

##### 迭代2次：多个目录项纪录的页

虽然说目录项记录中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16KB大小，能存放的目录项记录也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，如何处理呢?  
这里假设一个存储目录项记录的页最多只能存储4条目录项记录，所以如果此时再向上图中插入一条主键值为320的用户记录的话，那就需要分配一个新的存储目录项记录的页:

![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/0b549e6db8e1432b9ea195138bdbffb5.png)  
从图中可以看出，插入一条主键值为320的用户记录之后需要两个新的数据页：  
为存储该用户记录而新生成了页31 。  
因为原先存储目录项记录的页30的容量已满 （前边假设只能存储4条目录项记录），所以不得  
不需要一个新的页32来存放页31对应的目录项  
现在因为存储目录项记录的页不止一个，所以如果想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：

1. 确定目录项记录页  
    我们现在的存储目录项记录的页有两个，即页30和页32 ，又因为页30表示的目录项的主键值的范围是 \[1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目  
    录项记录在 页30 中。
2. 通过目录项记录页 确定用户记录真实所在的页  
    在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式说过了。
3. 在真实存储用户记录的页中定位到具体的记录。

树的高度越低，IO次数越少！

##### ③ 迭代3次：目录项记录页的目录页

问题来了，在这个查询步骤的第1步中需要定位存储目录项记录的页，但是这些页是不连续的，如果表中的数据非常多则会产生很多存储目录项记录的页，那怎么根据主键值快速定位一个存储目录项记录的页呢?那就为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样了:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/8df3c5786afd43fcaa5cf9874c7261f4.png)  
如图，生成了一个存储更高级目录项的页33 ，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在 \[1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值不小于320 的话，就到页32中查找更详细的目录项记录。  
可以用下边这个图来描述它：

![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/b75c1e49ae884e0e99c37b030e445156.png)  
这个数据结构，就是 B+树 。上面的每个蓝框表示一个数据页，最下面的叶子节点中存放了真实的一条条数据，这些数据之间用单向链表连接，叶子节点之间用双向链表连接。非叶子节点是目录页。

##### B+Tree

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放用户记录的那层为第 0 层，之后依次往上加。之前做了一个非常极端的假设：存放用户记录的页最多存放3条记录 ，存放目录项记录的页最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存放 1000条目录项记录 ，那么：  
如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。  
如果B+树有2层，最多能存放 1000×100=10,0000 条记录。  
如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。  
如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记  
录！！！  
表里能存放 100000000000 条记录吗？所以一般情况下，用到的B+树都不会超过4层 ，那通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过二分法实现快速定位记录。

#### 常见索引概念

索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。也可以把非聚集索引称为二级索引或者辅助索引。

##### [聚簇索引](https://so.csdn.net/so/search?q=%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95&spm=1001.2101.3001.7020)

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式(所有的用户记录都存储在了叶子节点)，也就是所谓的索引即数据,数据即索引。

> 术语"聚簇"表示数据行和相邻的键值聚簇的存储在一起。

`**特点：**`  
1.使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：  
1)页内的记录是按照主键的大小顺序排成一个单向链表 。  
2)各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表 。  
3)存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表 。  
2\. B+树的 叶子节点 存储的是完整的用户记录。  
所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。  
把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建,InnoDB存储引擎会自动地创建聚簇索引。

`**优点**`

- 数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
- 聚簇索引对于主键的 排序查找 和 范围查找 速度非常快
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 节省了大量的IO操作 。

`**缺点：**`

- 插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，一般都会定义一个自增的ID列为主键
- 更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，一般定义主键为不可更新
- 二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据

`**限制:**`

- 对于MysQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MylSAM并不支持聚簇索引。
- 由于数据物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引。一般情况下就是该表的主键。
- 如果没有定义主键，InnoDB会选择非空的唯一索引代替。如果没有这样的索引,InnoDB会隐式的定义一个主键来作为聚簇索引
- 为了充分利用聚簇索引的银簇的特性，所以InnoDB表的主键列尽量选用有序的顺序id，而不建议用无序的id,**比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长**

##### 二级索引（辅助索引、非聚簇索引）

上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果想以别的列作为搜索条件该怎么办呢?肯定不能是从头到尾沿着链表依次遍历记录一遍。  
答案:可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。比方说用c2列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/5c57b1e8e7cd4b6ab390b3807fda46c3.png)  
这个B+树与上边介绍的聚簇索引有几处不同:  
1.使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：

- 页内的记录是按照c2列的大小顺序排成一个单向链表
- 各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表
- 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个双向链表

2.B+树的叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值  
3.目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配  
所以如果想通过c2列的值查找某些记录的话就可以使用刚刚建好的这个B+树了  
以查找c2列的值为4的记录为例，查找过程如下:

1.确定目录项记录页  
根据根页面，也就是页44，可以快速定位到目录项记录所在的页为页42(因为2<4< 9 )  
2.通过目录项记录页确定用户记录真实所在的页  
在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2<4<=4，所以确定实际存储用户记录的页在页34和页35中  
3．在真实存储用户记录的页中定位到具体的记录: 到页34和页35中定位到具体的记录  
4.但是这个B+树的叶子节点中的记录只存储了c2和c1〔也就是主键）两个列，所以必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。

`**概念：回表**`  
根据这个以c2列大小排序的B+树只能确定要查找记录的主键值，所以如果想根据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程称为回表 。也就是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！  
`**问题**：`  
为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗

`**回答:**`  
如果把完整的用户记录放到叶子节点是可以不用回表。但是太占地方了，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了  
因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引(英文名secondary index )，或者辅动索引。由于使用的是c2列的大小作为B+树的排序规则，所以也称这个B+树是为c2列建立的索引

非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/ee0e3fb09b5a4b79a44d95822f54a995.png)  
小结:聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别:  
1.聚簇索引的叶子节点存储的就是数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序  
2.一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇聚簇索引，也就是多个索引目录提供数据检索  
3.使用聚簇索引的时候，数据的查询效率高(不用回表)，但如果对数据进行插入，删除，更新等操作，效率会比聚簇索引低

##### [联合索引](https://so.csdn.net/so/search?q=%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95&spm=1001.2101.3001.7020)（属于非聚簇索引）

可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说想让B+树按  
照 c2和c3列 的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照c2列进行排序
- 在记录的c2列相同的情况下，采用c3列进行排序

为c2和c3列建立的索引的示意图如下：  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/3a7de1d2c2f94fc7b31f85803d171c27.png)  
如图所示，需要注意以下几点:

- 每条目录项记录都由c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。
- B+树叶子节点处的用户记录由c2、c3和主键c1列组成

注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引 ，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

- 建立联合索引只会建立如上图一样的1棵B+树。
- 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。

#### InnoDB的B+树索引的注意事项

##### 一、根页面位置万年不动

前边介绍B+树索引的时候，为了理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的:

- 每当为某个表创建一个B+树索引(聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录
- 随后向表中插入用户记录时，先把用户记录存储到这个根节点中
- 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值)的大小就会被分配到页a或者b中，而根节点便升级为存储目录项记录的页

这个过程需要注意的是:一个B+树索引的根节点自诞生起，便不会再移动。这样只要对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引

##### 二、内节点(非叶节点)中目录项记录的唯一性

B+树索引的内节点中目录项记录的内容是索引列＋页号的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿index\_dema表为例，假设这个表中的数据是这样的:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/ef82909cdc6e45af9e1e9ff7b2b3a356.png)

如果二级索引中目录项记录的内容只是索引列＋页号的搭配的话，那么为c2列建立索引后的B+树应该长这样:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/5045fb59be324d5fb457553a6d4175e0.png)  
如果想新插入一行记录，其中c1、c2、c3的值分别是: 9、1、 ‘c’，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题:由于页3中存储的目录项记录是由c2列＋页号的值构成的，页3中的两条目录项记录对应的c2列的值都是1，而新插入的这条记录的c2列的值也是1，那这条新插入的记录到底应该放到页4中，还是应该放到页5中啊?答案是:对不起，懵了。

为了让新插入记录能找到自己在那个页里，需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的:

- 索引列的值
- 主键值
- 页号

也就是把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以为c2列建立二级索引后的示意图实际上应该是这样子的:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/5d34fc023bf04b22ad67ec9a00af0cc3.png)  
这样再插入记录(9，1， ‘c’)时，由于页3中存储的目录项记录是由c2列＋主键＋页号的值构成的，可以先把新记录的c2列的值和页3中各目录项记录的c2列的值作比较，如果c2列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的c2列＋主键的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到页5中。

##### 三、一个页面最少存储2条记录

一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错!这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢?那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录?所以InnoDB的一个数据页至少可以存放两条记录。

## MyISAM中的索引方案

B树索引适用存储引擎如表所示：

| 索引 / 存储引擎 | MyISAM | InnoDB | Memory |
| --- | --- | --- | --- |
| B-Tree索引 | 支持 | 支持 | 支持 |

即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是[Btree](https://so.csdn.net/so/search?q=Btree&spm=1001.2101.3001.7020)索引；而Memory默认的索引是Hash索引。  
MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址 。

#### MylSAM索引的原理

InnoDB中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而MyISAM的索引方案虽然也使用树形结构，但是却将索引和数据分开存储:  
将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并没有刻意按照主键大小排序，所以并不能在这些数据上使用二分法进行查找  
使用MyISAN存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。MyISAN会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是`**主键值＋数据记录地址**`的组合。  
下图是MyISAM索引的原理图：  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/35a67a717dbb480299d44cc44ed32a9c.png)  
这里设表一共有三列，假设以col1为主键，上图是一个MyISAM表的主索引(Primary key)示意。可以看出MylISAM的`**索引文件仅仅保存数据记录的地址**`。在MyISAM中，主键索引和二级索引(Secondary key)在结构上没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复（需要注意的是，MylSAM中没有聚簇索引和非聚簇索引之说）。如果在Col2上建立一个二级索引，则此索引的结构如下图所示:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/9e64c09dec754273b22ea096b15e273e.png)

#### MyISAM 与 InnoDB对比

`**MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：**`  
① 在InnoDB存储引擎中，只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM 中却需要进行一次回表操作（原因是没有聚簇索引），意味着MyISAM中建立的索引相当于全部都是二级索引  
② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的 ，索引文件仅保存数据记录的地址  
③ InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。  
④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。  
⑤ InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。

![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/e61b0f8fc98d473d9de7c7f574ef1570.png)  
`**小结:**`  
了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如:  
举例1:知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大  
举例2:用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择

## 索引的代价

索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：  
`**空间上的代价**`  
每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。  
`**时间上的代价**`  
每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且B+树每层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。

> 一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，需要学学这些索引在哪些条件下起作用

## MySQL数据结构选择的合理性

从MysQL的角度讲，不得不考虑一个现实问题就是磁盘IO。如果能让索引的数据结构尽量减少硬盘的I/O操作，所消耗的时间也就越小。可以说，磁盘的I/0操作次数对索引的使用效率至关重要。

查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，**数据库索引是存储在外部磁盘上的**。当利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么My$QL衡量查询效率的标准就是I/O磁盘次数。

#### 全表遍历

这里都懒得说了

#### Hash结构

Hash本身是一个函数，又被称为散列函数，它可以大幅提升检索数据的效率,  
Hash算法是通过某种确定性的算法（比如MD5、SHA1、SHA2、SHA3）将输入转变为输出。相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，在输出中通常会有不同的结果。

举例:如果想要验证两个文件是否相同，那么不需要把两份文件直接拿来比对，只需要让对方把Hash函数计算得到的结果告诉你即可，然后在本地同样对文件进行Hash函数的运算，最后通过比较这两个Hash 函数的结果是否相同，就可以知道这两个文件是否相同。

`**加速查找速度的数据结构。常见的有两类:**`  
⑴树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是0(log2N)  
⑵哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是0(1);  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/b4c7a53df00e4d56a5bf4fb5087aa3e7.png)  
采用Hash进行检索效率非常高，基本上一次检索就可以找到数据，而B+树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次IO操作，从效率来说Hash比 B+树更快。  
在哈希的方式下，一个元素k处于h(k)中，即利用哈希函数h，根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表T\[o…m-1\]的槽位上  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/3849833b03844e10b9bca78dd56ea9b3.png)  
上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 链接法 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/cf93d9a197b44b10b40ffc44f6b0600d.png)  
实验：体会数组全表遍历和hash表的查找方面的效率区别

```sql
// 算法复杂度为 O(n)
@Test
public void test1(){
int[] arr = new int[100000];
for(int i = 0;i < arr.length;i++){
arr[i] = i + 1;
}
long start = System.currentTimeMillis();
for(int j = 1; j<=100000;j++){
int temp = j;
for(int i = 0;i < arr.length;i++){
if(temp == arr[i]){
break;
}
}
}
long end = System.currentTimeMillis();
System.out.println("time： " + (end - start)); //time： 823
}
```

```sql
//算法复杂度为 O(1)
@Test
public void test2(){
HashSet<Integer> set = new HashSet<>(100000);
for(int i = 0;i < 100000;i++){
set.add(i + 1);
}
long start = System.currentTimeMillis();
for(int j = 1; j<=100000;j++) {
int temp = j;
boolean contains = set.contains(temp);
}
long end = System.currentTimeMillis();
System.out.println("time： " + (end - start)); //time： 5
}
```

`**Hash结构效率高，那为什么索引结构要设计成树型呢？**`  
原因1: Hash索引仅能满足(=)(）和IN查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为O(n);而树型的“有序"特性，依然能够保持O(log2N)的高效率。  
原因2: Hash索引还有一个缺陷，数据的存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。  
原因3∶对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。  
原因4:对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是素引列的重复值如果很多，效率就会降低。这是因为遇到 Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以,Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。  
`**Hash索引适用存储引擎如表所示:**`

| 索引 / 存储引擎 | MyISAM | InnoDB | Memory |
| --- | --- | --- | --- |
| HASH索引 | 不支持 | 不支持 | 支持 |

`**Hash索引的适用性:**`  
Hash索引存在着很多限制，相比之下在数据库中B+树索引的使用面会更广，不过也有一些场景采用Hash索引效率更高，比如在键值型（Key-Value）数据库中，**Redis 存储的核心就是Hash表**

MysQL中的 Memory存储引擎支持Hash存储，如果需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash 计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行等值查询的时候，采用Hash索引是个不错的选择。  
另外，InnoDB本身不支持 Hash索引，但是提供自适应Hash 索引(Adaptive Hash Index)。什么情况下才会使用自适应Hash 索引呢?  
如果某个数据经常被访问，当满足一定条件的时候（比如某个内容的查询数目超过某个值），就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash索引的优点  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/334870abf03a4807962435d0af702565.png)  
采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。  
可以通过 innodb\_adaptive\_hash\_index 变量来查看是否开启了自适应 Hash，比如：

```sql
show variables like '%adaptive_hash_index';
/*
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
| innodb_adaptive_hash_index | ON    |
+----------------------------+-------+
*/
```

#### 二叉搜索树

如果利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的  
**1.二叉搜索树的特点**

- 一个节点只能有两个子节点，也就是一个节点度不能超过2
- 左子节点<本节点;右子节点>=本节点，比我大的向右，比我小的向左

**2.查找规则**  
先来看下最基础的二叉搜索树(Binary Search Tree)，搜索某个节点和插入节点的规则一样，假设搜索插入的数值为key :  
1.如果key大于根节点，则在右子树中进行查找  
2。如果 key小于根节点,则在左子树中进行查找  
3.如果key等于根节点，也就是找到了这个节点，返回根节点即可。  
举个例子，对数列(34，22，89，5，23，77，91)创造出来的二分查找树如下图所示:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/36a58bcd53f2472cb15ac2bf32432b02.png)  
但是存在特殊的情况，就是有时候二叉树的深度非常大。比如给出的数据顺序是(5,22,23,34,77,89,91)，创造出来的二分搜索树如下图所示:  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/df2c26818d2943129d676070eca0a948.png)  
上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了0(n)。可以看出来第一个树的深度是3，也就是说最多只需3次比较，就可以找到节点，而第二个树的深度是7，最多需要7次比较才能找到节点。  
为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把原来"瘦高"“的树结构变的“矮胖”，树的每层的分叉越多越好。

#### AVL树

为了解决上面二叉查找树退化成链表的问题，人们提出了平衡二叉搜索树(Balanced Binary Tree)，又称为AVL树(有别于AVL算法)，它在二叉搜索树的基础上增加了约束，具有以下性质:  
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。  
这里说一下，常见的**平衡二叉树**有很多种，包括了平衡二叉搜索树、红黑树、数堆、伸展树。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是0(log2n).

数据查询的时间主要依赖于磁盘I/O的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是o(log2n)，当n比较大时，深度也是比较高的，比如下图的情况;  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/8a6b6085e2c24a168e52d4f6903604c7.png)  
每访问一次节点就需要进行一次磁盘I/O操作，对于上面的树来说，需要进行5次I/O操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘I/O操作次数多，会影响整体数据查询的效率。  
针对同样的数据，如果把二叉树改成M叉树(M>2）呢?当M=3时，同样的31个节点可以由下面的三叉树来进行存储:![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/3c5047568ccd49119e6dbfd173692ff5.png)  
可以看到此时树的高度降低了，当数据量N大的时候，以及树的分叉数M大的时候，M叉树的高度会远小于二叉树的高度(M>2)。所以，我们需要把树从"瘦高"变"矮胖”。

#### B-Tree

B树的英文是Balance Tree，也就是多路平衡查找树。简写为B-Tree (注意横杠表示这两个单词连起来的意思，不是减号)。它的高度远小于平衡二叉树的高度。  
B树的结构如下图所示:![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/ff72a3d69be249d8929b374d8a6e193c.png)  
B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，M称为B树的阶。每个磁盘块中包括了关键字和子节点的指针。如果一个磁盘块中包括了x个关键字，那么指针数就是x+1。对于一个100阶的B树来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合合的，因为树的高度要远小于二叉树的高度。  
一个M阶的B树(M>2)有以下的特性:  
1、根节点的儿子数的范围是\[2,M\]。  
2.每个中间节点包含k-1个关键字和k个孩子，孩子的数量=关键字的数量+1，k的取值范围为\[ceil(M/2),M\]。  
3.叶子节点包括 k-1个关键字(叶子节点没有孩子)，k的取值范围为\[ceil(M/2),M\]。  
4.假设中间节点节点的关键字为:Key\[1\],Key\[2\]… Key|k-1\]，且关键字按照升序排序，即Key\[i\]<Key\[i+1\]。此时k-1个关键字相当于划分了k个范围，也就是对应着k个指针，即为: P\[1\],P\[2\]…P\[K\]，其中 P\[1\]指向关键字小于Key\[1\]的子树，P\[i\]指向关键字属于(Key\[i-1\], Key\[i\])的子树，P\[K\]指向关键字大于Key\[k-1\]的子树。  
5.所有叶子节点位于同一层。  
上面那张图所表示的B树就是一棵3阶的B树。可以看一下磁盘块2，里面的关键字为(8，12)，它有3个孩子(3，5)，(9，10)和(13，15)，能看到(3，5)小于8，(9，10)在8和12之间，而(13，15)大于12，刚好符合刚才给出的特征。  
然后来看一下如何用B树进行查找。假设想要查找的关键字是9，那么步骤可以分为以下几步:  
1.与根节点的关键字(17，35)进行比较，9小于17那么得到指针P1  
2.按照指针P1找到磁盘块2，关键字为(8，12)，因为9在8和12之间，所以得到指针P2  
3.按照指针P2找到磁盘块6，关键字为(9，10)，然后找到了关键字9

能看出来在B树的搜索过程中，比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行I/O操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。B树相比于平衡二叉树来说磁盘I/O操作要少，在数据查询中比平衡二叉树效率要高。所以只要树的高度足够低，IO次数足够少。就可以提高查询性能。  
`**小结**`  
1.B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡  
2.关键字集合分布在整棵树中,即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束  
3.其搜索性能等价于在关键字全集内做一次二分查找  
**再举例1:**  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/9b7db685af1641b8b3f0ab8f2c662b80.png)

#### B+Tree

B+树也是一种多路搜索树，基于B树做出了改进，主流的DBMS都支持B+树的索引方式，比如 MysQL。相比于B-Tree,B+Tree适合文件索引系统

##### B+ 树和 B 树的差异：

1.有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。  
2.非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最  
小）。  
3.非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非叶子节点既保存索引，也保存数据记录 。  
4\. 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。  
下图就是一棵B+树，阶数为3，根节点中的关键字1、18、35分别是子节点(1，8，14)， (18，24，31)和(35，41，53)中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个指向下一个节点的指针，这样就形成了一个链表  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/7e8cf5ba57de4688ad6d28a8d6971ed5.png)  
比如，想要查找关键字16，B+树会自顶向下逐层进行查找:  
1.与根节点的关键字(1，18，35)进行比较，16在1和18之间。得到指针P1(指向磁盘块2)  
2.找到磁盘块2，关键字为(1，8，14)，因为16大于14，所以得到指针P3(指向磁盘块7)  
3.找到磁盘块7，关键字为(14，16，17)，然后找到了关键字16，所以可以找到关键字16所对应的数据。

整个过程一共进行了3次I/O操作，看起来B+树和B树的查询过程差不多，但是B+树和B树有个根本的差异在于，B+树的中间节点并不直接存储数据。这样的好处都有什么呢?  
首先，B+树查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时点需要访问到叶子节点才能找到关键字

其次，B+树的查询效率更高。这是因为B树非叶子节点也要存储数据，B+树非叶子节点不用存储数据。对于相同大小的页，B+树存储的目录项更多，故通常情况下B+树比B树更矮胖(阶数更大，深度更低)，查询所需要的磁盘I/O也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。

不仅是对单个关键字的查询上，在查询范围上，B+树的效率也比B树高。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找。效率要低很多

> B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。  
> 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。

##### 思考题一

思考题：为了减少IO，索引树会一次性加载吗？

> 1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。  
> 2、当利用索引查询的时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是:逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。

##### 思考题二

思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO

> InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节）或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree中的一个节点)中大概存储  
> 16KB/(8B+8B)=1K个键值(因为是估值，为方便计算，这里的K取值为 1 0 3 10^3 103。也就是说一个深度为3的B+Tree索引可以维护 1 0 3 10^3 103\* 1 0 3 10^3 103\* 1 0 3 10^3 103\=10亿条记录。(这里假定一个数据页也存储 1 0 3 10^3 103条行记录数据了)  
> 实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在2-4层。MysQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘1/O操作。

##### 思考题三

思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？

> 1、B+树的磁盘读写代价更低  
> B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。  
> 2、B+树的查询效率更加稳定  
> 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

##### 思考题四

思考题：Hash 索引与 B+ 树索引的区别

> 之前讲到过B+树索引的结构，Hash索引结构和B+树的不同，因此在索引使用上也会有差别。  
> 1、Hash索引不能进行范围查询，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。|  
> 2、Hash索引不支持联合索引的最左侧原则（即联合索引的部分索引无法使用)，而B+树可以。对于联合索引来说，Hash索引在计算 Hash值的时候是将索引键合并后再一起计算 Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。  
> 3、Hash索引不支持ORDER BY排序，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY排序优化的作用。同理，我们也无法用 Hash索引进行模糊查询，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询(比如%结尾)的话就可以起到优化作用。  
> 4、InnoDB不支持哈希索引

##### 思考题五

思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？

> 如果使用的是MysQL的话，需要了解MysQL的存储引擎都支持哪些索引结构，如下图所示（参考来源 https://dev.mysqL.com/doc/refman/8.o/en/create-index.html)。如果是其他DBMS，可以参考相关的DBMS文档。  
> 能看到，针对InnoDB和MyISAM存储引擎，都会默认采用B+树索引，无法使用Hash 索引。InnoDB提供的自适应Hash是不需要手动指定的。如果是Memory/Heap和NDB存储引擎，是可以进行选择Hash 索引的。

#### R树

R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度地图这种超大数据库中，这种方法便必定不可行了。R树就很好的 **解决了这种高维空间搜索问题**

它把B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来 存储高维数据的平衡树 。相对于B-Tree，R-Tree的优势在于范围查找。

| 索引 / 存储引擎 | MyISAM | InnoDB | Memory |
| --- | --- | --- | --- |
| R-Tree索引 | 支持 | 支持 | 不支持 |

#### 小结

使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利(提升查询效率）和弊(维护索引所需的代价)。  
在实际工作中，还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管索引不是万能的，但数据量大的时候不使用素引是不可想象的，毕竟索引的本质。是帮助我们提升数据检索的效率。

## 附录：算法的时间复杂度

同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法  
![请添加图片描述](http://p6ui.toweydoc.tech:20080/images/stydocs/db4f7ede6bd4498684ecb97e25186189.png)